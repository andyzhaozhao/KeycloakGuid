{"./":{"url":"./","title":"序言","keywords":"","body":"KeycloakGuidKeycloakGuid Keycloak 是一个为浏览器和 RESTful Web 服务提供 SSO 的集成。基于 OAuth 2.0 和 JSON Web Token(JWT) 规范。最开始是面向 JBoss 和 Wildfly 通讯，但已经计划为其他诸如 Tomcat、Jetty、Node.js、Rails、Grails 等环境提供解决方案。 主要功能： SSO and Single Log Out for browser applications Social Broker. Enable Google, Facebook, Yahoo, Twitter social login with no code required. Optional User Registration Password and TOTP support (via Google Authenticator). Client cert auth coming soon. Customizable themes for user facing pages OAuth Bearer token auth for REST Services Integrated Browser App to REST Service token propagation OAuth 2.0 Grant requests CORS Support CORS Web Origin management and validation Completely centrally managed user and role mapping metadata. Minimal configuration at the application side Admin Console for managing users, roles, role mappings, applications, user sessions, allowed CORS web origins, and OAuth clients. Deployable as a WAR, appliance, or an Openshift cloud service (SaaS). Supports JBoss AS7, EAP 6.x, and Wildfly applications. Plans to support Node.js, RAILS, GRAILS, and other non-Java applications. Javascript/HTML 5 adapter for pure Javascript apps Session management from admin console Revocation policies Password policies OpenID Connect Support Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-28 14:07:19 "},"Getting Started Guide.html":{"url":"Getting Started Guide.html","title":"Keycloak入门指南","keywords":"","body":"Keycloak入门指南 1. 概述 2. 安装和启动 2.1. 安装分发文件 2.2. 启动服务器 2.3. 创建管理员帐户 2.4. 登录管理控制台 3. 创建领域和用户 3.1. 在你开始之前 3.2. 创建一个新领域 3.3. 创建新用户 3.4. 用户帐户服务 4. 保护JBoss Servlet应用程序 4.1. 在你开始之前 4.2. 安装客户端适配器 4.3. 下载，构建和部署应用程序代码4.4. 创建和注册客户端 4.5. 配置子系统 Keycloak入门指南 原文地址: https://www.keycloak.org/docs/latest/getting_started/index.html 1. 概述 本指南可帮助您开始使用Keycloak。 它涵盖了服务器配置和默认数据库的使用。 不包括高级部署选项。 有关功能或配置选项的更深入说明，请参阅其他参考指南。 2. 安装和启动 本节介绍如何在独立模式下启动Keycloak服务器，设置初始管理员用户，以及登录Keycloak管理控制台。 2.1. 安装分发文件 下载Keycloak服务器分发文件: keycloak-6.0.1.[zip|tar.gz] 该文件可以从 Keycloak downloads下载. keycloak-6.0.1.[zip|tar.gz]文件是服务器专用的分发版。它只包含运行Keycloak服务器的脚本和二进制文件。 将文件放在您选择的目录中，并使用unzip或tar实用程序来提取它。 Linux/Unix $ unzip keycloak-6.0.1.zip or $ tar -xvzf keycloak-6.0.1.tar.gz Windows > unzip keycloak-6.0.1.zip 2.2. 启动服务器 要启动Keycloak服务器，请转到服务器分发的bin目录并运行standalone启动脚本： Linux/Unix $ cd bin $ ./standalone.sh Windows > ...\\bin\\standalone.bat 2.3. 创建管理员帐户 服务器启动后，在web浏览器中打开http://localhost:8080/auth。欢迎页面将指示服务器正在运行。 输入用户名和密码来创建初始管理用户。 该帐户将被允许登录到master(主) realm(域)的管理控制台，您将从该控制台创建域和用户，并注册应用程序，这些应用程序将由Keycloak进行保护。 如果使用localhost连接，则只能在欢迎页面上创建初始管理员用户。 这是一项安全预防措施。 您可以使用add-user-keycloak.sh脚本在命令行创建初始管理员用户。 有关详细信息，请参阅服务器安装和配置指南和服务器管理指南。 2.4. 登录管理控制台 创建初始管理员帐户后，请使用以下步骤登录管理控制台： 单击 Welcome 页面上的 Administration Console 链接或直接转到控制台URL http://localhost:8080/auth/admin/ 在Welcome页面上键入您创建的用户名和密码，打开Keycloak Admin Console。 Admin Console(管理控制台) 3. 创建领域和用户 在本节中，您将在Keycloak管理控制台中创建一个新领域，并向该领域添加新用户。 您将使用该新用户登录到您的新域并访问所有用户都可以访问的内置用户帐户服务。 3.1. 在你开始之前 (https://www.keycloak.org/docs/latest/getting_started/index.html#_install-boot) 3.2. 创建一个新领域 要创建新领域，请完成以下步骤： 转到http://localhost:8080/auth/admin/并使用您在安装和启动中创建的帐户登录Keycloak管理控制台。 从Master下拉菜单中，单击Add Realm。 当您登录到主域时，此下拉菜单会列出所有现有域。 在Name字段中输入demo，然后单击Create。 创建领域后，将打开主管理控制台页面。 注意，当前的域现在设置为demo。 通过单击Select realm下拉菜单中的条目，在管理master领域和刚刚创建的领域之间切换。 3.3. 创建新用户 要在demo域中创建新用户，以及该新用户的临时密码，请完成以下步骤： 从菜单中，单击Users以打开用户列表页面。 在空用户列表的右侧，单击Add User以打开添加用户页面。 在Username`字段中输入名称; 这是唯一必填字段。 单击保存以保存数据并打开新用户的管理页面。 单击Credentials选项卡为新用户设置临时密码。 输入新密码并确认。 单击Reset Password将用户密码设置为您指定的新密码。 此密码是临时的，用户需要在首次登录后进行更改。 要创建持久密码，请在单击Reset Password之前将Temporary开关从On翻转到Off。 3.4. 用户帐户服务 创建新用户后，打开用户下拉菜单并选择Sign Out，注销管理控制台。 转到http://localhost:8080/auth/realms/demo/account并使用刚创建的用户登录您的demo域的用户帐户服务。 输入您创建的用户名和密码。 成功登录后，您将需要创建一个永久密码，除非您在创建密码时将Temporary设置更改为Off。 将打开用户帐户服务页面。 默认情况下，领域中的每个用户都可以访问此帐户服务。 在此页面中，您可以更新配置文件信息并更改或添加其他凭据。 有关此服务的详细信息，请参阅服务器管理指南。 4. 保护JBoss Servlet应用程序 本节介绍如何通过以下方式在WildFly应用程序服务器上保护Java servlet应用程序： 在WildFly应用程序服务器分发上安装Keycloak客户端适配器 在Keycloak管理控制台中创建和注册客户端应用程序 配置要由Keycloak保护的应用程序 4.1. 在你开始之前 在确保Java servlet应用程序安全之前，必须完成Keycloak的安装并创建初始管理员用户，如安装和引导中所示。 有一点需要注意：尽管WildFly与Keycloak捆绑在一起，但您不能将其用作应用程序容器。 相反，您必须在与Keycloak服务器相同的机器上运行单独的WildFly实例才能运行Java servlet应用程序。 使用与WildFly不同的端口运行Keycloak，以避免端口冲突。 要调整使用的端口，请在从命令行启动服务器时更改jboss.socket.binding.port-offset系统属性的值。 此属性的值是一个数字，将添加到Keycloak服务器打开的每个端口的基值。 要在调整端口的同时启动Keycloak服务器： Linux/Unix $ cd bin $ ./standalone.sh -Djboss.socket.binding.port-offset=100 Windows > ...\\bin\\standalone.bat -Djboss.socket.binding.port-offset=100 启动Keycloak后，转到http://localhost:8180/auth/admin/以访问管理控制台。 4.2. 安装客户端适配器 下载WildFly发行版并将其从压缩文件中提取到计算机上的目录中。 从keycloak.org下载WildFly OpenID Connect适配器分发版。 将此文件的内容解压缩到WildFly发行版的根目录中。 为您的平台运行适当的脚本： WildFly 10 和 Linux/Unix $ cd bin $ ./jboss-cli.sh --file=adapter-install-offline.cli WildFly 10 和 Windows > cd bin > jboss-cli.bat --file=adapter-install-offline.cli Wildfly 11 和 Linux/Unix $ cd bin $ ./jboss-cli.sh --file=adapter-elytron-install-offline.cli Wildfly 11 和 Windows > cd bin > jboss-cli.bat --file=adapter-elytron-install-offline.cli 此脚本将对您的应用服务器分发的…/standalone/configuration/standalone.xml文件进行必要的编辑，可能需要一些时间才能完成。 启动应用程序服务器。 Linux/Unix $ cd bin $ ./standalone.sh Windows > ...\\bin\\standalone.bat 4.3. 下载，构建和部署应用程序代码 您必须在您的机器上安装以下软件，并在您的PATH路径中可用，然后才能继续: Java JDK 8 Apache Maven 3.1.1 or higher Git 您可以通过克隆https://github.com/keycloak/keycloak-quickstarts上的Keycloak Quickstarts存储库来获取代码。 快速入门旨在与最新的Keycloak版本一起使用。 在继续之前，请确保已启动WildFly应用程序服务器。 要下载，构建和部署代码，请完成以下步骤。 克隆项目 $ git clone https://github.com/keycloak/keycloak-quickstarts $ cd keycloak-quickstarts/app-profile-jee-vanilla $ mvn clean wildfly:deploy 在安装过程中，您将在应用程序服务器控制台窗口中看到一些文本滚动。 要确认应用程序已成功部署，请转至http://localhost:8080/vanilla，然后将显示登录页面。 如果单击Login，浏览器将弹出BASIC auth登录对话框。 但是，应用程序尚未受到任何身份提供程序的保护，因此您在对话框中输入的任何内容都将导致服务器发回Forbidden消息。 您可以通过查找应用程序的web.xml文件中的设置来确认应用程序当前是通过BASICauthentication保护的。 4.4. 创建和注册客户端 要在Keycloak管理控制台中定义和注册客户端，请完成以下步骤： 使用您的管理员帐户登录管理控制台。 在左上角的下拉菜单中选择并管理 Demo 领域。 单击左侧菜单中的Clients以打开“客户端”页面。 Clients(客户端) 在右侧，单击Create。 填写如下所示的字段： Add Client(添加客户端) 单击Save以创建客户端应用程序条目。 单击Keycloak管理控制台中的Installation选项卡以获取配置模板。 选择Keycloak OIDC JBoss Subsystem XML以生成XML模板。 复制内容以供下一部分使用。 模板 XML 4.5. 配置子系统 要配置部署应用程序的WildFly实例，以便Keycloak保护此应用程序，请完成以下步骤。 打开部署了应用程序的WildFly实例中的standalone/configuration/standalone.xml文件，并搜索以下文本： 修改此文本以准备粘贴内容的文件来自Keycloak OIDC JBoss Subsystem XML模板我们获得Keycloak管理控制台Installation选项卡，通过将XML条目从自动关闭更改为使用一对开放和结束标签： 将模板的内容粘贴到元素中，如下例所示： demo http://localhost:8180/auth true EXTERNAL vanilla 将name更改为vanilla.war： ... 重新启动应用程序服务器。 转到http://localhost:8080/vanilla并单击Login。 当Keycloak登录页面打开时，使用您在创建新用户中创建的用户登录。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-28 16:50:14 "},"Server Installation and Configuration Guide.html":{"url":"Server Installation and Configuration Guide.html","title":"KeyCloak服务器安装和配置指南","keywords":"","body":"KeyCloak服务器安装和配置指南 1. 指南概述 1.1. 建议额外的外部文档 2. 安装 2.1. 系统需求 2.2. 安装分布式文件 2.3. 分布式目录结构 3. 选择工作模式 3.1. 独立模式 3.2. 独立的集群模式 3.3. 域集群模式 3.4. 跨数据中心复制模式 4. 管理子系统配置 4.1. 配置SPI提供程序 4.2. 启动WildFly CLI 4.3. CLI嵌入式模式 4.4. CLI GUI模式 4.5. CLI脚本 4.6. CLI食谱 5. 特征文件 6. 关系数据库设置 6.1. RDBMS设置清单 6.2. 打包JDBC驱动程序 6.3. 声明并加载JDBC驱动程序 6.4. 修改Keycloak数据源 6.5. 数据库配置 6.6. 数据库的Unicode注意事项 7. 网络设置 7.1. 绑定地址 7.2. 套接字端口绑定 7.3. 设置 HTTPS/SSL 7.4. 传出HTTP请求 8. 集群 8.1. 推荐的网络架构 8.2. 集群示例 8.3. 设置负载均衡器或代理 8.4. 粘性会话 8.5. 多播网络设置 8.6. 确保集群通信安全 8.7. 串行化集群启动 8.8. 启动群集 8.9. 故障排除 9. 服务器缓存配置 9.1. 驱逐和到期 9.2. 复制和故障转移 9.3. 禁用缓存 9.4. 在运行时清除缓存 10. Keycloak安全代理 10.1. 代理安装和运行 10.2. 代理配置 10.3. 应用程序配置 10.4. Keycloak标识头 KeyCloak服务器安装和配置指南 原文地址: https://www.keycloak.org/docs/latest/server_installation/index.html 1. 指南概述 本指南的目的是介绍在首次启动Keycloak服务器之前需要完成的步骤。如果您只是想测试Keycloak，它几乎是用它自己的嵌入式和本地数据库开箱即用。对于将要在生产环境中运行的实际部署，您需要决定如何在运行时管理服务器配置(独立或域模式)，为Keycloak存储配置共享数据库，设置加密和HTTPS，最后设置Keycloak在集群中运行。本指南将详细介绍部署服务器之前必须进行的任何预引导决策和设置的各个方面。 需要特别注意的一点是，Keycloak派生自WildFly应用程序服务器。配置Keycloak的许多方面都围绕着WildFly配置元素。如果您想深入了解更多细节，本指南通常会将您引向手册之外的文档。 1.1. 建议额外的外部文档 Keycloak构建在WildFly应用服务器之上，它的子项目包括Infinispan(用于缓存)和Hibernate(用于持久性)。本指南只涵盖基础设施级配置的基础知识。强烈建议您仔细阅读WildFly及其子项目的文档。以下是文档链接: WildFly 16 Documentation 2. 安装 安装Keycloak非常简单，只需下载并解压缩即可。本章回顾了系统的需求以及发行版的目录结构。 2.1. 系统需求 以下是运行Keycloak身份验证服务器的要求: 能运行Java的任何操作系统 Java 8 JDK zip 或者 gzip 和 tar 至少512M内存 At least 1G of diskspace 共享的外部数据库，如PostgreSQL、MySQL、Oracle等。如果要在集群中运行，Keycloak需要一个外部共享数据库。有关更多信息，请参阅本指南的数据库配置部分。 如果您想在集群中运行，最好计算机上的网络支持多播。Keycloak可以在没有多播的情况下集群化，但这需要大量的配置更改。有关更多信息，请参见本指南的集群部分。 在Linux上，建议使用/dev/urandom作为随机数据的来源，以防止由于缺少可用的熵而导致密钥隐藏挂起，除非您的安全策略强制使用/dev/random。要在Oracle JDK 8和OpenJDK 8上实现这一点，请设置 java.security.egd系统属性为file:/dev/urandom。 2.2. 安装分布式文件 Keycloak服务器有三个可下载的发行版: 'keycloak-6.0.0.[zip|tar.gz]' 'keycloak-overlay-6.0.0.[zip|tar.gz]' 'keycloak-demo-6.0.0.[zip|tar.gz]' 'keycloak-6.0.0.[zip|tar.gz]'文件是服务器唯一的发行版。它只包含运行Keycloak服务器的脚本和二进制文件。要解压缩这个文件，只需运行操作系统的unzip或gunzip和tar实用程序。 'keycloak-overlay-6.0.0.[zip|tar.gz]'文件是一个WildFly插件，允许您在现有的WildFly发行版上安装Keycloak服务器。我们不支持用户希望在同一服务器实例上运行应用程序和Keycloak。要安装Keycloak服务包，只需将其解压到WildFly发行版的根目录中，打开shell中的bin目录并运行./jboss-cli.[sh|bat] --file=keycloak-install.cli。 'keycloak-demo-6.0.0.[zip|tar.gz]' 包含服务器二进制文件、所有文档和所有示例。它预先配置了OIDC和SAML客户机应用程序适配器，可以在不进行任何配置的情况下开箱即用地部署任何分发示例。此分发版只建议那些想要测试Keycloak的用户使用。我们不支持用户在生产环境中运行演示发行版。 要解压缩这些文件，请运行unzip或gunzip和tar实用程序。 2.3. 分布式目录结构 本章将介绍服务器分发版的目录结构。 分布式目录结构 让我们来看看其中一些目录的用途: bin/ 它包含各种脚本，可以启动服务器，也可以在服务器上执行其他管理操作。 domain/ 当在域模式中运行Keycloak时，它包含配置文件和工作目录。 modules/ 这些都是服务器使用的所有Java库。 providers/ 如果您正在为keycloak编写扩展，可以将扩展放在这里。有关这方面的更多信息，请参见服务器开发人员指南。 standalone/ 这包含配置文件和工作目录时，运行Keycloak在独立模式。 themes/ 此目录包含用于服务器显示的任何UI所需要的所有html、样式表、JavaScript文件和图像。在这里，您可以修改现有的主题或创建自己的主题。有关这方面的更多信息，请参见服务器开发人员指南。 3. 选择工作模式 在生产环境中部署Keycloak之前，您需要决定使用哪种类型的操作模式。您会在集群中运行Keycloak吗?您需要一种集中的方式来管理服务器配置吗?您选择的操作模式将影响您如何配置数据库、配置缓存，甚至如何启动服务器。 Keycloak构建在WildFly应用服务器之上。本指南只讨论在特定模式下部署的基础知识。如果您想了解这方面的具体信息，最好的去处是WildFly 16 Documentation. 3.1. 独立模式 独立的操作模式只在您希望运行一个且仅运行一个Keycloak服务器实例时才有用。它不适用于集群部署，而且所有缓存都是非分布式的，并且只在本地使用。 不建议在生产中使用独立模式，因为只有一个故障点。如果您的单机模式服务器宕机，用户将无法登录。这种模式只适用于测试驱动和使用Keycloak的功能. 3.1.1. 独立的启动脚本 当以独立模式运行服务器时，您需要运行一个特定的脚本来启动服务器，这取决于您的操作系统。这些脚本位于服务器分发版的 bin/ 目录中。 独立的启动脚本 启动服务器: Linux/Unix $ .../bin/standalone.sh Windows > ...\\bin\\standalone.bat 3.1.2. 独立的配置 本指南的大部分内容将指导您如何配置Keycloak的基础设施级别方面。 这些方面是在配置文件中配置的，该配置文件特定于Keycloak派生的应用程序服务器。在独立操作模式下，该文件位于 .. / independent /configuration/standalone.xml 中。 此文件还用于配置特定于Keycloak组件的非基础设施级别的内容。 独立的配置文件 在服务器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。而是使用命令行脚本或WildFly的web控制台。 更多信息参见WildFly 16 Documentation。 3.2. 独立的集群模式 当您希望在集群中运行Keycloak时，可以使用独立集群操作模式。此模式要求在希望运行服务器实例的每台计算机上都有Keycloak分发版的副本。这种模式最初很容易部署，但是会变得相当麻烦。要进行配置更改，您必须修改每台机器上的每个发行版。对于大型集群，这可能会耗费时间并容易出错。 3.2.1. 独立的集群配置 该发行版有一个主要预配置的app服务器配置文件，用于在集群中运行。它具有用于网络、数据库、缓存和发现的所有特定基础设施设置。此文件驻留在 …/standalone/configuration/standalone-ha.xml. 这个配置中缺少一些东西。如果不配置共享数据库连接，就不能在集群中运行Keycloak。您还需要在集群前面部署某种类型的负载均衡器。 本指南的集群 和 数据库 部分将指导您了解这些内容。 标准HA配置 在服务器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。建议使用命令行脚本或WildFly的web控制台。 更多信息参见 WildFly 16 Documentation | 3.2.2. 独立集群启动脚本 使用与在独立模式下相同的引导脚本启动Keycloak。不同之处在于，您传递了一个额外的标志来指向HA配置文件。 独立集群启动脚本 启动服务器: Linux/Unix $ .../bin/standalone.sh --server-config=standalone-ha.xml Windows > ...\\bin\\standalone.bat --server-config=standalone-ha.xml 3.3. 域集群模式 域模式是一种集中管理和发布服务器配置的方法。 在标准模式下运行集群会随着集群规模的增长而迅速恶化。每次需要更改配置时，都必须在集群中的每个节点上执行。 域模式解决了这个问题通过提供一个中心位置存储和发布配置。 设置起来可能相当复杂，但最终是值得的。这个功能被内置到WildFly应用服务器中，Keycloak就是从这个应用服务器派生的。 本指南将介绍域模式的基本知识。关于如何在集群中设置域模式的详细步骤应该从WildFly 16 Documentation. 获得。 以下是在域模式下运行的一些基本概念。 域控制器 域控制器是一个进程，负责存储、管理和发布集群中每个节点的一般配置。这个进程是集群中的节点获取其配置的中心点。 主机控制器 主机控制器负责管理特定机器上的服务器实例。 您将其配置为运行一个或多个服务器实例。域控制器还可以与每台机器上的主机控制器交互来管理集群。 为了减少运行进程的数量，域控制器还充当它所运行机器上的主机控制器。 域配置文件 域配置文件是一组命名的配置文件，可供服务器用于引导。 域控制器可以定义不同服务器使用的多个域配置文件。 服务器组 服务器组是服务器的集合。它们被管理并配置为一个。您可以将一个域配置文件分配给一个服务器组，该组中的每个服务都将使用该域配置文件作为它们的配置。 在域模式下，在主节点上启动域控制器。集群的配置位于域控制器中。 接下来，在群集中的每台计算机上启动主机控制器。 每个主机控制器部署配置指定将在该计算机上启动的Keycloak服务器实例数。 当主机控制器启动时，它启动的Keycloak服务器实例与配置时一样多。这些服务器实例从域控制器中提取配置。 3.3.1. 域配置 本指南的其他各章将介绍如何配置数据库、HTTP网络连接、缓存和其他与基础设施相关的内容。 虽然独立模式使用 standalone.xml 文件来配置这些内容，但域模式使用 .../domain/configuration/domain.xml 配置文件。 这里定义了Keycloak 服务器的域配置文件和服务器组。 domain.xml 在域控制器运行时对该文件所做的任何更改都不会生效，甚至可能被服务器覆盖。建议使用命令行脚本或WildFly的web控制台。 更多信息参见WildFly 16 Documentation 我们来看看这个 domain.xml 文件的某些内容。 auth-server-standalone 和 auth-server-clustered profile XML块是您进行大量配置决策的地方。 您将在此处配置网络连接，缓存和数据库连接等内容。 auth-server配置 ... ... auth-server-standalone配置是非集群设置。 auth-server-clustered配置是集群设置。 如果你进一步向下滚动，你会看到定义了各种socket-binding-groups。 socket-binding-groups ... ... ... 此配置定义使用每个Keycloak服务器实例打开的各种连接器的默认端口映射。 包含$ {...}的任何值都是可以在命令行上使用-D开关重写的值，例如: $ domain.sh -Djboss.http.port=80 Keycloak服务器组的定义位于 server-groups XML块中。 它指定在主机控制器启动实例时使用的域配置文件(default)以及Java VM的一些默认引导参数。 它还将socket-binding-group绑定到服务器组。 server group 3.3.2. 主机控制器配置 Keycloak附带了两个主机控制器配置文件，它们位于 .../domain/configuration/ 目录中：host-master.xml 和 host-slave.xml。 host-master.xml 配置为启动域控制器，负载均衡器和一个Keycloak服务器实例。 host-slave.xml 配置为与域控制器通信并启动一个Keycloak服务器实例。 负载均衡器不是必需的服务。 它的存在使您可以轻松地在开发计算机上测试驱动器群集。 虽然可以在生产中使用，但如果您要使用其他基于硬件或软件的负载均衡器，则可以选择替换它。 主机控制器配置 要禁用负载均衡器服务器实例，请编辑 host-master.xml 并注释掉或删除 \"load-balancer\" 条目。 ... 关于此文件的另一个有趣的事情是声明身份验证服务器实例。 它有一个port-offset设置。 domain.xmlsocket-binding-group或服务器组中定义的任何网络端口都将添加port-offset的值。 对于此示例域设置，我们执行此操作，以便负载平衡器服务器打开的端口不会与启动的身份验证服务器实例冲突。 ... 3.3.3. 服务器实例工作目录 主机文件中定义的每个Keycloak服务器实例在 …/domain/servers/{SERVER NAME} 下创建一个工作目录。可以在其中进行其他配置，并且服务器实例需要或创建的任何临时，日志或数据文件也可以放在那里。 每个服务器目录的结构最终看起来像任何其他WildFly启动的服务器。 工作目录 3.3.4. 域启动脚本 在域模式下运行服务器时，根据您的操作系统，需要运行特定的脚本来启动服务器。 这些脚本位于服务器分发的 bin/ 目录中。 域启动脚本 启动服务器: Linux/Unix $ .../bin/domain.sh --host-config=host-master.xml Windows > ...\\bin\\domain.bat --host-config=host-master.xml 运行启动脚本时，您需要通过--host-config开关传入您将要使用的主机控制配置文件。 3.3.5. 集群域示例 您可以使用开箱即用的 domain.xml 配置测试驱动器集群。这个示例域是用来在一台机器上运行并启动的: 1个域控制器 1个HTTP负载均衡器 2个Keycloak服务器实例 要模拟在两台计算机上运行集群，您将运行domain.sh脚本两次以启动两个单独的主机控制器。 第一个是主控主机控制器，它将启动域控制器，HTTP负载平衡器和一个Keycloak认证服务器实例。 第二个是从属主机控制器，它只启动一个认证服务器实例。 设置从属控制器到域控制器的连接 在启动之前，您必须配置从属主机控制器，以便它可以安全地与域控制器通信。如果不这样做，则从属主机将无法从域控制器获取集中式配置。 要设置安全连接，您必须创建服务器管理员用户和将在主服务器和从服务器之间共享的密钥。 您可以通过运行 …/bin/add-user.sh 脚本来完成此操作。 当您运行脚本时，选择 Management User 并回答 yes ，当它询问您是否将新用户用于一个AS进程以连接到另一个AS进程时。 这将生成一个秘密值，您需要将其剪切并粘贴到 …/domain/configuration/host-slave.xml 文件中。 添加: App Server Admin $ add-user.sh What type of user do you wish to add? a) Management User (mgmt-users.properties) b) Application User (application-users.properties) (a): a Enter the details of the new user to add. Using realm 'ManagementRealm' as discovered from the existing property files. Username : admin Password recommendations are listed below. To modify these restrictions edit the add-user.properties configuration file. - The password should not be one of the following restricted values {root, admin, administrator} - The password should contain at least 8 characters, 1 alphabetic character(s), 1 digit(s), 1 non-alphanumeric symbol(s) - The password should be different from the username Password : Re-enter Password : What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[ ]: About to add user 'admin' for realm 'ManagementRealm' Is this correct yes/no? yes Added user 'admin' to file '/.../standalone/configuration/mgmt-users.properties' Added user 'admin' to file '/.../domain/configuration/mgmt-users.properties' Added user 'admin' with groups to file '/.../standalone/configuration/mgmt-groups.properties' Added user 'admin' with groups to file '/.../domain/configuration/mgmt-groups.properties' Is this new user going to be used for one AS process to connect to another AS process? e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls. yes/no? yes To represent the user add the following to the server-identities definition add-user.sh不会将用户添加到Keycloak服务器，而是添加到基础JBoss企业应用程序平台。 上述脚本中使用和生成的凭据仅用于示例目的。 请使用系统上生成的。 现在将秘密值剪切并粘贴到 …/domain/configuration/host-slave.xml 文件中，如下所示： 您还需要在 …/domain/configuration/host-slave.xml 文件中添加已创建用户的 username： 运行启动脚本 由于我们在一台开发机器上模拟双节点集群，因此您将运行两次启动脚本： 启动 主 $ domain.sh --host-config=host-master.xml 启动 从属 $ domain.sh --host-config=host-slave.xml 要试用它，请打开浏览器并转到 http://localhost:8080/auth。 3.4. 跨数据中心复制模式 跨数据中心复制模式适用于您希望跨多个数据中心在集群中运行Keycloak，最常用的是使用位于不同地理区域的数据中心站点。 使用此模式时，每个数据中心都有自己的Keycloak服务器集群。 本文档将引用以下示例体系结构图来说明和描述简单的跨数据中心复制用例。 示例架构图 3.4.1. 先决条件 由于这是一个高级主题，我们建议您首先阅读以下内容，它们提供了宝贵的背景知识： 集群与Keycloak 设置跨数据中心复制时，您将使用更多独立的Keycloak集群，因此您必须了解集群的工作方式以及基本概念和要求，例如负载平衡，共享数据库和多播。 JBoss数据网格跨数据中心复制 Keycloak使用JBoss Data Grid（JDG）在数据中心之间复制Infinispan数据。 3.4.2. 技术细节 本节介绍了如何完成Keycloak跨数据中心复制的概念和详细信息。 Data(数据) Keycloak是有状态的应用程序。 它使用以下作为数据源： 数据库用于保存永久数据，例如用户信息。 Infinispan缓存用于缓存来自数据库的持久性数据，还用于保存一些短期和频繁更改的元数据，例如用于用户会话。 Infinispan通常比数据库快得多，但是使用Infinispan保存的数据不是永久性的，并且预计不会在集群重启期间持续存在。 在我们的示例架构中，有两个名为 site1 和 site2 的数据中心。 对于跨数据中心复制，我们必须确保两个数据源都可靠地工作，并且来自 site1 的Keycloak服务器最终能够读取site2上的Keycloak服务器保存的数据。 根据环境，您可以选择是否愿意： 可靠性 - 通常用于 主/主 模式。 写在site1上的数据必须立即在site2上可见。 性能 - 通常用于 主/被模式。 写在site1上的数据不需要立即在site2上可见。 在某些情况下，数据可能在site2上根本不可见。 For more details, see Modes. 3.4.3. 请求处理 最终用户的浏览器向前端负载均衡器发送HTTP请求。 此负载均衡器通常是HTTPD或WildFly，带有mod_cluster，NGINX，HA代理，或者某些其他类型的软件或硬件负载均衡器。 然后，负载均衡器将其接收的HTTP请求转发到基础Keycloak实例，这些实例可以在多个数据中心之间传播。 负载平衡器通常为粘性会话提供支持, 这意味着负载均衡器能够始终将来自同一用户的所有HTTP请求转发到同一数据中心内的同一Keycloak实例。 从客户端应用程序发送到负载均衡器的HTTP请求称为“反向通道请求”。终端用户的浏览器不会看到这些，因此不能作为用户和负载平衡器之间的粘性会话的一部分。 对于反向信道请求，负载均衡器可以将HTTP请求转发到任何数据中心中的任何Keycloak实例。 这很有挑战性，因为一些OpenID Connect和一些SAML流需要来自用户和应用程序的多个HTTP请求。 由于我们不能可靠地依赖粘性会话来强制将所有相关请求发送到同一数据中心中的同一个Keycloak实例，因此我们必须跨数据中心复制一些数据，以便在特定流期间由后续HTTP请求查看数据。 3.4.4. 模式 根据您的要求，跨数据中心复制有两种基本操作模式： 主/备 - 这里，用户和客户端应用程序仅将请求发送到单个数据中心的Keycloak节点。 第二个数据中心仅用作保存数据的备份。 如果主数据中心出现故障，通常可以从第二个数据中心恢复数据。 主/主 - 这里，用户和客户端应用程序将请求发送到两个数据中心的Keycloak节点。 这意味着数据需要立即在两个站点上可见，并且可以立即从两个站点上的Keycloak服务器中使用。 如果Keycloak服务器在site1上写入一些数据，并且要求在site1上的写入完成后，立即可以通过site2上的Keycloak服务器读取数据。 主动/被动模式对性能更好。 有关如何为任一模式配置高速缓存的详细信息，请参阅：SYNC或ASYNC备份. 3.4.5. 数据库 Keycloak使用关系数据库管理系统(RDBMS)来持久保存有关领域，客户端，用户等的一些元数据。 有关详细信息，请参阅服务器安装指南的本章。 在跨数据中心复制设置中，我们假设两个数据中心都与同一个数据库通信，或者每个数据中心都有自己的数据库节点，并且两个数据库节点在数据中心之间同步复制。 在这两种情况下，当site1上的Keycloak服务器持久保存某些数据并提交事务时，要求这些数据立即在site2上的后续数据库事务中可见。 数据库设置的细节超出了Keycloak的范围，但是像MariaDB和Oracle这样的许多RDBMS供应商都提供了复制数据库和同步复制。 我们与这些供应商一起测试Keycloak： Oracle Database 12c Release 1 (12.1) RAC Galera 3.12 cluster for MariaDB server version 10.1.19-MariaDB 3.4.6. Infinispan缓存 本节首先介绍Infinispan缓存的高级描述。 下面是缓存设置的更多细节。 Authentication sessions (认证会话) 在Keycloak中，我们有认证会话的概念。 有一个名为 authenticationSessions 的独立Infinispan缓存用于在特定用户的身份验证期间保存数据。 来自此缓存的请求通常只涉及浏览器和Keycloak服务器，而不是应用程序。 在这里，我们可以依赖粘性会话，即使您处于主/主 模式，也不需要跨数据中心复制 authenticationSessions 缓存内容。 Action tokens (动作令牌) 我们还有动作令牌的概念， 通常用于用户需要通过电子邮件异步地确认操作的场景。例如，在“忘记密码”流期间，actiontokenInfinispan缓存用于跟踪有关操作令牌的元数据，比如已经使用了哪个操作令牌，因此不能第二次重用。这通常需要跨数据中心复制。 持久数据的缓存和失效 Keycloak使用Infinispan来缓存持久数据，以避免对数据库的许多不必要的请求。 缓存提高了性能，但它增加了额外的挑战。 当某些Keycloak服务器更新任何数据时，所有数据中心中的所有其他Keycloak服务器都需要知道它，因此它们会使其缓存中的特定数据无效。 Keycloak使用称为realms ，users 和 authorization 的本地Infinispan缓存来缓存持久数据。 我们使用单独的缓存 work，它在所有数据中心中复制。 工作缓存本身不会缓存任何实际数据。 它仅用于在群集节点和数据中心之间发送失效消息。 换句话说，当更新数据时，例如用户john，Keycloak节点将失效消息发送到同一数据中心的所有其他集群节点以及所有其他数据中心。 收到无效通知后，每个节点都会从其本地缓存中使相应的数据无效。 User sessions (用户会话) Infinispan缓存称为 sessions, clientSessions, offlineSessions 和 offlineClientSessions，所有这些缓存通常都需要跨数据中心进行复制。 这些缓存用于保存有关用户会话的数据，这些数据对用户的浏览器会话长度有效。 缓存必须处理来自最终用户和应用程序的HTTP请求。 如上所述，在此实例中无法可靠地使用粘性会话，但我们仍希望确保后续HTTP请求可以查看最新数据。 因此，数据通常在数据中心之间复制。 Brute force protection (强力保护) 最后，loginFailures 缓存用于跟踪有关失败登录的数据，例如用户john 输入错误密码的次数。 详细说明此处。 管理员是否应该跨数据中心复制此缓存。 要准确计算登录失败次数，需要进行复制。 另一方面，不复制此数据可以节省一些性能。 因此，如果性能比准确的登录失败计数更重要，则可以避免复制。 有关如何配置高速缓存的更多详细信息，请参阅调整JDG高速缓存配置。 3.4.7. 通信细节 keycover使用多个独立的Infinispan缓存集群。每个Keycloak 节点都与相同数据中心中的其他Keycloak 节点在集群中，但不包含不同数据中心的Keycloak节点。 Keycloak节点不直接与来自不同数据中心的Keycloak节点通信。 Keycloak节点使用外部JDG（实际上是Infinispan服务器）跨数据中心进行通信。 这是使用Infinispan HotRod协议。 Keycloak端上的Infinispan缓存必须配置为remoteStore，以确保数据被保存到远程缓存中。JDG服务器之间有单独的Infinispan集群，因此保存在 site1 上的JDG1上的数据被复制到 site2上的JDG2上。 最后，接收JDG服务器通过客户机侦听器通知集群中的Keycloak服务器，这是HotRod协议的一个特性。然后更新它们的Infinispan缓存，特定的用户会话也可以在 site2 的Keycloak节点上看到。 有关更多细节，请参见示例架构图。 3.4.8. 基本设置 在本例中，我们描述了使用两个数据中心，site1 和 site2。 每个数据中心由1个Infinispan服务器和2个Keycloak服务器组成。 我们最终将拥有2台Infinispan服务器和4台Keycloak服务器。 Site1 由Infinispan服务器，jdg1 和2个Keycloak服务器，node11 和 node12 组成。 Site2 由Infinispan服务器，jdg2 和2个Keycloak服务器，node21 和 node22 组成。 Infinispan服务器 jdg1 和 jdg2 通过 RELAY2 协议和 backup 的Infinispan缓存相互连接，其方式与JDG文档中描述的类似。 Keycloak服务器 node11 和 node12 彼此形成一个集群，但它们不直接与 site2 中的任何服务器通信。 它们使用HotRod协议（远程缓存）与Infinispan服务器 jdg1 进行通信。 有关详细信息，请参阅通信详细信息。 同样的细节适用于 node21 和 node22。它们彼此集群，仅使用HotRod协议与jdg2服务器通信。 我们的示例设置假定所有4个Keycloak服务器都与同一个数据库通信。 在生产中，建议在数据库中使用单独的同步复制数据库，如数据库中所述。 Infinispan服务器设置 请按照以下步骤设置Infinispan服务器： 下载Infinispan 9.4.8服务器并解压缩到您选择的目录。 该位置将在后面的步骤中称为 JDG1_HOME 。 在JGroups子系统的配置中更改 JDG1_HOME/standalone/configuration/clustered.xml中的那些内容： 在 channels 元素下添加 xsite 通道，它将使用tcp 堆栈： 在 udp 堆栈的末尾添加 relay 元素。 我们将以我们的站点为 site1 的方式配置它，而我们将备份的另一个站点是 site2 ： ... false 配置tcp堆栈使用TCPPING协议而不是'MPING。 删除MPING元素并将其替换为TCPPING。initial_hosts元素指向主机jdg1和jdg2`： jdg1[7600],jdg2[7600] false ... 这只是一个让程序快速运行的示例设置。在生产中，JGroups ' RELAY2 '不需要使用' tcp '栈， 但是您可以配置任何其他堆栈。例如，如果数据中心之间的网络支持多播，可以使用默认的udp堆栈。 只要确保Infinispan和Keycloak集群是相互不可发现的。 同样，您不需要使用 TCPPING 作为发现协议。 在生产中，你可能不会使用TCPPING因为它是静态的。 最后，站点名称也是可配置的。 这个更详细的设置的详细信息超出了Keycloak文档的范围。 有关更多详细信息，请参阅Infinispan文档和JGroups文档。 将其添加到名为clustered的缓存容器下的JDG1_HOME/standalone/configuration/clustered.xml中： ... 有关 replicated-cache-configuration 中的配置选项的详细信息，请参阅调整JDG缓存配置，其中包含信息 关于调整其中一些选项。 与以前的版本不同，Infinispan服务器 replicated-cache-configuration 需要在没有 transaction 元素的情况下进行配置。 有关详细信息，请参阅故障排除 。 在通过网络访问受保护的缓存之前，某些Infinispan服务器版本需要授权。 如果您使用推荐的Infinispan 9.4.8服务器，则不应该看到任何问题，并且可以（并且应该）忽略此步骤。 与授权相关的问题可能仅适用于Infinispan服务器的某些其他版本。 Keycloak需要更新包含脚本的 ___ script_cache 缓存。 如果访问此缓存时出错，则需要在 clustered.xml 配置中设置授权，如下所述： 在 部分中，添加一个安全领域： ... not-so-secret-password 在服务器核心子系统中，添加 ，如下所示： ... 在端点子系统中，将身份验证配置添加到Hot Rod连接器： ... 将服务器复制到第二个位置，稍后将称之为 JDG2_HOME。 在 JDG2_HOME/standalone/configuration/clustered.xml交换site1和site2，反之亦然，在JGroups子系统中的 relay 配置和cache-subsystem中 backups 的配置。 例如： relay元素应如下所示： false 像这样的backups元素： 由于Infinispan子系统不支持用表达式替换站点名，因此目前需要为两个站点上的JDG服务器提供不同的配置文件。有关详细信息，请参见this issue。 启动服务器 jdg1: cd JDG1_HOME/bin ./standalone.sh -c clustered.xml -Djava.net.preferIPv4Stack=true \\ -Djboss.default.multicast.address=234.56.78.99 \\ -Djboss.node.name=jdg1 -b PUBLIC_IP_ADDRESS 启动服务器jdg2。由于存在不同的组播地址，因此jdg1和jdg2服务器并不直接集群在一起;相反，它们只是通过RELAY2协议连接，TCP JGroups堆栈用于它们之间的通信。启动命令是这样的: cd JDG2_HOME/bin ./standalone.sh -c clustered.xml -Djava.net.preferIPv4Stack=true \\ -Djboss.default.multicast.address=234.56.78.100 \\ -Djboss.node.name=jdg2 -b PUBLIC_IP_ADDRESS 要验证此时通道是否工作，您可能需要使用JConsole并连接到正在运行的JDG1或JDG2服务器。当您使用MBean jgroups:type=protocol,cluster=\"cluster\",protocol=RELAY2和操作printRoutes时，应该会看到如下输出: site1 --> _jdg1:site1 site2 --> _jdg2:site2 当您使用MBean jgroups:type=protocol,cluster=\"cluster\",protocol=GMS 时，您应该看到属性成员只包含一个成员: 在JDG1上应该是这样的: (1) jdg1 在JDG2上是这样的: (1) jdg2 在生产中，您可以在每个数据中心拥有更多Infinispan服务器。 您只需要确保同一数据中心内的Infinispan服务器使用相同的多播地址（换句话说，在启动时使用相同的 jboss.default.multicast.address ）。 然后在GMS 协议视图的jconsole中，您将看到当前集群的所有成员。 Keycloak服务器设置 将Keycloak服务器分发解压缩到您选择的位置。 它将在后面称为 NODE11。 为KeycloakDS数据源配置共享数据库。 建议使用MySQL或MariaDB进行测试。 有关详细信息，请参阅数据库。 在生产中，您可能需要在每个数据中心都有一个单独的数据库服务器，并且两个数据库服务器应该同步复制到彼此。 在示例设置中，我们只使用一个数据库并将所有4个Keycloak服务器连接到它。 编辑 NODE11/standalone/configuration/standalone-ha.xml : 将属性site添加到JGroups UDP协议： 在名为keycloak的cache-container元素下添加这个module属性： 在work缓存下添加remote-store： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 在sessions缓存下添加这样的remote-store： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 对于offlineSessions，clientSessions，offlineClientSessions，loginFailures和actionTokens缓存执行相同的操作（与sessions缓存的唯一区别是cache属性值不同）： true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory true org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory 将远程存储的出站套接字绑定添加到socket-binding-group元素配置中： 分布式缓存authenticationSessions和其他缓存的配置保持不变。 （可选）在logging子系统下启用DEBUG日志记录： 将NODE11复制到3个其他目录，后面称为NODE12，NODE21和NODE22。 启动 NODE11 : cd NODE11/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node11 -Djboss.site.name=site1 \\ -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=jdg1 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 启动 NODE12 : cd NODE12/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node12 -Djboss.site.name=site1 \\ -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=jdg1 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 应该连接集群节点。类似这样的东西应该同时出现在NODE11和NODE12的日志中: Received new cluster view for channel keycloak: [node11|1] (2) [node11, node12] 日志中的通道名称可能不同。 启动 NODE21 : cd NODE21/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node21 -Djboss.site.name=site2 \\ -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=jdg2 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 它不应该使用NODE11和NODE12连接到集群，而是分开一个： Received new cluster view for channel keycloak: [node21|0] (1) [node21] 启动 NODE22 : cd NODE22/bin ./standalone.sh -c standalone-ha.xml -Djboss.node.name=node22 -Djboss.site.name=site2 \\ -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=jdg2 \\ -Djava.net.preferIPv4Stack=true -b PUBLIC_IP_ADDRESS 它应该在与NODE21的集群中： Received new cluster view for channel keycloak: [node21|1] (2) [node21, node22] 日志中的通道名称可能不同。 测试: 转到 http://node11:8080/auth/ 并创建初始管理员用户。 转到 http://node11:8080/auth/admin 并以admin身份登录管理控制台。 打开第二个浏览器并转到任何节点 http://node12:8080/auth/admin 或http://node21:8080/auth/admin 或 http://node22:8080/auth/admin 。 登录后，您应该能够在所有4台服务器上的特定用户，客户端或领域的“会话”选项卡中看到相同的会话。 在对Keycloak管理控制台进行任何更改后（例如，更新某些用户或某些领域），更新应立即在4个节点中的任何一个上可见，因为缓存应在任何地方正确无效。 如果需要，请检查server.logs。 登录或注销后，这样的消息应该在所有节点上 NODEXY/standalone/log/server.log： 2017-08-25 17:35:17,737 DEBUG [org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionListener] (Client-Listener-sessions-30012a77422542f5) Received event from remote store. Event 'CLIENT_CACHE_ENTRY_REMOVED', key '193489e7-e2bc-4069-afe8-f1dfa73084ea', skip 'false' 3.4.9. 跨DC部署的管理 本节包含与跨数据中心复制相关的一些提示和选项。 当您在数据中心内运行Keycloak服务器时， 需要在 KeycloakDS 数据源中引用的数据库已经在该数据中心中运行并可用。 outbound-socket-binding引用的Infinispan服务器也是必要的， 从Infinispan缓存remote-store元素引用的,已经在运行。否则Keycloak服务器将无法启动。 如果要支持数据库故障转移和更高的可靠性，每个数据中心都可以拥有更多数据库节点。 有关如何在数据库端进行设置以及如何在Keycloak端配置KeycloakDS数据源的详细信息，请参阅数据库和JDBC驱动程序的文档。 每个数据中心都可以在集群中运行更多Infinispan服务器。 如果您需要一些故障转移和更好的容错能力，这将非常有用。 用于Infinispan服务器和Keycloak服务器之间通信的HotRod协议具有以下功能：Infinispan服务器将自动向Keycloak服务器发送有关Infinispan群集更改的新拓扑， 因此，Keycloak端的远程存储将知道它可以连接到哪个Infinispan服务器。阅读Infinispan和WildFly文档了解更多细节。 强烈建议在启动任何站点中的Keycloak服务器之前，在每个站点中运行一个主Infinispan服务器。 在我们的例子中，我们首先在所有Keycloak服务器之前启动了jdg1和jdg2。 如果您仍然需要运行Keycloak服务器并且备份站点处于脱机状态，建议您在站点上的Infinispan服务器上手动切换备份站点，如使站点脱机并联机中所述。 如果不手动将不可用站点脱机，则第一次启动可能会失败，或者在启动期间可能会出现一些异常，直到备份站点因配置的失败操作计数而自动脱机。 3.4.10. 使网站脱机和在线 例如，假设这种情况： 站点site2从site1角度完全脱机。 这意味着site2上的所有Infinispan服务器都关闭**或者site1和site2之间的网络被破坏了。 您在站点site1中运行Keycloak服务器和Infinispan服务器jdg1 有人在site1上的Keycloak服务器上登录。 来自site1的Keycloak服务器将尝试将会话写入jdg1服务器上的远程缓存，该服务器应该将数据备份到site2中的jdg2服务器。 有关详细信息，请参阅通信详细信息。 服务器jdg2离线或无法访问jdg1。 所以从jdg1到jdg2的备份将失败。 在jdg1日志中抛出异常，故障也将从jdg1服务器传播到Keycloak服务器，因为配置了默认的FAIL备份失败策略。 有关备份策略的详细信息，请参阅备份失败策略。 错误也会在Keycloak方面发生，用户可能无法完成登录。 根据您的环境，站点之间的网络可能或多或少可能不可用或暂时中断（裂脑）。如果发生这种情况，最好是site1上的Infinispan服务器知道site2上的Infinispan服务器不可用，因此它们将停止尝试访问jdg2站点上的服务器，并且不会发生备份故障。这就是所谓的“让网站脱机”。 使网站脱机 有两种方法可以使网站脱机。 由管理员手动 - 管理员可以使用jconsole或其他工具运行一些JMX操作来手动使特定站点脱机。 这非常有用，尤其是在计划中断时。使用jconsole或CLI，您可以连接到jdg1服务器并使site2脱机。 有关这方面的更多详细信息，请参见JDG文档。 通常需要对SYNC或ASYNC备份中提到的所有Keycloak缓存执行这些步骤。 自动 - 经过一定数量的失败备份后，site2通常会自动脱机。 这是通过在Infinispan服务器设置中配置的缓存配置中的take-offline元素的配置来完成的。 这个示例显示，如果在60秒内至少有3个后续备份失败，并且没有任何成功备份，那么对于特定的单个缓存，站点将自动脱机。 自动使站点脱机是非常有用的，特别是当站点之间的网络中断是计划外的。 缺点是，在检测到网络中断之前，会有一些失败的备份，这也可能意味着应用程序端出现故障。 例如，某些用户的登录失败或登录超时很长。 特别是如果使用值为 FAIL 的 failure-policy。 每个缓存都会单独跟踪站点是否处于脱机状态。 把网站在线 一旦你的网络恢复了，site1 和 site2 可以互相交谈，你可能需要把网站上线。这需要通过JMX或CLI手动完成，方法类似于使站点脱机。同样，您可能需要检查所有缓存并将它们联机。 一旦网站上线，通常最好: 做状态转移。 手动清除缓存。 3.4.11. 状态转移 国家转移是必需的手动步骤。 Infinispan服务器不会自动执行此操作，例如在裂脑期间，只有管理员可以决定哪个站点具有首选项，因此是否需要在两个站点之间双向进行状态转移，或者只是单向进行，如同仅来自site1到site2，但不是从site2到site1。 双向状态转移将确保site1上的裂脑后创建的实体被转移到site2上。 这不是问题，因为它们在site2上还不存在。 类似地，在site2上裂脑后创建的实体将被转移到site1上。 可能有问题的部分是那些在两个站点上的裂脑之前存在并且在两个站点上的裂脑期间更新的实体。 当这种情况发生时，其中一个站点将胜出，并覆盖第二个站点在脑裂期间完成的更新。 不幸的是，没有任何通用的解决方案。 脑裂和网络中断只是状态，通常不可能100%正确地处理站点之间100%一致的数据。 就Keycloak而言，它通常不是一个关键问题。 在最坏的情况下，用户需要重新登录到他们的客户端，或者有不正确的loginFailures计数用于强力保护。 有关如何处理裂脑的更多提示，请参阅Infinispan/JGroups文档。 状态转移也可以通过JMX在Infinispan服务器端完成。 操作名称是pushState。 几乎没有其他操作来监视状态，取消推送状态等。 有关状态转移的更多信息，请参阅Infinispan docs。 3.4.12. 清除缓存 在脑裂之后，可以安全地在Keycloak管理控制台中手动清除缓存。 这是因为在site1上的数据库中可能存在一些数据发生了变化，并且由于该事件，缓存应该被无效，并且在脑裂期间没有被转移到site2。 因此，site2上的Keycloak节点可能仍然在其缓存中有一些陈旧的数据。 要清除缓存，请参阅清除服务器缓存。 当网络恢复时，仅在任何随机站点上的一个Keycloak节点上清除缓存就足够了。 缓存失效事件将发送到所有站点中的所有其他Keycloak节点。 但是，需要对所有缓存（领域，用户，密钥）执行此操作。 有关详细信息，请参阅清除服务器缓存。 3.4.13. 调整JDG缓存配置 本节包含配置JDG缓存的技巧和选项。 备份失败策略 默认情况下，JDG的clustered.xml文件中Infinispan缓存配置中的备份failure-policy配置级别为FAIL。 您可以根据需要将其更改为WARN或IGNORE。 FAIL和WARN之间的区别在于，当使用FAIL并且Infinispan服务器尝试将数据备份到另一个站点并且备份失败时，失败将传播回调用者（Keycloak服务器）。 备份可能会失败，因为第二个站点暂时无法访问，或者存在尝试更新同一实体的并发事务。 在这种情况下，Keycloak服务器将重试该操作几次。 但是，如果重试失败，则用户可能会在更长的超时后看到错误。 使用WARN时，失败的备份不会从Infinispan服务器传播到Keycloak服务器。 用户将看不到错误，将忽略失败的备份。 将有一个较短的超时，通常为10秒，因为这是备份的默认超时。 它可以通过backup元素的属性timeout来改变。 不会重试。 Infinispan服务器日志中只会出现一条WARNING消息。 潜在的问题是，在某些情况下，站点之间可能只有一些短暂的网络中断，其中重试（使用FAIL策略）可能有所帮助，因此使用WARN（不重试），将会有 站点间的一些数据不一致。 如果尝试在两个站点上同时更新同一实体，也会发生这种情况。 这些不一致有多糟糕？ 通常只表示用户需要重新进行身份验证。 当使用WARN策略时，可能会发生由actionTokens缓存提供并处理该特定密钥的一次性缓存实际上是单独使用，但可能“成功”两次写入相同的密钥。 但是，例如，OAuth2规范提及该代码必须是单一使用的。 使用WARN策略，可能无法严格保证，如果尝试在两个站点中同时写入相同的代码，则可以写两次相同的代码。 如果有较长的网络中断或裂脑，那么同时使用FAIL和WARN，其他站点将在一段时间后失效，如使站点离线和联机中所述。 使用默认的1分钟超时，通常需要1-3分钟才能使所有相关的缓存脱机。 之后，从最终用户的角度来看，所有操作都可以正常工作。 如网站离线和在线中所述，您只需在网站重新联机时手动恢复该网站。 总之，如果您希望站点之间频繁，更长时间的中断，并且您可以接受一些数据不一致且不是100％准确的一次性缓存，但您绝不希望最终用户看到错误和长时间超时，那么 切换到WARN。 WARN和IGNORE之间的区别在于，IGNORE警告不会写入JDG日志中。 请参阅Infinispan文档中的更多详细信息。 Lock acquisition timeout (锁定获取超时) 默认配置是在NON_DURABLE_XA模式下使用事务，获取超时为0.这意味着如果同一个密钥正在进行另一个事务，则事务将快速失败。 将其切换为0而不是默认10秒的原因是为了避免可能的死锁问题。 使用Keycloak，可能会发生同一实体（通常是会话实体或loginFailure）从两个站点同时更新。 这可能会在某些情况下导致死锁，这将导致事务被阻止10秒。 有关详细信息，请参阅此JIRA报告。 如果超时为0，则事务将立即失败，如果配置了具有值FAIL的备份failure-policy，则将从Keycloak重试该事务。 只要第二个并发事务完成，重试通常就会成功，并且实体将从两个并发事务中应用更新。 我们看到使用此配置进行并发事务的一致性和结果非常好，建议保留它。 唯一（非功能）问题是Infinispan服务器日志中的异常，每次锁定不可用时都会发生。 3.4.14. 同步或异步备份 backup元素的一个重要部分是strategy属性。 您必须决定是否需要SYNC或ASYNC。 我们有7个可能支持跨数据中心复制的缓存，这些缓存可以配置为3种不同的交叉直流模式： 同步 备份 异步 备份 不备份 如果使用SYNC备份，则备份是同步的，并且在第二个站点上处理备份后，调用者（Keycloak服务器）端的操作将被视为已完成。 这比ASYNC的性能更差，但另一方面，您确信在site2上对特定实体（如用户会话）的后续读取将从site1中看到更新。 此外，如果您想要数据一致性，则需要它。 与ASYNC一样，如果备份到其他站点失败，则不会通知呼叫者。 对于某些缓存，甚至可能根本不进行备份并完全跳过将数据写入Infinispan服务器。 要进行此设置，请不要将remote-store元素用于Keycloak端的特定缓存 (文件 KEYCLOAK_HOME/standalone/configuration/standalone-ha.xml) ，然后使用特定的replicated-cache元素。 在Infinispan服务器端也不需要。 默认情况下，所有7个缓存都配置了SYNC备份，这是最安全的选项。 以下是一些需要考虑的事项： 如果您使用的是主动/被动模式（所有Keycloak服务器都在单站点site1中，而site2中的Infinispan服务器仅用作备份。请参阅模式以获取更多详细信息），然后通常可以使用所有缓存的ASYNC策略来保存性能。 work缓存主要用于向其他站点发送一些消息，例如缓存失效事件。 它还用于确保某些特殊事件,例如userStorage同步;仅在单个站点上发生。 建议将此设置保持为`SYNC。 actionTokens缓存用作一次性缓存，用于跟踪某些令牌/票证仅使用一次。 例如，动作令牌或OAuth2代码。 可以将其设置为ASYNC以略微提高性能，但是不能保证特定票证真的是单次使用。 例如，如果两个站点中同时存在同一票证请求，那么两个请求都可能成功使用ASYNC策略。 所以你在这里设置的将取决于你是否更喜欢更好的安全性（SYNC策略）或更好的性能（ASYNC策略）。 loginFailures缓存可以在3种模式中的任何一种中使用。 如果根本没有备份，则意味着每个站点将单独计算用户的登录失败次数（请参阅Infinispan缓存了解详情）。 这具有一些安全隐患，但它具有一些性能优势。 此外，它还可以降低拒绝服务（DoS）攻击的风险。 例如，如果攻击者使用两个站点上的用户的用户名和密码模拟1000个并发请求，则意味着在站点之间传递大量消息，这可能导致网络拥塞。 ASYNC策略可能更糟糕，因为等待备份到其他站点不会阻止攻击者请求，从而导致可能更加拥挤的网络流量。 使用ASYNC策略，登录失败的次数也不准确。 对于数据中心之间网络速度较慢且DoS概率较低的环境，建议不要备份loginFailures缓存。 建议在SYNC中保留sessions和clientSessions缓存。 只有当您确定用户请求和反向通道请求（从请求处理中描述的客户端应用程序到Keycloak的请求）时，才可以将它们切换为ASYNC）将始终在同一站点上处理。 例如，如果： 您使用主动/被动模式，如模式所述。 您的所有客户端应用程序都使用Keycloak JavaScript Adapter。 JavaScript适配器在浏览器中发送反向通道请求，因此它们参与浏览器粘性会话，并将在与该用户的其他浏览器请求相同的群集节点（因此在同一站点上）结束。 您的负载均衡器能够根据客户端IP地址（位置）提供请求，并在两个站点上部署客户端应用程序。 例如，您有2个站点LON和NYC。 只要您的应用程序也部署在LON和NYC站点中，您就可以确保来自伦敦用户的所有用户请求将被重定向到LON站点中的应用程序以及LON站点中的Keycloak服务器。 来自LON站点客户端部署的Backchannel请求也将在LON站点中的Keycloak服务器上结束。 另一方面，对于美国用户，所有Keycloak请求，应用程序请求和反向通道请求将在NYC站点上处理。 对于offlineSessions和offlineClientSessions，它是相似的，不同之处在于，如果您从未计划为任何客户端应用程序使用脱机令牌，则根本不需要备份它们。 一般来说，如果您有疑问并且性能不适合您，那么将缓存保持在SYNC策略中会更安全。 关于切换到SYNC/ASYNC备份，请确保编辑backup元素的strategy属性。 例如这样： 注意cache-configuration元素的mode属性。 3.4.15. 故障排除 以下提示旨在帮助您解决问题： 建议通过基本设置并首先使用此工具，以便您对事情有所了解 工作。 阅读整篇文档以了解事物也是明智之举。 按照Infinispan服务器设置中的说明检入Infinispan的jconsole集群状态（GMS）和JGroups状态（RELAY）。 如果事情看起来不像预期，那么问题很可能出在Infinispan服务器的设置上。 对于Keycloak服务器，您应该在服务器启动期间看到这样的消息： 18:09:30,156 INFO [org.keycloak.connections.infinispan.DefaultInfinispanConnectionProviderFactory] (ServerService Thread Pool -- 54) Node name: node11, Site name: site1 在Keycloak服务器启动期间检查站点名称和节点名称是否与预期一致。 检查Keycloak服务器是否按预期位于集群中，包括只有来自同一数据中心的Keycloak服务器彼此在集群中。 这也可以通过GMS视图在JConsole中进行检查。 有关其他详细信息，请参阅集群疑难解答。 如果在启动Keycloak服务器期间有异常，如下所示： 17:33:58,605 ERROR [org.infinispan.client.hotrod.impl.operations.RetryOnFailureOperation] (ServerService Thread Pool -- 59) ISPN004007: Exception encountered. Retry 10 out of 10: org.infinispan.client.hotrod.exceptions.TransportException:: Could not fetch transport ... Caused by: org.infinispan.client.hotrod.exceptions.TransportException:: Could not connect to server: 127.0.0.1:12232 at org.infinispan.client.hotrod.impl.transport.tcp.TcpTransport.(TcpTransport.java:82) 它通常意味着Keycloak服务器无法访问自己的数据中心的Infinispan服务器。 确保按预期设置防火墙，并且可以连接Infinispan服务器。 如果在启动Keycloak服务器期间有异常，如下所示： 16:44:18,321 WARN [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 57) ISPN004005: Error received from the server: javax.transaction.RollbackException: ARJUNA016053: Could not commit transaction. ... 然后检查您站点的相应Infinispan服务器的日志，并检查是否未能备份到其他站点。 如果备份站点不可用，则建议将其切换为脱机，以便Infinispan服务器不会尝试备份到脱机站点，从而导致操作也在Keycloak服务器端成功通过。 有关详细信息，请参阅交叉DC部署管理。 检查可通过JMX获得的Infinispan统计信息。 例如，尝试登录，然后查看新会话是否已成功写入两个Infinispan服务器，并在那里的sessions缓存中可用。 这可以通过检查MBean的sessions缓存中的元素数来间接完成jboss.datagrid-infinispan:type=Cache,name=\"sessions(repl_sync)\",manager=\"clustered\",component=Statistics和属性numberOfEntries。 登录后，两个站点上的两个Infinispan服务器上都应该有一个numberOfEntries条目。 按照Keycloak服务器设置所述启用DEBUG日志记录。 例如，如果您登录并且认为新会话在第二个站点上不可用，则最好检查Keycloak服务器日志并检查是否按照Keycloak服务器设置中的说明触发了侦听器。 如果您不知道并想要在keycloak-user邮件列表上询问，那么从电子邮件中的两个数据中心的Keycloak服务器发送日志文件会很有帮助。 将日志片段添加到邮件或将日志放在某处并在电子邮件中引用它们。 如果您在site1上的Keycloak服务器上更新了实体，例如user，并且您没有在site2上的Keycloak服务器上看到该实体更新，那么问题可能在于复制同步数据库本身 或Keycloak缓存未正确无效。 您可以尝试暂时禁用Keycloak缓存，如here所述，以确定问题是否在数据库复制级别。 此外，手动连接到数据库并检查数据是否按预期更新可能会有所帮助。 这是特定于每个数据库的，因此您需要查阅数据库的文档。 有时您可能会在Infinispan服务器日志中看到与此类锁相关的异常： (HotRodServerHandler-6-35) ISPN000136: Error executing command ReplaceCommand, writing keys [[B0x033E243034396234..[39]]: org.infinispan.util.concurrent.TimeoutException: ISPN000299: Unable to acquire lock after 0 milliseconds for key [B0x033E243034396234..[39] and requestor GlobalTx:jdg1:4353. Lock is held by GlobalTx:jdg1:4352 这些例外不一定是个问题。 它们可能在任何时候在两个DC上触发同一实体的并发编辑时发生。 这在部署中很常见。 通常，Keycloak服务器会收到有关失败操作的通知，并会重试，因此从用户的角度来看，通常没有任何问题。 如果Keycloak服务器启动期间有异常，如下所示： 16:44:18,321 WARN [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 55) ISPN004005: Error received from the server: java.lang.SecurityException: ISPN000287: Unauthorized access: subject 'Subject with principal(s): []' lacks 'READ' permission ... 这些日志条目是Keycloak自动检测Infinispan是否需要身份验证的结果，并且意味着需要进行身份验证。 此时您将注意到服务器成功启动并且您可以安全地忽略这些或服务器无法启动。 如果服务器无法启动，请确保已按照Infinispan服务器设置中的说明正确配置Infinispan进行身份验证。 要防止包含此日志条目，可以通过在spi=connectionsInfinispan/provider=default配置中将remoteStoreSecurityEnabled属性设置为true来强制进行身份验证： ... ... ... 如果您尝试使用Keycloak对您的应用程序进行身份验证，但身份验证失败并且浏览器中存在无限次重定向，并且您在Keycloak服务器日志中看到如下错误： 2017-11-27 14:50:31,587 WARN [org.keycloak.events] (default task-17) type=LOGIN_ERROR, realmId=master, clientId=null, userId=null, ipAddress=aa.bb.cc.dd, error=expired_code, restart_after_timeout=true 这可能意味着您的负载均衡器需要设置为支持粘性会话。 确保在启动Keycloak服务器（Propertyjboss.node.name）期间使用的提供的路由名称包含负载均衡器服务器用于标识当前服务器的正确名称。 如果Infinispanwork缓存无限增长，您可能会遇到此Infinispan问题，这是由缓存项未正确过期引起的。 在这种情况下，使用空的标记更新缓存声明，如下所示： 如果您在Infinispan服务器日志中看到警告，例如： 18:06:19,687 WARN [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-12) ISPN006011: Operation 'PUT_IF_ABSENT' forced to return previous value should be used on transactional caches, otherwise data inconsistency issues could arise under failure situations 18:06:19,700 WARN [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-10) ISPN006010: Conditional operation 'REPLACE_IF_UNMODIFIED' should be used with transactional caches, otherwise data inconsistency issues could arise under failure situations 你可以忽略它们。 为了避免警告，Infinispan服务器端的缓存可以更改为事务缓存，但不推荐这样做，因为它可能导致由bug引起的其他一些问题https://issues.jboss.org/browse/ISPN-9323。 所以现在，警告只需要被忽略。 如果您在Infinispan服务器日志中看到错误，例如： 12:08:32,921 ERROR [org.infinispan.server.hotrod.CacheDecodeContext] (HotRod-ServerWorker-7-11) ISPN005003: Exception reported: org.infinispan.server.hotrod.InvalidMagicIdException: Error reading magic byte or message id: 7 at org.infinispan.server.hotrod.HotRodDecoder.readHeader(HotRodDecoder.java:184) at org.infinispan.server.hotrod.HotRodDecoder.decodeHeader(HotRodDecoder.java:133) at org.infinispan.server.hotrod.HotRodDecoder.decode(HotRodDecoder.java:92) at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) 并且您在Keycloak日志中看到一些类似的错误，它可以表明正在使用的HotRod协议的版本不兼容。 当您尝试将Keycloak与JDG 7.2服务器或旧版本的Infinispan服务器一起使用时，可能会发生这种情况。 如果将protocolVersion属性作为附加属性添加到Keycloak配置文件中的remote-store元素，将会有所帮助。 例如： 2.6 4. 管理子系统配置 Keycloak的低级配置是通过编辑发行版中的standalone.xml，standalone-ha.xml或domain.xml文件来完成的。 此文件的位置取决于您的操作模式。 虽然您可以在此配置无限设置，但本节将重点介绍 keycloak-server 子系统的配置。 无论您使用哪个配置文件，keycloak-server 子系统的配置都是相同的。 keycloak-server子系统通常在文件末尾声明，如下所示： auth ... 请注意，在重新启动服务器之前，此子系统中的任何更改都不会生效。 4.1. 配置SPI提供程序 每个配置设置的细节在该设置的上下文中的其他地方讨论。 但是，了解用于在SPI提供程序上声明设置的格式很有用。 Keycloak是一个高度模块化的系统，具有很大的灵活性。 有超过50个服务提供程序接口（SPI），您可以交换每个SPI的实现。 SPI的实现称为提供者。 SPI声明中的所有元素都是可选的，但完整的SPI声明如下所示： myprovider 这里我们为SPImyspi定义了两个提供程序。 default-provider被列为myprovider。 但是由SPI来决定如何处理这个设置。 有些SPI允许多个提供商，有些则不允许。 所以default-provider可以帮助SPI选择。 另请注意，每个提供程序都定义了自己的一组配置属性。 上面两个提供商都有一个名为foo的属性这一事实只是巧合。 每个属性值的类型由提供程序解释。 但是，有一个例外。 考虑eventsStore SPI 的 jpa 提供程序： 我们看到值以方括号开头和结尾。 这意味着该值将作为列表传递给提供程序。 在此示例中，系统将向提供程序传递一个包含两个元素值 EVENT1 和 EVENT2 的列表。 要向列表中添加更多值，只需使用逗号分隔每个列表元素即可。 不幸的是，你需要使用 ＆quot; 来转义每个列表元素周围的引号。 4.2. 启动WildFly CLI 除了手动编辑配置外，您还可以通过 jboss-cli 工具发出命令来更改配置。 CLI允许您在本地或远程配置服务器。 当与脚本结合使用时，它尤其有用。 要启动WildFly CLI，您需要运行jboss-cli。 Linux/Unix $ .../bin/jboss-cli.sh Windows > ...\\bin\\jboss-cli.bat 这将带您到这样的提示： 提示 [disconnected /] 如果您希望在正在运行的服务器上执行命令，则首先执行connect命令。 连接 [disconnected /] connect connect [standalone@localhost:9990 /] 你可能会想，“我没有输入任何用户名或密码！”。 如果您在运行独立服务器或域控制器的同一台计算机上运行jboss-cli，并且您的帐户具有适当的文件权限，则无需设置或输入管理员用户名和密码。 请参阅 WildFly 16文档，了解如果您对该设置感到不舒服时如何使事情更安全的更多详细信息。 4.3. CLI嵌入式模式 如果您碰巧与独立服务器位于同一台计算机上，并且您希望在服务器未处于活动状态时发出命令，则可以将服务器嵌入CLI并在不允许传入请求的特殊模式下进行更改。 为此，首先使用您要更改的配置文件执行embed-server命令。 embed-server (嵌入服务器) [disconnected /] embed-server --server-config=standalone.xml [standalone@embedded /] 4.4. CLI GUI模式 CLI也可以在GUI模式下运行。 GUI模式启动Swing应用程序，允许您以图形方式查看和编辑 running 服务器的整个管理模型。 当您需要帮助格式化CLI命令并了解可用选项时，GUI模式特别有用。 GUI还可以从本地或远程服务器检索服务器日志。 从GUI模式开始 $ .../bin/jboss-cli.sh --gui 注意: 要连接到远程服务器，还要传递--connect选项。 使用--help选项可获取更多详细信息。 启动GUI模式后，您可能需要向下滚动才能找到节点 subsystem=keycloak-server 。 如果右键单击该节点并单击 Explore subsystem=keycloak-server ，您将获得一个仅显示keycloak-server子系统的新选项卡。 4.5. CLI脚本 CLI具有广泛的脚本功能。 脚本只是一个包含CLI命令的文本文件。 考虑一个关闭主题和模板缓存的简单脚本。 turn-off-caching.cli /subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheThemes,value=false) /subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheTemplates,value=false) 要执行脚本，我可以按照CLI GUI中的Scripts菜单，或者从命令行执行脚本，如下所示： $ .../bin/jboss-cli.sh --file=turn-off-caching.cli 4.6. CLI食谱 以下是一些配置任务以及如何使用CLI命令执行它们。 请注意，在第一个示例中的所有示例中，我们使用通配符路径 ** 表示您应该替换keycloak-server子系统的路径。 对于独立模式，这意味着: **` = `/subsystem=keycloak-server 对于域模式，这意味着： **` = `/profile=auth-server-clustered/subsystem=keycloak-server 4.6.1. 更改服务器的Web上下文 /subsystem=keycloak-server/:write-attribute(name=web-context,value=myContext) 4.6.2. 设置全局默认主题 **/theme=defaults/:write-attribute(name=default,value=myTheme) 4.6.3. 添加新的SPI和提供程序 **/spi=mySPI/:add **/spi=mySPI/provider=myProvider/:add(enabled=true) 4.6.4. 禁用提供商 **/spi=mySPI/provider=myProvider/:write-attribute(name=enabled,value=false) 4.6.5. 更改SPI的默认提供程序 **/spi=mySPI/:write-attribute(name=default-provider,value=myProvider) 4.6.6. 配置dblock SPI **/spi=dblock/:add(default-provider=jpa) **/spi=dblock/provider=jpa/:add(properties={lockWaitTimeout => \"900\"},enabled=true) 4.6.7. 为提供者添加或更改单个属性值 **/spi=dblock/provider=jpa/:map-put(name=properties,key=lockWaitTimeout,value=3) 4.6.8. 从提供程序中删除单个属性 **/spi=dblock/provider=jpa/:map-remove(name=properties,key=lockRecheckTime) 4.6.9. 在类型为List的提供程序属性上设置值 **/spi=eventsStore/provider=jpa/:map-put(name=properties,key=exclude-events,value=[EVENT1,EVENT2]) 5. 特征文件 Keycloak中的某些功能默认情况下未启用，这些功能包括不完全支持的功能。 此外，默认情况下会启用一些功能，但可以禁用这些功能。 可以启用和禁用的功能包括： 名称 描述 默认启用 支持级别 account2 New Account Management Console No Experimental account_api Account Management REST API No Preview admin_fine_grained_authz Fine-Grained Admin Permissions No Preview authz_drools_policy Drools Policy for Authorization Services No Preview docker Docker Registry protocol No Supported impersonation Ability for admins to impersonate users Yes Supported openshift_integration Extension to enable securing OpenShift No Preview script Write custom authenticators using JavaScript Yes Preview token_exchange Token Exchange Service No Preview 要启用所有预览功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile=preview 您可以通过在域模式下为server-one创建文件standalone/configuration/profile.properties（或domain/servers/server-one/configuration/profile.properties）来永久设置它。 将以下内容添加到文件中： profile=preview 要启用特定功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile.feature.=enabled 例如，要启用Docker，请使用-Dkeycloak.profile.feature.docker=enabled。 您可以通过添加以下内容在profile.properties文件中永久设置它： feature.docker=enabled 要禁用特定功能，请启动服务器： bin/standalone.sh|bat -Dkeycloak.profile.feature.=disabled 例如，要禁用模拟，请使用-Dkeycloak.profile.feature.impersonation=disabled。 您可以通过添加以下内容在profile.properties文件中永久设置它： feature.impersonation=disabled 6. 关系数据库设置 Keycloak附带了自己的基于Java的嵌入式关系数据库H2。 这是Keycloak用于保存数据的默认数据库，以便您可以开箱即用地运行身份验证服务器。 我们强烈建议您使用更多生产就绪的外部数据库替换它。 H2数据库在高并发情况下不是很可行，也不应该在集群中使用。 本章的目的是向您展示如何将Keycloak连接到更成熟的数据库。 Keycloak使用两种分层技术来持久保存其关系数据。 底层技术是JDBC。 JDBC是一种用于连接到RDBMS的Java API。 每种数据库类型都有不同的JDBC驱动程序，由数据库供应商提供。 本章讨论如何配置Keycloak以使用这些特定于供应商的驱动程序之一。 用于持久性的顶层技术是Hibernate JPA。 这是将Java对象映射到关系数据的关系映射API的对象。 Keycloak的大部分部署永远不会触及Hibernate的配置方面，但我们将讨论如果遇到这种罕见的情况，如何做到这一点。 在 WildFly 16文档 的数据源配置章节中更全面地介绍了数据源配置。 6.1. RDBMS设置清单 以下是为Keycloak配置RDBMS所需执行的步骤。 找到并下载数据库的JDBC驱动程序 将驱动程序JAR打包到模块中并将此模块安装到服务器中 在服务器的配置文件中声明JDBC驱动程序 修改数据源配置以使用数据库的JDBC驱动程序 修改数据源配置以定义数据库的连接参数 本章将使用PostgresQL作为其所有示例。 其他数据库遵循相同的安装步骤。 6.2. 打包JDBC驱动程序 查找并下载RDBMS的JDBC驱动程序JAR。 在使用此驱动程序之前，必须将其打包到模块中并将其安装到服务器中。 模块定义加载到Keycloak类路径中的JAR以及这些JAR对其他模块的依赖关系。 它们设置起来非常简单。 在Keycloak发行版的 …/modules/ 目录中，您需要创建一个目录结构来保存模块定义。 约定是使用JDBC驱动程序的Java包名称作为目录结构的名称。 对于PostgreSQL，创建目录 org/postgresql/main 。 将数据库驱动程序JAR复制到此目录中，并在其中创建一个空的 module.xml 文件。 模块目录 完成此操作后，打开 module.xml 文件并创建以下XML： 模块 XML 模块名称应与模块的目录结构匹配。 所以，org/postgresql 映射到org.postgresql。 resource-root path属性应指定驱动程序的JAR文件名。 其余的只是任何JDBC驱动程序JAR所具有的正常依赖关系。 6.3. 声明并加载JDBC驱动程序 接下来要做的是将新打包的JDBC驱动程序声明到部署配置文件中，以便在服务器启动时加载并变为可用。 执行此操作的位置取决于您的操作模式。 如果要在标准模式下部署，请编辑…/standalone/configuration/standalone.xml。 如果要以标准群集模式进行部署，请编辑.../standalone/configuration/ standalone-ha.xml。 如果要在域模式下部署，请编辑.../domain/configuration/domain.xml。 在域模式下，您需要确保编辑正在使用的配置文件：auth-server-standalone或auth-server-clustered 在配置文件中，搜索datasources子系统中的drivers XML块。 您应该看到为H2 JDBC驱动程序声明的预定义驱动程序。 这是您为外部数据库声明JDBC驱动程序的地方。 JDBC 驱动 ... org.h2.jdbcx.JdbcDataSource 在drivers XML块中，您需要声明一个额外的JDBC驱动程序。 它需要一个name，你可以选择任何你想要的。 您指定module属性，该属性指向您之前为驱动程序JAR创建的module包。 最后，您必须指定驱动程序的Java类。 下面是安装PostgreSQL驱动程序的示例，该驱动程序位于本章前面定义的模块示例中。 声明您的JDBC驱动程序 ... org.postgresql.xa.PGXADataSource org.h2.jdbcx.JdbcDataSource 6.4. 修改Keycloak数据源 声明JDBC驱动程序后，必须修改Keycloak用于将其连接到新外部数据库的现有数据源配置。 您将在注册JDBC驱动程序的相同配置文件和XML块中执行此操作。以下是设置与新数据库的连接的示例： 声明您的JDBC驱动程序 ... jdbc:postgresql://localhost/keycloak postgresql 20 William password ... 搜索KeycloakDS的datasource定义。 您首先需要修改connection-url。 供应商的JDBC实现的文档应指定此连接URL值的格式。 接下来定义你将使用的driver。 这是您在本章上一节中声明的JDBC驱动程序的逻辑名称。 每次要执行事务时，打开与数据库的新连接都很昂贵。 为了补偿，数据源实现维护了一个打开的连接池。 max-pool-size指定它将允许的最大连接数。 您可能希望根据系统负载更改此值。 最后，至少使用PostgreSQL，您需要定义连接到数据库所需的数据库用户名和密码。 您可能会担心示例中的明文是明文。 有一些方法可以对此进行模糊处理，但这超出了本指南的范围。 有关数据源功能的更多信息，请参阅 WildFly 16文档中的数据源配置章节。 6.5. 数据库配置 此组件的配置位于发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中。 此文件的位置取决于您的操作模式。 数据库配置 ... ... 可能的配置选项是： dataSource DataSource的JNDI名称 jta boolean属性，用于指定datasource是否支持JTA driverDialect 数据库方言的值。在大多数情况下，您不需要指定此属性，因为Hibernate将自动检测方言。 initializeEmpty 如果为空则初始化数据库。 如果设置为false，则必须手动初始化数据库。 如果要手动将数据库集migrationStrategy初始化为manual，它将创建一个带有SQL命令的文件来初始化数据库。 默认为true。 migrationStrategy 用于迁移数据库的策略。 有效值为update，manual和validate。 Update将自动迁移数据库架构。 手动将使用可在数据库上手动执行的SQL命令将所需更改导出到文件。 验证将只检查数据库是否是最新的。 migrationExport 编写手动数据库初始化/迁移文件的位置的路径。 showSql 指定Hibernate是否应在控制台中显示所有SQL命令（默认为false）。 这非常冗长！ formatSql 指定Hibernate是否应格式化SQL命令（默认为true） globalStatsInterval 将从Hibernate记录关于执行的数据库查询和其他事情的全局统计信息。 统计信息始终以指定的时间间隔（以秒为单位）报告给服务器日志，并在每次报告后清除。 schema 指定要使用的数据库的schema 这些配置开关等在 WildFly 16开发指南中有所描述。 6.6. 数据库的Unicode注意事项 Keycloak中的数据库模式仅考虑以下特殊字段中的Unicode字符串： Realms: 显示名称，HTML显示名称 Federation Providers: 显示名称 Users: 用户名，给定名称，姓氏，属性名称和值 Groups: 名称，属性名称和值 Roles: 名字 Descriptions of objects: 对象的描述 否则，字符仅限于数据库编码中包含的字符，通常为8位。 但是，对于某些数据库系统，可以启用Unicode字符的UTF-8编码，并在所有文本字段中使用完整的Unicode字符集。 通常，与8位编码的情况相比，这通过较短的字符串最大长度来抵消。 某些数据库需要对数据库和/或JDBC驱动程序进行特殊设置才能处理Unicode字符。 请在下面找到您的数据库的设置。 请注意，如果此处列出了数据库，只要它在数据库级别和JDBC驱动程序上正确处理UTF-8编码，它仍然可以正常工作。 从技术上讲，Unicode支持所有字段的关键标准是数据库是否允许为VARCHAR和CHAR字段设置Unicode字符集。 如果是，那么Unicode很可能是合理的，通常以字段长度为代价。 如果它只支持NVARCHAR和NCHAR字段中的Unicode，则不太可能支持所有文本字段，因为Keycloak模式广泛使用VARCHAR和CHAR字段。 6.6.1. Oracle 数据库 如果数据库是在VARCHAR和CHAR字段中使用Unicode支持创建的（例如，使用AL32UTF8字符集作为数据库字符集），则可以正确处理Unicode字符。 JDBC驱动程序无需特殊设置。 如果数据库字符集不是Unicode，那么要在特殊字段中使用Unicode字符，需要使用连接属性oracle.jdbc.defaultNChar设置为true来配置JDBC驱动程序。 将oracle.jdbc.convertNcharLiterals连接属性设置为true可能是明智的，尽管不是绝对必要的。 可以将这些属性设置为系统属性或连接属性。 请注意，设置oracle.jdbc.defaultNChar可能会对性能产生负面影响。 有关详细信息，请参阅Oracle JDBC驱动程序配置文档。 6.6.2. Microsoft SQL Server 数据库 只为特殊字段正确处理Unicode字符。 不需要JDBC驱动程序或数据库的特殊设置。 6.6.3. MySQL 数据库 如果在CREATE DATABASE命令中的VARCHAR和CHARfields中使用Unicode支持创建数据库，则可以正确处理Unicode字符（例如，使用utf8字符集作为MySQL 5.5中的默认数据库字符集。请注意 由于对utf8字符集[1]的存储要求不同，utf8mb4字符集不起作用。 请注意，在这种情况下，对非特殊字段的长度限制不适用，因为创建列以容纳给定数量的字符，而不是字节。 如果数据库缺省字符集不允许存储Unicode，则只有特殊字段允许存储Unicode值。 在JDBC驱动程序设置方面，需要在JDBC连接设置中添加连接属性characterEncoding = UTF-8。 6.6.4. PostgreSQL 数据库 当数据库字符集为UTF8时，支持Unicode。 在这种情况下，Unicode字符可以在任何字段中使用，非特殊字段的字段长度不会减少。 不需要JDBC驱动程序的特殊设置。 7. 网络设置 keycover可能会因为一些网络限制而无法使用。首先，所有网络端点都绑定到localhost，因此auth服务器实际上只能在一台本地机器上使用。对于基于HTTP的连接，它不使用80和443之类的默认端口。HTTPS/SSL不是开箱即用配置的，如果没有它，keycover有许多安全漏洞。最后，keyshield可能经常需要与外部服务器建立安全的SSL和HTTPS连接，因此需要建立信任存储，以便正确验证端点。本章将讨论所有这些内容。 7.1. 绑定地址 默认情况下，keycover绑定到本地主机环回地址127.0.0.1。如果您希望网络上的身份验证服务器可用，那么这不是一个非常有用的缺省值。通常，我们建议在公共网络上部署反向代理或负载平衡器，并将流量路由到私有网络上的各个Keycloak服务器实例。无论哪种情况，您仍然需要设置网络接口来绑定到localhost之外的其他东西。 设置绑定地址非常简单，可以在命令行上使用选择操作模式章节 中讨论的 standalone.sh 或 domain.sh 启动脚本来完成。 $ standalone.sh -b 192.168.0.5 -b开关为任何公共接口设置IP绑定地址。 或者，如果您不想在命令行设置绑定地址，则可以编辑部署的配置文件配置。 打开配置文件配置文件（standalone.xml 或 domain.xml，具体取决于您的操作模式 ）并寻找interfaces XML块。 public接口对应于创建可公开使用的套接字的子系统。 其中一个子系统的示例是Web层，它提供Keycloak的身份验证端点。 management接口对应于WildFly管理层打开的套接字。 特别是允许您使用jboss-cli.sh命令行界面和WildFly Web控制台的套接字。 在查看public接口时，您会看到它有一个特殊字符串${jboss.bind.address:127.0.0.1}。 此字符串表示值127.0.0.1，可以通过设置Java系统属性在命令行上覆盖，即： $ domain.sh -Djboss.bind.address=192.168.0.5 -b只是这个命令的简写符号。 因此，您可以直接在配置文件配置中更改绑定地址值，也可以在启动时在命令行上更改它。 设置interface定义时，还有更多选项可用。 有关更多信息，请参阅 WildFly 16文档 中的网络接口。 7.2. 套接字端口绑定 为每个套接字打开的端口具有预定义的默认值，可以在命令行或配置中覆盖。 为了说明这种配置，让我们假装你在独立模式中运行并打开…/standalone/configuration/standalone.xml。 搜索socket-binding-group。 socket-bindings定义将由服务器打开的套接字连接。 这些绑定指定了它们使用的interface（绑定地址）以及它们将打开的端口号。 你最感兴趣的是： http 定义用于Keycloak HTTP连接的端口 https 定义用于Keycloak HTTPS连接的端口 ajp 此套接字绑定定义用于AJP协议的端口。 当您使用Apache HTTPD作为负载均衡器时，Apache HTTPD服务器将此协议与mod-cluster结合使用。 management-http 定义WildFly CLI和Web控制台使用的HTTP连接。 在域模式中运行时，设置套接字配置有点棘手，因为示例 domain.xml文件具有 多个socket-binding-groups定义。 如果向下滚动到server-group定义，你可以看到socket-binding-group用于每个server-group。 域套接字绑定 ... ... 设置socket-binding-group定义时，还有更多选项可用。 有关更多信息，请参阅 WildFly 16文档 中的套接字绑定组。 7.3. 设置 HTTPS/SSL 默认情况下，Keycloak未设置为处理SSL/HTTPS。 强烈建议您在Keycloak服务器本身或Keycloak服务器前面的反向代理上启用SSL。 此默认行为由每个Keycloak领域的SSL/HTTPS模式定义。 这在服务器管理指南中有更详细的讨论，但让我们给出一些上下文和这些模式的简要概述。 外部请求 只要您坚持使用localhost，127.0.0.1，10.0.x.x，192.168.x.x和172.16.x.x等私有IP地址，Keycloak就可以在没有SSL的情况下运行。 如果您没有在服务器上配置SSL/HTTPS，或者您尝试通过HTTP从非私有IP地址访问Keycloak，则会收到错误消息。 none (没有) Keycloak不需要SSL。当你玩弄东西时,这应该只用于开发。 所有请求 Keycloak要求所有IP地址都使用SSL。 可以在Keycloak管理控制台中配置每个领域的SSL模式。 7.3.1. 为Keycloak Server启用SSL/HTTPS 如果您没有使用反向代理或负载平衡器来处理HTTPS流量，则需要为Keycloak服务器启用HTTPS。 这涉及到 获取或生成包含SSL/HTTP流量的私钥和证书的密钥库 配置Keycloak服务器以使用此密钥对和证书。 创建证书和Java密钥库 为了允许HTTPS连接，您需要获取自签名或第三方签名证书并将其导入Java密钥库，然后才能在要部署Keycloak Server的Web容器中启用HTTPS。 自签名证书 在开发过程中，您可能没有第三方签名证书可用于测试Keycloak部署，因此您需要使用Java JDK附带的keytool实用程序生成自签名证书。 $ keytool -genkey -alias localhost -keyalg RSA -keystore keycloak.jks -validity 10950 Enter keystore password: secret Re-enter new password: secret What is your first and last name? [Unknown]: localhost What is the name of your organizational unit? [Unknown]: Keycloak What is the name of your organization? [Unknown]: Red Hat What is the name of your City or Locality? [Unknown]: Westford What is the name of your State or Province? [Unknown]: MA What is the two-letter country code for this unit? [Unknown]: US Is CN=localhost, OU=Keycloak, O=Test, L=Westford, ST=MA, C=US correct? [no]: yes 您应该使用您正在安装服务器的计算机的DNS名称来回答您的名字和姓氏是什么？问题。 出于测试目的，应使用localhost。 执行此命令后，keycloak.jks文件将在您执行keytool命令的同一目录中生成。 如果您需要第三方签名证书，但没有第三方签名证书，可以在cacert.org免费获取。 在这之前你必须先做一点设置。 首先要做的是生成证书申请： $ keytool -certreq -alias yourdomain -keystore keycloak.jks > keycloak.careq 其中yourdomain是为其生成此证书的DNS名称。 Keytool生成请求： -----BEGIN NEW CERTIFICATE REQUEST----- MIIC2jCCAcICAQAwZTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk1BMREwDwYDVQQHEwhXZXN0Zm9y ZDEQMA4GA1UEChMHUmVkIEhhdDEQMA4GA1UECxMHUmVkIEhhdDESMBAGA1UEAxMJbG9jYWxob3N0 MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr7kck2TaavlEOGbcpi9c0rncY4HhdzmY Ax2nZfq1eZEaIPqI5aTxwQZzzLDK9qbeAd8Ji79HzSqnRDxNYaZu7mAYhFKHgixsolE3o5Yfzbw1 29RvyeUVe+WZxv5oo9wolVVpdSINIMEL2LaFhtX/c1dqiqYVpfnvFshZQaIg2nL8juzZcBjj4as H98gIS7khql/dkZKsw9NLvyxgJvp7PaXurX29fNf3ihG+oFrL22oFyV54BWWxXCKU/GPn61EGZGw Ft2qSIGLdctpMD1aJR2bcnlhEjZKDksjQZoQ5YMXaAGkcYkG6QkgrocDE2YXDbi7GIdf9MegVJ35 2DQMpwIDAQABoDAwLgYJKoZIhvcNAQkOMSEwHzAdBgNVHQ4EFgQUQwlZJBA+fjiDdiVzaO9vrE/i n2swDQYJKoZIhvcNAQELBQADggEBAC5FRvMkhal3q86tHPBYWBuTtmcSjs4qUm6V6f63frhveWHf PzRrI1xH272XUIeBk0gtzWo0nNZnf0mMCtUBbHhhDcG82xolikfqibZijoQZCiGiedVjHJFtniDQ 9bMDUOXEMQ7gHZg5q6mJfNG9MbMpQaUVEEFvfGEQQxbiFK7hRWU8S23/d80e8nExgQxdJWJ6vd0X MzzFK6j4Dj55bJVuM7GFmfdNC52pNOD5vYe47Aqh8oajHX9XTycVtPXl45rrWAH33ftbrS8SrZ2S vqIFQeuLL3BaHwpl3t7j2lMWcK1p80laAxEASib/fAwrRHpLHBXRcq6uALUOZl4Alt8= -----END NEW CERTIFICATE REQUEST----- 将此ca请求发送给您的CA. CA将向您签发签名证书并将其发送给您。 在导入新证书之前，必须获取并导入CA的根证书。 您可以从CA下载证书（即：root.crt）并导入如下： $ keytool -import -keystore keycloak.jks -file root.crt -alias root 最后一步是将新的CA生成的证书导入密钥库： $ keytool -import -alias yourdomain -keystore keycloak.jks -file your-certificate.cer 配置Keycloak以使用密钥库 现在您已拥有具有相应证书的Java密钥库，您需要配置Keycloak安装以使用它。 首先，您必须编辑standalone.xml，standalone-ha.xml 或 host.xml文件以使用密钥库并启用HTTPS。然后，您可以将密钥库文件移动到部署的 configuration/ 目录或您选择的位置中的文件，并提供它的绝对路径。 如果使用绝对路径，请从配置中删除可选的relative-to参数（参见操作模式）。 使用CLI添加新的security-realm元素： $ /core-service=management/security-realm=UndertowRealm:add() $ /core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=secret) 如果使用域模式，命令应该在每个主机中使用/host=/前缀执行（为了在所有主机中创建security-realm），就像这样，你会重复 每个主机： $ /host=/core-service=management/security-realm=UndertowRealm/server-identity=ssl:add(keystore-path=keycloak.jks, keystore-relative-to=jboss.server.config.dir, keystore-password=secret) 在独立或主机配置文件中，security-realms元素应如下所示： 接下来，在独立或每个域配置文件中，搜索security-realm的任何实例。 修改https-listener以使用创建的领域： $ /subsystem=undertow/server=default-server/https-listener=https:write-attribute(name=security-realm, value=UndertowRealm) 如果使用域模式，请在命令前加上正在使用的配置文件：/profile=/。 结果元素server name=\"default-server\"是subsystem xmlns=\"urn:jboss:domain:undertow:8.0\"的子元素，应该包含以下节： ... 7.4. 传出HTTP请求 Keycloak服务器通常需要向其保护的应用程序和服务发出非浏览器HTTP请求。 auth服务器通过维护HTTP客户端连接池来管理这些传出连接。 您需要在standalone.xml，standalone-ha.xml或domain.xml中配置一些内容。 此文件的位置取决于您的操作模式。 HTTP客户端配置示例 可能的配置选项是： establish-connection-timeout-millis 建立套接字连接的超时时间。 socket-timeout-millis 如果传出请求未在此时间内收到数据，则超时连接。 connection-pool-size 池中可以有多少个连接（默认为128）。 max-pooled-per-route 每个主机可以合并多少个连接（默认为64个）。 connection-ttl-millis 最长连接时间（以毫秒为单位）。 默认情况下未设置。 max-connection-idle-time-millis 连接可能在连接池中保持空闲的最长时间（默认为900秒）。 将启动Apache HTTP客户端的后台清理线程。 设置为-1以禁用此检查和后台线程。 disable-cookies 默认为true。 设置为true时，这将禁用任何cookie缓存。 client-keystore 这是Java密钥库文件的文件路径。 此密钥库包含双向SSL的客户端证书。 client-keystore-password 客户端密钥库的密码。 如果设置了client-keystore，这是 REQUIRED 。 client-key-password 客户密钥的密码。 如果设置了client-keystore，这是 REQUIRED 。 proxy-mappings 注意传出HTTP请求的代理配置。 有关更多详细信息，请参阅传出HTTP请求的代理映射部分。 7.4.1. 传出HTTP请求的代理映射 Keycloak发送的传出HTTP请求可以选择使用基于逗号分隔的代理映射列表的代理服务器。 代理映射表示基于正则表达式的主机名模式和hostnamePattern;proxyUri形式的proxy-uri的组合，例如： .*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080 要确定传出HTTP请求的代理，需要根据配置的主机名模式匹配目标主机名。第一个匹配模式确定要使用的代理uri。如果配置的模式都不匹配给定的主机名，则不使用代理。 代理uri的特殊值 NO_PROXY 可用于指示不应将任何代理用于匹配关联主机名模式的主机。可以在代理映射的末尾指定一个catch-all模式，为所有发出的请求定义一个默认代理。 以下示例演示了代理映射配置。 #All requests to Google APIs should use http://www-proxy.acme.com:8080 as proxy .*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080 #All requests to internal systems should use no proxy .*\\.acme\\.com;NO_PROXY #All other requests should use http://fallback:8080 as proxy .*;http://fallback:8080 这可以通过以下jboss-cli命令配置。 请注意，您需要正确地转义正则表达式模式，如下所示。 echo SETUP: Configure proxy routes for HttpClient SPI # In case there is no connectionsHttpClient definition yet {#} /subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:add(enabled=true) # Configure the proxy-mappings {#} /subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:write-attribute(name=properties.proxy-mappings,value=[\".*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080\",\".*\\\\.acme\\\\.com;NO_PROXY\",\".*;http://fallback:8080\"]) jboss-cli 命令将导致以下子系统配置。注意，需要用 \" 来编码 \" 字符。 7.4.2. 传出HTTPS请求信任库 当Keycloak在远程HTTPS端点上调用时，它必须验证远程服务器的证书，以确保它连接到受信任的服务器。 这对于防止中间人攻击是必要的。 必须将这些远程服务器的证书或签署这些证书的CA放在信任库中。 此信任库由Keycloak服务器管理。 在安全地连接到身份代理，LDAP身份提供程序，发送电子邮件以及与客户端应用程序进行反向通道通信时，将使用信任库。 默认情况下，未配置信任库提供程序，并且任何https连接都回退到标准java信任库配置，如Java的JSSE参考指南中所述。 如果没有建立信任，则这些传出的HTTPS请求将失败。 您可以使用 keytool 创建新的信任库文件或将可信主机证书添加到现有文件： $ keytool -import -alias HOSTDOMAIN -keystore truststore.jks -file host-certificate.cer 信任库在您的发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中配置。 此文件的位置取决于您的操作模式。 您可以使用以下模板添加信任库配置： 此设置的可能配置选项包括： file Java密钥库文件的路径。 HTTPS请求需要一种方法来验证他们正在与之通信的服务器的主机。 这就是委托人所做的。 密钥库包含一个或多个可信主机证书或证书颁发机构。 此信任库文件应仅包含安全主机的公共证书。 如果disabled不成立，这是 REQUIRED 。 password 信任库的密码。 如果disabled不成立，这是 REQUIRED 。 hostname-verification-policy WILDCARD默认情况下。 对于HTTPS请求，这将验证服务器证书的主机名。 ANY表示未验证主机名。 WILDCARD 允许子域名中的通配符，即*.foo.com。 STRICT CN必须与主机名完全匹配。 disabled 如果为true（默认值），则将忽略信任库配置，并且证书检查将回退到JSSE配置，如上所述。 如果设置为false，则必须为truststore配置file和password。 8. 集群 本节介绍如何配置要在集群中运行的Keycloak。 设置集群时，您需要做很多事情，具体来说： 选择一种操作模式 配置共享外部数据库 设置负载均衡器 提供支持IP多播的专用网络 本指南前面已讨论过选择操作模式和配置共享数据库。 在本章中，我们将讨论设置负载均衡器和提供专用网络。 我们还将讨论在集群中启动主机时需要注意的一些问题。 可以在没有IP多播的情况下对Keycloak进行群集，但此主题超出了本指南的范围。 有关更多信息，请参阅 WildFly 16 文档 的JGroups 章节。 8.1. 推荐的网络架构 用于部署Keycloak的推荐网络体系结构是在公共IP地址上设置HTTP/HTTPS负载均衡器，以将请求路由到位于专用网络上的Keycloak服务器。 这隔离了所有集群连接，并提供了保护服务器的好方法。 默认情况下，没有什么可以阻止未经授权的节点加入集群和广播多播消息。 这就是集群节点应该在专用网络中的原因，防火墙可以保护它们免受外部攻击。 8.2. 集群示例 Keycloak确实附带了一个利用域模式的开箱即用集群演示。 有关详细信息，请查看群集域示例一章。 8.3. 设置负载均衡器或代理 本节讨论在将反向代理或负载均衡器放在群集Keycloak部署之前需要配置的一些事项。 它还包括配置内置负载均衡器Clustered Domain Example。 8.3.1. 识别客户端IP地址 Keycloak中的一些功能依赖于连接到身份验证服务器的HTTP客户端的远程地址是客户端计算机的真实IP地址。 例子包括： 事件日志 - 将使用错误的源IP地址记录失败的登录尝试 需要SSL - 如果所需的SSL设置为外部（默认值），则所有外部请求都需要SSL 认证流程 - 使用IP地址的自定义身份验证流，例如仅针对外部请求显示OTP 动态客户端注册 当您在Keycloak身份验证服务器前面有反向代理或负载均衡器时，这可能会有问题。 通常的设置是，您有一个位于公共网络上的前端代理，负载平衡并将请求转发给位于专用网络中的后端Keycloak服务器实例。 在此方案中您需要执行一些额外配置，以便将实际的客户端IP地址转发到Keycloak服务器实例并由其处理。 特别： 配置反向代理或负载均衡器以正确设置 X-Forwarded-For 和 X-Forwarded-Proto HTTP头。 配置反向代理或负载均衡器以保留原始 HostHTTP头。 配置身份验证服务器以从 X-Forwarded-For 头读取客户端的IP地址。 配置代理以生成X-Forwarded-For和X-Forwarded-ProtoHTTP头并保留原始的HostHTTP头超出了本指南的范围。 采取额外的预防措施，以确保您的代理设置X-Forwared-For头。 如果您的代理配置不正确，那么 rogue 客户端可以自己设置此标头，并诱使Keycloak认为客户端从不同的IP地址连接而不是实际连接。 如果您正在进行任何黑名单或白名单的IP地址，这将变得非常重要。 除了代理本身之外，还需要在Keycloak方面配置一些东西。 如果您的代理通过HTTP协议转发请求，那么您需要配置Keycloak以从 X-Forwarded-For 头而不是从网络数据包中提取客户端的IP地址。 要执行此操作，请打开配置文件配置文件（standalone.xml，standalone-ha.xml 或 domain.xml，具体取决于您的操作模式）并查找 urn:jboss:domain:undertow:8.0 XML块。 X-Forwarded-For HTTP 配置 ... ... 将proxy-address-forwarding属性添加到http-listener元素。 将值设置为true。 如果您的代理使用AJP协议而不是HTTP来转发请求（即Apache HTTPD + mod-cluster），那么您必须以不同的方式配置。 您需要添加一个过滤器来从AJP数据包中提取此信息，而不是修改http-listener。 X-Forwarded-For AJP 配置 ... ... ... 8.3.2. 使反向代理启用HTTPS/SSL 假设您的反向代理不使用端口8443进行SSL，您还需要配置重定向到HTTPS流量的端口。 ... ... 将redirect-socket属性添加到http-listener元素。 值应为proxy-https，它指向您还需要定义的套接字绑定。 然后在socket-binding-group元素中添加一个新的socket-binding元素： ... ... 8.3.3. 验证配置 您可以通过反向代理打开路径 /auth/realms/master/.well-known/openid-configuration 来验证反向代理或负载均衡器配置。 例如，如果反向代理地址是 https://acme.com/，则打开URL https://acme.com/auth/realms/master/.well-known/openid-configuration。 这将显示一个JSON文档，其中列出了Keycloak的许多端点。 确保端点以反向代理或负载均衡器的地址（scheme, domain and port）开头。 通过这样做，您可以确保Keycloak正在使用正确的端点。 您还应验证Keycloak是否看到了请求的正确源IP地址。 请检查此项，您可以尝试使用无效的用户名和/或密码登录管理控制台。 这应该在服务器日志中显示如下警告： 08:14:21,287 WARN XNIO-1 task-45 [org.keycloak.events] type=LOGIN_ERROR, realmId=master, clientId=security-admin-console, userId=8f20d7ba-4974-4811-a695-242c8fbd1bf8, ipAddress=X.X.X.X, error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, redirect_uri=http://localhost:8080/auth/admin/master/console/?redirect_fragment=%2Frealms%2Fmaster%2Fevents-settings, code_id=a3d48b67-a439-4546-b992-e93311d6493e, username=admin 检查ipAddress的值是您尝试登录的计算机的IP地址，而不是反向代理或负载平衡器的IP地址。 8.3.4. 使用内置负载均衡器 本节介绍如何配置Clustered Domain Example中讨论的内置负载均衡器. Clustered Domain Example仅设计为在一台计算机上运行。 要在另一台主机上启动一个slave，你需要 编辑 domain.xml 文件以指向新的主机slave 复制服务器分发版。 您不需要domain.xml，host.xml 或 host-master.xml文件。 你也不需要 standalone/ 目录。 编辑 host-slave.xml 文件以更改使用的绑定地址或在命令行上覆盖它们 使用Load Balancer注册新主机 让我们首先看一下使用 domain.xml 中的负载均衡器配置注册新的主机slave。 打开此文件并转到load-balancer配置文件中的undertow配置。 在reverse-proxy XML块中添加一个名为remote-host3的新host定义。 domain.xml反向代理配置 ... ... output-socket-binding是一个逻辑名，指向稍后在 domain.xml 文件中配置的socket-binding。 instance-id属性对于新主机也必须是唯一的，因为cookie使用此值来在负载平衡时启用粘性会话。 接下来转到load-balancer-socket socket-binding-group 并为 remote-host3 添加 outbound-socket-binding。 此新绑定需要指向新主机的主机和端口。 domain.xml outbound-socket-binding ... Master Bind Addresses (主绑定地址) 接下来你要做的就是更改主控主机的public和management绑定地址。 按照绑定地址一章中的说明编辑 domain.xml 文件，或者在命令行上指定这些绑定地址 命令行如下： $ domain.sh --host-config=host-master.xml -Djboss.bind.address=192.168.0.2 -Djboss.bind.address.management=192.168.0.2 Host Slave Bind Addresses (主机从属绑定地址) 接下来，您将不得不更改public，management和域控制器绑定地址（jboss.domain.master-address）。 编辑host-slave.xml文件或在命令行中指定它们，如下所示： $ domain.sh --host-config=host-slave.xml -Djboss.bind.address=192.168.0.5 -Djboss.bind.address.management=192.168.0.5 -Djboss.domain.master.address=192.168.0.2 jboss.bind.address和jboss.bind.addres.management的值属于主机slave的IP地址。 jboss.domain.master.address的值必须是域控制器的IP地址，域控制器是master主机的管理地址。 8.3.5. 配置其他负载均衡器 有关如何使用其他基于软件的负载平衡器的信息，请参阅 WildFly 16文档 中的负载均衡部分。 8.4. 粘性会话 典型的集群部署包括负载均衡器（反向代理）和专用网络上的2个或更多Keycloak服务器。 出于性能目的，如果负载均衡器将与特定浏览器会话相关的所有请求转发到同一Keycloak后端节点，则可能会很有用。 原因是，Keycloak正在使用Infinispan分布式缓存来保存与当前身份验证会话和用户会话相关的数据。 默认情况下，Infinispan分布式缓存配置有一个所有者。 这意味着特定会话仅保存在一个群集节点上，而其他节点需要远程查找会话才能访问它。 例如，如果ID为123的认证会话保存在node1上的Infinispan缓存中，然后node2需要查找该会话，则需要通过网络将请求发送到node1以返回特定会话 实体。 如果特定会话实体始终在本地可用，这是有益的，这可以在粘性会话的帮助下完成。 具有公共前端负载均衡器和两个后端Keycloak节点的集群环境中的工作流可以是这样的： 用户发送初始请求以查看Keycloak登录屏幕 该请求由前端负载均衡器提供，后者将其转发到某个随机节点（例如，node1）。 严格地说，节点不需要是随机的，但可以根据其他一些标准（客户端IP地址等）进行选择。 这一切都取决于底层负载均衡器（反向代理）的实现和配置。 Keycloak使用随机ID（例如123）创建认证会话并将其保存到Infinispan缓存。 Infinispan分布式缓存根据会话ID的哈希值分配会话的主要所有者。 有关此内容的详细信息，请参阅Infinispan文档。 让我们假设Infinispan将node2指定为此会话的所有者。 Keycloak使用.等格式创建cookie AUTH_SESSION_ID。 在我们的示例中，它将是123.node2。 使用Keycloak登录屏幕和浏览器中的AUTH_SESSION_ID cookie将响应返回给用户 从这一点来看，如果负载均衡器将所有下一个请求转发到node2是有益的，因为这是节点，它是ID为123的认证会话的所有者，因此Infinispan可以在本地查找该会话。 身份验证完成后，身份验证会话将转换为用户会话，该会话也将保存在node2上，因为它具有相同的ID123。 粘性会话对于群集设置不是强制性的，但由于上述原因，它对性能有利。 您需要将loadbalancer配置为粘贴在AUTH_SESSION_ID cookie上。 这究竟取决于您的负载均衡器。 建议在Keycloak端使用启动期间的系统属性jboss.node.name，其值与路由名称相对应。 例如，-Djboss.node.name=node1将使用node1来标识路由。 此路由将由Infinispan缓存使用，并在节点是特定密钥的所有者时附加到AUTH_SESSION_ID cookie。 以下是使用此系统属性的启动命令的示例： cd $RHSSO_NODE1 ./standalone.sh -c standalone-ha.xml -Djboss.socket.binding.port-offset=100 -Djboss.node.name=node1 通常在生产环境中，路由名称应使用与后端主机相同的名称，但不是必需的。 您可以使用其他路径名称。 例如，如果要在专用网络中隐藏Keycloak服务器的主机名。 8.4.1. 禁用添加路由 某些负载均衡器可以配置为自行添加路由信息，而不是依赖于后端Keycloak节点。 但是，如上所述，建议通过Keycloak添加路线。 这是因为当这样做时性能得到改善，因为Keycloak知道作为特定会话的所有者的实体并且可以路由到该节点，该节点不一定是本地节点。 如果您愿意，可以通过将以下内容添加到Keycloak子系统配置中的RHSSO_HOME/standalone/configuration/standalone-ha.xml文件中来禁用Keycloak将路由信息添加到AUTH_SESSION_ID cookie中： ... 8.5. 多播网络设置 开箱即用的集群支持需要IP多播。 组播是一种网络广播协议。 此协议在启动时用于发现和加入集群。 它还用于广播消息，以便复制和使Keycloak使用的分布式缓存失效。 Keycloak的集群子系统在JGroups堆栈上运行。 开箱即用，集群的绑定地址绑定到专用网络接口，默认IP地址为127.0.0.1。 您必须编辑Bind Address 中讨论的standalone-ha.xml 或 domain.xml部分章节。 专用网络配置 ... ... ... 你想要配置的东西是jboss.bind.address.private和jboss.default.multicast.address以及集群堆栈上服务的端口。 可以在没有IP多播的情况下对Keycloak进行集群，但此主题超出了本指南的范围。 有关更多信息，请参阅 WildFly 16文档 中的JGroups。 8.6. 确保集群通信安全 当集群节点在专用网络上隔离时，它需要访问专用网络才能加入集群或查看集群中的通信。 此外，您还可以为集群通信启用身份验证和加密。 只要您的专用网络是安全的，就不必启用身份验证和加密。 在任何一种情况下，Keycloak都不会在集群上发送非常敏感的信息。 如果要为集群通信启用身份验证和加密，请参阅 JBoss EAP配置指南中的保护群集。 8.7. 串行化集群启动 允许Keycloak集群节点同时引导。 当Keycloak服务器实例启动时，它可以执行一些数据库迁移，导入或首次初始化。 数据库锁用于在集群节点同时启动时防止启动操作相互冲突。 默认情况下，此锁定的最大超时为900秒。 如果某个节点正在等待此锁超过超时，则无法启动。 通常，您不需要增加/减少默认值，但以防万一可以在您的发行版中的standalone.xml，standalone-ha.xml或domain.xml文件中进行配置。 此文件的位置取决于您的操作模式。 8.8. 启动群集 在群集中启动Keycloak取决于您的操作模式 Standalone Mode (独立模式) $ bin/standalone.sh --server-config=standalone-ha.xml Domain Mode (域模式) $ bin/domain.sh --host-config=host-master.xml $ bin/domain.sh --host-config=host-slave.xml 您可能需要使用其他参数或系统属性。 例如，绑定主机的参数-b或系统属性jboss.node.name用于指定路由的名称，如Sticky Sessions中所述 部分。 8.9. 故障排除 请注意，在运行集群时，您应该在两个集群节点的日志中看到与此类似的消息： INFO [org.infinispan.remoting.transport.jgroups.JGroupsTransport] (Incoming-10,shared=udp) ISPN000094: Received new cluster view: [node1/keycloak|1] (2) [node1/keycloak, node2/keycloak] 如果您只看到提到的一个节点，则您的集群主机可能未连接在一起。 通常，最佳做法是将您的集群节点放在专用网络上，而不使用防火墙进行通信。 可以仅在公共访问点上启用防火墙，而不是网络。 如果由于某种原因您仍需要在集群节点上启用防火墙，则需要打开一些端口。 默认值为UDP端口55200和组播地址为230.0.0.4的组播端口45688。 请注意，如果要为JGroups堆栈启用诊断等其他功能，则可能需要打开更多端口。 Keycloak将大部分集群工作委托给Infinispan/JGroups。 有关更多信息，请参阅 WildFly 16文档 中的JGroups。 如果您对故障转移支持（高可用性），驱逐，到期和缓存调整感兴趣，请参阅服务器缓存配置。 9. 服务器缓存配置 Keycloak有两种类型的缓存。 一种类型的缓存位于数据库前面，以减少数据库的负载，并通过将数据保存在内存中来减少总体响应时间。 领域，客户端，角色和用户元数据保存在此类缓存中。 此缓存是本地缓存。 即使您在具有更多Keycloak服务器的集群中，本地缓存也不使用复制。 相反，它们仅在本地保留副本，如果更新了条目，则会向集群的其余部分发送无效消息，并逐出该条目。 存在单独的复制缓存work，该任务是将失效消息发送到整个集群，关于应从本地缓存中逐出哪些条目。 这极大地减少了网络流量，提高了效率，并避免了通过网络传输敏感元数据。 第二种类型的缓存处理用户会话，脱机令牌和跟踪登录失败，以便服务器可以检测密码网络钓鱼和其他攻击。 这些缓存中保存的数据是临时的，仅在内存中，但可能在集群中复制。 本章讨论这些高速缓存的集群非集群部署的一些配置选项。 这些高速缓存的更高级配置可以在 WildFly 16文档 的Infinispan部分找到。 9.1. 驱逐和到期 为Keycloak配置了多个不同的缓存。 有一个领域缓存可以保存有关安全应用程序，常规安全数据和配置选项的信息。 还有一个包含用户元数据的用户缓存。 两个缓存默认最多为10000个条目，并使用最近最少使用的逐出策略。 它们中的每一个还绑定到对象修订缓存，该缓存控制群集设置中的逐出。 此缓存是隐式创建的，并且具有配置大小的两倍。 这同样适用于保存授权数据的authorization缓存。 keys缓存保存有关外部密钥的数据，不需要具有专用的修订缓存。 相反，它在其上明确声明了expiration，因此密钥会定期过期并强制定期从外部客户端或身份提供者下载。 可以在standalone.xml，standalone-ha.xml或domain.xml中配置这些缓存的驱逐策略和最大条目，具体取决于您的操作模式。 在配置文件中，有infinispan子系统的部分，看起来类似于： ... ... 要限制或扩展允许的条目数，只需添加或编辑特定缓存配置的object元素或expiration元素。 此外，还有单独的缓存sessions，clientSessions，offlineSessions，offlineClientSessions，loginFailures和actionTokens。 这些缓存在集群环境中分布，默认情况下它们的大小无限制。 如果它们是有界的，则可能会丢失一些会话。 过期的会话由Keycloak本身在内部清除，以避免无限制地增加这些缓存的大小。 如果由于大量会话而发现内存问题，您可以尝试： 增加集群的大小（集群中的更多节点意味着会话在节点之间更均匀地分布） 增加Keycloak服务器进程的内存 减少所有者的数量以确保将缓存保存在一个位置。 有关详细信息，请参阅复制和故障转移 禁用分布式缓存的l1-lifespan。 有关更多详细信息，请参阅Infinispan文档 减少会话超时，可以在Keycloak管理控制台中为每个领域单独完成。 但这可能会影响最终用户的可用性。 有关详细信息，请参阅超时。 还有一个额外的复制缓存，work，主要用于在集群节点之间发送消息; 默认情况下它也是无界限的。 但是，此缓存不应导致任何内存问题，因为此缓存中的条目非常短暂。 9.2. 复制和故障转移 有一些缓存，如sessions，authenticationSessions，offlineSessions，loginFailures等等（参见Eviction and Expiration了解更多细节）， 在使用集群设置时配置为分布式缓存。 条目不会复制到每个节点，而是选择一个或多个节点作为该数据的所有者。 如果节点不是特定高速缓存条目的所有者，则查询集群以获取它。 这对于故障转移意味着如果拥有一个数据的所有节点都关闭，那么该数据将永远丢失。 默认情况下，Keycloak仅指定一个数据所有者。 因此，如果那个节点发生故障，那么数据就会丢失。 这通常意味着用户将被注销，并且必须再次登录。 您可以通过更改distributed-cache声明中的owners属性来更改复制一段数据的节点数。 owners (拥有者) ... 这里我们已经更改了它，因此至少有两个节点将复制一个特定的用户登录会话。 建议的所有者数量实际上取决于您的部署。 如果您不关心用户是否在节点关闭时注销，那么一个所有者就足够了，您将避免复制。 通常明智的做法是将环境配置为使用带有粘性会话的负载均衡。 这对于性能是有益的，因为提供特定请求的Keycloak服务器通常是来自分布式缓存的数据的所有者，因此能够在本地查找数据。 有关详细信息，请参阅粘贴会话。 9.3. 禁用缓存 要禁用领域或用户高速缓存，必须编辑发行版中的standalone.xml，standalone-ha.xml或domain.xml文件。 此文件的位置取决于您的操作模式。 这是配置最初的样子。 要禁用缓存，请将要禁用的缓存的enabled属性设置为false。 您必须重新启动服务器才能使此更改生效。 9.4. 在运行时清除缓存 要清除领域或用户缓存，请转到Keycloak管理控制台领域设置→缓存配置页面。 在此页面上，您可以清除领域缓存，用户缓存或外部公钥缓存。 所有领域缓存将被清除！ 10. Keycloak安全代理 Keycloak有一个HTTP(S)代理，在无法安装Keycloak适配器的环境里,您可以把它放在Web应用程序和服务之前。 您可以设置URL过滤器，以便通过浏览器登录和/或承载令牌身份验证来保护某些URL。 您还可以在应用程序中定义URL模式的角色约束。 10.1. 代理安装和运行 从Keycloak下载页面下载Keycloak代理发布版并解压缩。 $ unzip keycloak-proxy-dist.zip 要运行它，您必须有一个代理配置文件（我们将在稍后讨论）。 $ java -jar bin/launcher.jar [your-config.json] 如果未指定代理配置文件的路径，则启动程序将在当前工作目录中查找名为`proxy.json的文件。 10.2. 代理配置 这是一个示例配置文件。 { \"target-url\": \"http://localhost:8082\", \"target-request-timeout\": \"60000\", \"send-access-token\": true, \"bind-address\": \"localhost\", \"http-port\": \"8080\", \"https-port\": \"8443\", \"keystore\": \"classpath:ssl.jks\", \"keystore-password\": \"password\", \"key-password\": \"password\", \"applications\": [ { \"base-path\": \"/customer-portal\", \"error-page\": \"/error.html\", \"adapter-config\": { \"realm\": \"demo\", \"resource\": \"customer-portal\", \"realm-public-key\": \"MIGfMA0GCSqGSIb\", \"auth-server-url\": \"http://localhost:8081/auth\", \"ssl-required\" : \"external\", \"principal-attribute\": \"name\", \"credentials\": { \"secret\": \"password\" } } , \"constraints\": [ { \"pattern\": \"/users/*\", \"roles-allowed\": [ \"user\" ] }, { \"pattern\": \"/admins/*\", \"roles-allowed\": [ \"admin\" ] }, { \"pattern\": \"/users/permit\", \"permit\": true }, { \"pattern\": \"/users/deny\", \"deny\": true } ] } ] } 10.2.1. 基本配置 服务器的基本配置选项如下： target-url 此服务器代理的URL。 需要。 target-request-timeout 代理请求的超时（以毫秒为单位）。 可选的。 默认值为30000。 send-access-token 布尔标志。 如果为true，则会通过KEYCLOAK_ACCESS_TOKEN标头将访问令牌发送到代理服务器。 可选的。 默认值为false。 bind-address 用于将代理服务器的套接字绑定到的DNS名称或IP地址。 可选的。 默认值为localhost http-port 用于侦听HTTP请求的端口。 如果未指定此值，则代理将不侦听常规HTTP请求。 可选的。 https-port 侦听HTTPS请求的端口。 如果未指定此值，则代理将不侦听HTTPS请求。 可选的。 keystore Java密钥库文件的路径，该文件包含服务器能够处理HTTPS请求的私钥和证书。 可以是文件路径，或者，如果在前面添加classpath:，它将在类路径中查找此文件。 可选的。 如果您已启用HTTPS但尚未定义密钥库，则代理将自动生成自签名证书并使用该证书。 buffer-size HTTP服务器套接字缓冲区大小 通常默认值足够好。 可选的。 buffers-per-region 每个region(区域)的HTTP服务器套接字缓冲 通常默认值足够好。 可选的。 io-threads 处理IO的线程数。 通常默认是足够好的。 可选的。 默认值是可用处理器数量* 2。 worker-threads 处理请求的线程数。 通常默认值足够好。 可选的。 默认值是可用处理器数量* 16。 10.3. 应用程序配置 接下来在applications数组属性下，您可以为每个要代理的主机定义一个或多个应用程序。 base-path 应用程序的基本上下文根。 必须以'/'开头。 需要。 error-page 如果代理有错误，它将显示目标应用程序的错误页面相对URL。 可选的。 这是基本路径的相对路径。 在上面的例子中，它将是/customer-portal/error.html。 adapter-config 需要。 与任何其他Keycloak适配器的配置相同。 proxy-address-forwarding 当托管在另一个代理/负载均衡器后面时，允许使用X-Forwarded-For，X-Forwarded-Host，X-Forwarded-Proto。 10.3.1. 约束配置 在每个应用程序下，您可以在constraints数组属性中定义一个或多个约束。 约束定义相对于基本路径的URL模式。 您可以拒绝，允许或要求对特定URL模式进行身份验证。 您也可以指定该路径允许的角色。 更具体的约束将优先于更一般的约束。 pattern 相对于应用程序的基本路径匹配的URL模式。 必须以'/'开头。 必须. 你可能只有一个通配符，它必须位于模式的末尾。有效：/foo/bar/*和/foo/*.txt 无效：/ */foo/*。 roles-allowed 允许访问此url模式的角色字符串数组。 可选的。 methods HTTP方法的字符串数组，它们将独占地匹配此模式和HTTP请求。 可选的。 excluded-methods 匹配此模式时将忽略的HTTP方法字符串数组。 可选的。 deny 拒绝所有访问此URL模式的权限。 可选的。 permit 允许所有访问而无需身份验证或角色映射。 可选的。 permit-and-inject 允许所有访问，但如果用户已经过身份验证，则注入标头。 可选的。 authenticate 需要对此模式进行身份验证，但不需要角色映射。 可选的。 10.3.2. 头名配置 接下来，在应用程序列表下，您可以覆盖代理注入的头字段名称的默认值（请参阅Keycloak Identity Headers）。 此映射是可选的。 keycloak-subject 例如: MYAPP_USER_ID keycloak-username 例如: MYAPP_USER_NAME keycloak-email 例如: MYAPP_USER_EMAIL keycloak-name 例如: MYAPP_USER_ID keycloak-access-token 例如: MYAPP_ACCESS_TOKEN 10.4. Keycloak标识头 将请求转发到代理服务器时，Keycloak Proxy将使用收到的OIDC身份令牌中的值设置一些其他标头以进行身份验证。 KEYCLOAK_SUBJECT 用户ID。 对应于JWTsub，将是Keycloak用于存储此用户的用户ID。 KEYCLOAK_USERNAME 用户名。 对应于JWTpreferred_username。 KEYCLOAK_EMAIL 设置的用户的电子邮件地址。 KEYCLOAK_NAME 如果设置, 用户全名。 KEYCLOAK_ACCESS_TOKEN 如果代理配置为发送，则在此标头中发送访问令牌。 此令牌可用于发出承载令牌请求。 可以使用配置文件中的header-names映射配置标题字段名称：{ \"header-names\" { \"keycloak-subject\": \"MY_SUBJECT\" } } Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-04-28 17:28:06 "},"Securing Applications and Services Guide.html":{"url":"Securing Applications and Services Guide.html","title":"保护应用程序和服务指南","keywords":"","body":"保护应用程序和服务指南 1. 概述 1.1. 什么是客户端适配器? 1.2. 支持的平台 1.3. 支持的协议 2. OpenID 连接器 2.1. Java 适配器 2.2. JavaScript 适配器 2.3. Node.js 适配器 2.4. Keycloak 看门人 2.5. 其他OpenID连接库 3. SAML 3.1. Java 适配器 3.2. mod_auth_mellon Apache HTTPD 模块 4. Docker注册表配置 4.1. Docker注册表配置文件安装 4.2. Docker注册表环境变量覆盖安装 4.3. Docker撰写YAML文件 5. 客户端注册 5.1. 认证 5.2. Keycloak表示 5.3. Keycloak适配器配置 5.4. OpenID连接动态客户端注册 5.5. SAML实体描述符 5.6. 使用CURL的示例 5.7. 使用Java客户端注册API的示例 5.8. 客户端注册政策 6. 客户端注册 CLI 6.1. 配置新常规用户以使用客户端注册CLI 6.2. 配置客户端以与客户端注册CLI一起使用 6.3. 安装客户端注册CLI 6.4. 使用客户端注册CLI 6.5. 故障排除 7. 令牌交换 7.1. 内部令牌到内部令牌交换 7.2. 外部令牌交换的内部令牌 7.3. 外部令牌到内部令牌交换 7.4. 模拟 7.5. 直接赤裸裸的模拟 7.6. 使用服务帐户展开权限模型 7.7. 交换漏洞 保护应用程序和服务指南 1. 概述 Keycloak支持OpenID Connect（OAuth 2.0的扩展）和SAML 2.0。 在保护客户端和服务时，首先需要确定的是您要使用的两个中的哪一个。 如果您愿意，您也可以选择使用OpenID Connect和其他SAML安全保护。 To secure clients and services you are also going to need an adapter or library for the protocol you’ve selected. Keycloak comes with its own adapters for selected platforms, but it is also possible to use generic OpenID Connect Resource Provider and SAML Service Provider libraries. 1.1. 什么是客户端适配器? Keycloak客户端适配器是使用Keycloak轻松保护应用程序和服务的库。 我们将它们称为适配器而不是库，因为它们提供了与底层平台和框架的紧密集成。 这使得我们的适配器易于使用，并且它们需要的库样板代码少于库通常所需的代码。 1.2. 支持的平台 1.2.1. OpenID Connect Java JBoss EAP WildFly Fuse Tomcat Jetty 9 Servlet Filter Spring Boot Spring Security JavaScript (client-side) JavaScript Node.js (server-side) Node.js 1.2.2. C# OWIN (community) 1.2.3. Python oidc (generic) 1.2.4. Android AppAuth (generic) AeroGear (generic) 1.2.5. iOS AppAuth (generic) AeroGear (generic) Apache HTTP Server mod_auth_openidc 1.2.6. SAML Java JBoss EAP WildFly Tomcat Jetty Apache HTTP Server mod_auth_mellon 1.3. 支持的协议 1.3.1. OpenID Connect OpenID 连接 (OIDC)是一个身份验证协议，它是OAuth 2.0的扩展。虽然OAuth 2.0只是一个构建授权协议的框架，而且主要是不完整的，但OIDC是一个完整的身份验证和授权协议。 OIDC还大量使用了Json Web Token (JWT)标准集。这些标准定义了一种身份令牌JSON格式，以及以一种紧凑且web友好的方式对数据进行数字签名和加密的方法。 使用OIDC时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到identity token(身份令牌)和access token(访问令牌)。 身份令牌包含有关用户的信息，例如用户名，电子邮件和其他个人资料信息。 访问令牌由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取访问令牌，它可以代表用户在其他远程服务上调用。 Keycloak对用户进行身份验证，然后要求用户同意授予访问请求它的客户端的权限。 然后客户端接收访问令牌。 此访问令牌由领域进行数字签名。 客户端可以使用此访问令牌在远程服务上进行REST调用。 REST服务提取访问令牌，验证令牌的签名，然后根据令牌内的访问信息决定是否处理请求。 1.3.2. SAML 2.0 SAML 2.0 是与OIDC类似的规范，但是更老，更成熟。 它的根源在于SOAP和过多的WS-*规范，所以它往往比OIDC更冗长。 SAML 2.0主要是一种身份验证协议，通过在身份验证服务器和应用程序之间交换XML文档来工作。 XML签名和加密用于验证请求和响应。 在Keycloak中，SAML提供两种用例：浏览器应用程序和REST调用。 使用SAML时，实际上有两种用例。 第一个是要求Keycloak服务器为用户验证用户的应用程序。 成功登录后，应用程序将收到一个XML文档，其中包含称为SAML断言的内容，该断言指定了有关用户的各种属性。 此XML文档由领域进行数字签名，并包含访问信息（如用户角色映射），应用程序可以使用该信息来确定允许用户在应用程序上访问哪些资源。 第二种用例是希望获得远程服务访问权限的客户端。 在这种情况下，客户端要求Keycloak获取可用于代表用户在其他远程服务上调用的SAML断言。 1.3.3. OpenID Connect 与 SAML 在OpenID Connect和SAML之间进行选择不仅仅是使用更新的协议（OIDC）而不是旧的更成熟的协议（SAML）。 在大多数情况下，Keycloak建议使用OIDC。 SAML往往比OIDC更冗长。 除了交换数据的详细程度之外，如果您比较规范，您会发现OIDC旨在与Web一起工作，同时SAML被改装为在Web上运行。 例如，OIDC也更适合HTML5/JavaScript应用程序，因为它比SAML更容易在客户端实现。 由于令牌采用JSON格式，因此JavaScript更易于使用。 您还将找到一些很好的功能，可以更轻松地在Web应用程序中实现安全性。 例如，查看规范用于轻松确定用户是否仍在登录的iframe技巧。 SAML虽然有它的用途。 正如您所看到的，OIDC规范的发展，您会发现它们实现了SAML多年来所拥有的越来越多的功能。 我们经常看到人们选择SAML而不是OIDC，因为人们认为它更成熟，也因为他们已经有了现有的应用程序。 2. OpenID 连接器 本节介绍如何使用Keycloak适配器或通用OpenID Connect资源提供程序库通过OpenID Connect保护应用程序和服务。 2.1. Java 适配器 Keycloak为Java应用程序提供了一系列不同的适配器。 选择正确的适配器取决于目标平台。 所有Java适配器共享Java Adapters Config 章节中描述的一组常用配置选项。 2.1.1. Java适配器配置 Keycloak支持的每个Java适配器都可以通过简单的JSON文件进行配置。 这可能是这样的： { \"realm\" : \"demo\", \"resource\" : \"customer-portal\", \"realm-public-key\" : \"MIGfMA0GCSqGSIb3D...31LwIDAQAB\", \"auth-server-url\" : \"https://localhost:8443/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\" : false, \"enable-cors\" : true, \"cors-max-age\" : 1000, \"cors-allowed-methods\" : \"POST, PUT, DELETE, GET\", \"cors-exposed-headers\" : \"WWW-Authenticate, My-custom-exposed-Header\", \"bearer-only\" : false, \"enable-basic-auth\" : false, \"expose-token\" : true, \"verify-token-audience\" : true, \"credentials\" : { \"secret\" : \"234234-234234-234234\" }, \"connection-pool-size\" : 20, \"disable-trust-manager\": false, \"allow-any-hostname\" : false, \"truststore\" : \"path/to/truststore.jks\", \"truststore-password\" : \"geheim\", \"client-keystore\" : \"path/to/client-keystore.jks\", \"client-keystore-password\" : \"geheim\", \"client-key-password\" : \"geheim\", \"token-minimum-time-to-live\" : 10, \"min-time-between-jwks-requests\" : 10, \"public-key-cache-ttl\": 86400, \"redirect-rewrite-rules\" : { \"^/wsmaster/api/(.*)$\" : \"/api/$1\" } } 您可以使用${…}来替换系统属性。例如${jboss.server.config.dir}将替换为/path/to/Keycloak。环境变量的替换也通过env前缀得到支持，例如。 ${env.MY_ENVIRONMENT_VARIABLE}。 可以从管理控制台获取初始配置文件。 这可以通过打开管理控制台，从菜单中选择Clients并单击相应的客户端来完成。 打开客户端页面后，单击Installation选项卡，然后选择Keycloak OIDC JSON。 以下是每个配置选项的说明： realm 领域的名称。 这是必需的 resource 应用程序的客户端ID。 每个应用程序都有一个client-id，用于标识应用程序。 这是必需的 realm-public-key 领域公钥的PEM格式。 您可以从管理控制台获取此信息。 这是可选的，不建议设置它。 如果没有设置，适配器将从Keycloak下载它，它将在需要时总是重新下载（例如Keycloak旋转它的键）。 但是，如果设置了realm-public-key，那么适配器永远不会从Keycloak下载新密钥，所以当Keycloak旋转它的密钥时，适配器将会中断。 auth-server-url Keycloak服务器的基本URL。 所有其他Keycloak页面和REST服务端点都源于此。 它的形式通常为https://host:port/auth。 这是必需的 ssl-required 确保与Keycloak服务器之间的所有通信均通过HTTPS进行。 在生产中，这应该设置为“all”。 这是可选的。 默认值为external表示默认情况下HTTPS是外部请求所必需的。 有效值为“all”，“external”和“none”。 confidential-port Keycloak服务器用于通过SSL/TLS进行安全连接的机密端口。 这是可选的。 默认值为8443。 use-resource-role-mappings 如果设置为true，那么适配器将在令牌内查找用户的应用程序级别角色映射。 如果为false，它将查看用户角色映射的领域级别。 这是可选的。 默认值为 false。 public-client 如果设置为true，则适配器将不会将客户端的凭据发送到Keycloak。 这是可选的。 默认值为false。 enable-cors 这使CORS支持成为可能。 它将处理CORS预检请求。 它还将查看访问令牌以确定有效的来源。 这是可选的。 默认值为false。 cors-max-age 如果启用了CORS，则设置Access-Control-Max-Age标头的值。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-allowed-methods 如果启用了CORS，则设置Access-Control-Allow-Methods标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-allowed-headers 如果启用了CORS，则设置Access-Control-Allow-Headers标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 cors-exposed-headers 如果启用了CORS，则设置Access-Control-Expose-Headers标头的值。 这应该是逗号分隔的字符串。 这是可选的。 如果未设置，则在CORS响应中不返回此标头。 bearer-only 对于服务，应将其设置为true。 如果启用，适配器将不会尝试对用户进行身份验证，而只会验证承载令牌。 这是可选的。 默认值为false。 autodetect-bearer-only 如果您的应用程序同时提供Web应用程序和Web服务（例如SOAP或REST），则应将其设置为true。 它允许您将未经身份验证的Web应用程序用户重定向到Keycloak登录页面，但是将HTTP401状态代码发送给未经身份验证的SOAP或REST客户端，因为他们无法理解重定向到登录页面。 Keycloak基于典型的标题自动检测SOAP或REST客户端，如X-Requested-With，SOAPAction 或 Accept。 默认值为false。 enable-basic-auth 这告诉适配器也支持基本身份验证。 如果启用此选项，则还必须提供secret。 这是选的。 默认值为false。 expose-token 如果是true，则经过身份验证的浏览器客户端（通过JavaScript HTTP调用）可以通过URL root/k_query_bearer_token获取签名访问令牌。 这是可选的。 默认值为false。 credentials 指定应用程序的凭据。 这是一个对象表示法，其中键是凭证类型，值是凭证类型的值。 目前支持密码和jwt。 这是必须的仅适用于具有'Confidential(机密)'访问类型的客户。 connection-pool-size 适配器将对Keycloak服务器进行单独的HTTP调用，以将访问代码转换为访问令牌。 此配置选项定义应该合并到Keycloak服务器的连接数。 这是可选的。 默认值为20。 disable-trust-manager 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则不必指定信任库。 此设置仅应在开发期间使用，永远不要在生产中使用，因为它将禁用SSL证书的验证。 这是可选的。 默认值为false。 allow-any-hostname 如果Keycloak服务器需要HTTPS并且此配置选项设置为true，则通过信任库验证Keycloak服务器的证书，但不会进行主机名验证。 此设置仅应在开发期间使用，永远不要在生产中使用，因为它将禁用SSL证书的验证。 此测试在测试环境中可能很有用。这是可选的。 默认值为false。 proxy-url HTTP代理的URL（如果使用）。 truststore 该值是信任库文件的文件路径。 如果在路径前加上classpath:，那么将从部署的类路径中获取信任库。 用于与Keycloak服务器的传出HTTPS通信。 发出HTTPS请求的客户端需要一种方法来验证他们正在与之通信的服务器的主机。 这就是委托人所做的。 密钥库包含一个或多个可信主机证书或证书颁发机构。 您可以通过提取Keycloak服务器的SSL密钥库的公共证书来创建此信任库。 这是 必须的，除非ssl-required是none或disable-trust-manager 是 true。 truststore-password 信任库的密码。 如果设置了truststore并且信任库需要密码，那么这是必须的。 client-keystore 这是密钥库文件的文件路径。 当适配器向Keycloak服务器发出HTTPS请求时，此密钥库包含双向SSL的客户端证书。 这是可选的。 client-keystore-password 客户端密钥库的密码。 如果设置了client-keystore，这是必须的。 client-key-password 客户密钥的密码。 如果设置了client-keystore，这是必须的。 always-refresh-token 如果true，则适配器将在每个请求中刷新令牌。 register-node-at-startup 如果true，则适配器将向Keycloak发送注册请求。 它默认为false，仅在应用程序集群时才有用。 有关详细信息，请参阅应用程序群集 register-node-period 重新注册适配器到Keycloak的期限。 应用程序集群时很有用。 有关详细信息，请参阅应用程序群集 token-store 可能的值是session和cookie。 默认为session，这意味着适配器在HTTP会话中存储帐户信息。 如果是cookie表示在cookie中存储信息。 有关详细信息，请参阅应用程序群集 token-cookie-path 使用cookie存储时，此选项设置用于存储帐户信息的cookie的路径。 如果它是相对路径，则假定应用程序在上下文根中运行，并且相对于该上下文根进行解释。 如果它是绝对路径，则绝对路径用于设置cookie路径。 默认使用相对于上下文根的路径。 principal-attribute 使用OpenID Connect ID Token属性填充UserPrincipal名称。 如果token属性为null，则默认为sub。 可能的值是sub，preferred_username，email，name，nickname，given_name，family_name。 turn-off-change-session-id-on-login 默认情况下，在某些平台上成功登录时会更改会话ID以插入安全攻击向量。 如果要将其关闭，请将此更改为true这是可选的。 默认值为false。 token-minimum-time-to-live 在Keycloak服务器到期之前使用Keycloak服务器抢先刷新活动访问令牌的时间（以秒为单位）。 当访问令牌被发送到另一个REST客户端时，这在它可能在评估之前到期时特别有用。 该值不应超过领域的访问令牌寿命。 这是可选的。 默认值为0秒，因此适配器将刷新访问令牌，如果它已过期。 min-time-between-jwks-requests 指定Keycloak检索新公钥的两个请求之间的最小间隔的时间量（以秒为单位）。 默认为10秒。 当适配器识别带有未知kid的令牌时，它总是会尝试下载新的公钥。 但是，它不会每10秒尝试一次（默认情况下）。 这是为了避免DoS，当攻击者发送大量带有错误kid强制适配器的令牌向Keycloak发送大量请求时。 public-key-cache-ttl 指定Keycloak检索新公钥的两个请求之间的最大间隔的时间量（以秒为单位）。 默认为86400秒（1天）。 当适配器识别带有未知kid的令牌时，它总是会尝试下载新的公钥。 如果它识别已知kid的令牌，它将只使用先前下载的公钥。 但是，每个此配置的间隔（默认为1天）至少一次将是新的公钥，即使令牌的kid已知，也会一直下载。 ignore-oauth-query-parameter 默认为false，如果设置为true将关闭处理承载令牌处理的access_token查询参数。 如果用户只传入access_token，他们将无法进行身份验证 redirect-rewrite-rules 如果需要，请指定重定向URI重写规则。 这是一个对象表示法，其中键是要与Redirect URI匹配的正则表达式，值是替换String。 $字符可用于替换String中的反向引用。 verify-token-audience 如果设置为“true”，则在使用承载令牌进行身份验证期间，适配器将验证令牌是否包含此客户端名称（资源）作为受众。 该选项对于主要服务于由承载令牌验证的请求的服务特别有用。 默认设置为false，但为了提高安全性，建议启用此功能。 有关受众群体支持的详细信息，请参阅受众群体支持。 2.1.2. JBoss EAP/WildFly 适配器 为了能够保护部署在JBoss EAP，WildFly或JBoss AS上的WAR应用程序，您必须安装和配置Keycloak适配器子系统。 然后，您有两个选项来保护您的WAR。 您可以在WAR中提供适配器配置文件，并在web.xml中将auth-method更改为KEYCLOAK。 或者，您根本不必修改WAR，并且可以通过配置文件中的Keycloak适配器子系统配置（例如standalone.xml）来保护它。 本节将介绍这两种方法。 安装适配器 根据您使用的服务器版本，适配器可作为单独的存档提供。 我们只测试和维护适配器，并在发布时提供最新版本的WildFly。 一旦发布了新版本的WildFly，当前的适配器将被弃用，并且在下一个WildFly版本发布后将删除对它们的支持。 另一种方法是将应用程序从WildFly切换到JBoss EAP，因为JBoss EAP适配器的支持时间更长。 安装WildFly 9或更新版本: $ cd $WILDFLY_HOME $ unzip keycloak-wildfly-adapter-dist-6.0.1.zip 安装WildFly 8: $ cd $WILDFLY_HOME $ unzip keycloak-wf8-adapter-dist-6.0.1.zip 安装JBoss EAP 7: $ cd $EAP_HOME $ unzip keycloak-eap7-adapter-dist-6.0.1.zip 安装JBoss EAP 6: $ cd $EAP_HOME $ unzip keycloak-eap6-adapter-dist-6.0.1.zip 安装JBoss AS 7.1: $ cd $JBOSS_HOME $ unzip keycloak-as7-adapter-dist-6.0.1.zip 此ZIP存档包含特定于Keycloak适配器的JBoss模块。 它还包含JBoss CLI脚本以配置适配器子系统。 要在服务器未运行时配置适配器子系统，请执行： 或者，您可以在从命令行安装适配器时指定server.config属性，以使用其他配置安装适配器，例如：-Dserver.config=standalone-ha.xml。 WildFly 11 或者 更新版本 $ ./bin/jboss-cli.sh --file=bin/adapter-elytron-install-offline.cli WildFly 10 或者 更旧版本 $ ./bin/jboss-cli.sh --file=bin/adapter-install-offline.cli 可以在WildFly 11或更新版本上使用传统的非Elytron适配器，这意味着即使在这些版本上也可以使用adapter-install-offline.cli。 但是，我们建议使用较新的Elytron适配器。 或者，如果服务器正在运行，则执行： WildFly 11 或者 更新版本 $ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install.cli WildFly 10 或者 更旧版本 $ ./bin/jboss-cli.sh -c --file=bin/adapter-install.cli JBoss SSO WildFly内置支持部署到同一WildFly实例的Web应用程序的单点登录。 使用Keycloak时不应启用此功能。 每个WAR配置必需 本节介绍如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR的WEB-INF目录中创建一个keycloak.json适配器配置文件。 此配置文件的格式在Java适配器配置 部分中进行了描述。 接下来，您必须在web.xml中将auth-method设置为KEYCLOAK。 您还必须使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： application Admins /admin/* admin CONFIDENTIAL Customers /customers/* user CONFIDENTIAL KEYCLOAK this is ignored currently admin user 通过适配器子系统保护WAR 您不必修改WAR以使用Keycloak保护它。 相反，您可以通过Keycloak适配器子系统从外部保护它。 虽然您不必将KEYCLOAK指定为auth-method，但仍需要在web.xml中定义security-constraints。 但是，您不必创建WEB-INF/keycloak.json文件。 而是在Keycloak子系统定义中的服务器配置（即standalone.xml）中定义此元数据。 demo http://localhost:8081/auth external customer-portal password secure-deployment``name属性标识要保护的WAR。 它的值是web.xml中定义的module-name，附加了.war。 其余的配置几乎与Java adapter configuration中定义的keycloak.json配置选项一一对应。 例外是credential元素。 为了方便您，您可以转到Keycloak管理控制台并转到此WAR所对应的应用程序的客户端/安装选项卡。 它提供了一个可以剪切和粘贴的示例XML文件。 如果您有多个由同一领域保护的部署，则可以在单独的元素中共享领域配置。 例如： http://localhost:8080/auth external demo customer-portal password demo product-portal password demo database-service true 安全域 要将安全上下文传播到EJB层，您需要将其配置为使用“keycloak”安全域。 这可以通过@SecurityDomain注释来实现： import org.jboss.ejb3.annotation.SecurityDomain; ... @Stateless @SecurityDomain(\"keycloak\") public class CustomerService { @RolesAllowed(\"user\") public List getCustomers() { return db.getCustomers(); } } 2.1.3. 从RPM安装JBoss EAP适配器 从RPM安装EAP 7适配器： 在Red Hat Enterprise Linux 7中，term channel被替换为term repository。 在这些说明中，仅使用term repository。 您必须先订阅JBoss EAP 7.2存储库，然后才能从RPM安装EAP 7适配器。 先决条件 确保您的Red Hat Enterprise Linux系统已使用Red Hat Subscription Manager注册到您的帐户。 有关更多信息，请参阅Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须先取消订阅该存储库。 使用Red Hat订阅管理器，使用以下命令订阅JBoss EAP 7.2存储库。根据您的Red Hat Enterprise Linux版本，将替换为6或7。 $ sudo subscription-manager repos --enable=jb-eap-7-for-rhel--server-rpms 使用以下命令安装OIDC的EAP 7适配器: $ sudo yum install eap7-keycloak-adapter-sso7_3 RPM安装的默认EAP_HOME路径是:/opt/rh/eap7/root/usr/share/wildfly。 运行适当的模块安装脚本。 对于OIDC模块，输入以下命令: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli 安装完成。 从RPM安装EAP 6适配器: 在Red Hat Enterprise Linux 7中，term channel被term repository替换。在这些指令中，只使用term repository。 在从RPM安装EAP 6适配器之前，必须订阅JBoss EAP 6.0存储库。 先决条件 确保您的Red Hat Enterprise Linux系统使用Red Hat Subscription Manager注册到您的帐户。有关更多信息，请参见Red Hat订阅管理文档。 如果您已经订阅了另一个JBoss EAP存储库，则必须首先从该存储库取消订阅。 使用Red Hat订阅管理器，使用以下命令订阅JBoss EAP 6.0存储库。根据您的Red Hat Enterprise Linux版本，将替换为6或7。 $ sudo subscription-manager repos --enable=jb-eap-6-for-rhel--server-rpms 使用以下命令安装OIDC的EAP 6适配器: $ sudo yum install keycloak-adapter-sso7_3-eap6 RPM安装的默认EAP_HOME路径是/opt/rh/eap6/root/usr/share/wildfly。 运行适当的模块安装脚本。 对于OIDC模块，输入以下命令: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli 安装完成。 2.1.4. JBoss Fuse 6 适配器 Keycloak支持保护在JBoss Fuse 6中运行的web应用程序。 JBoss Fuse 6利用Jetty 9适配器作为JBoss Fuse 6.3.0 Rollup 5与Jetty 9.2服务器捆绑在一起和Jetty用于运行各种Web应用程序。 Fuse 6唯一受支持的版本是最新版本。 如果使用早期版本的Fuse 6，则某些功能可能无法正常工作。 特别是，Hawtio集成不适用于早期版本的Fuse 6。 Fuse支持以下项目的安全性: 使用Pax Web WAR Extender在Fuse上部署经典的WAR应用程序 使用Pax Web白板扩展器将servlet作为OSGI服务部署在Fuse上 Apache Camel使用Camel Jetty组件运行的Jetty端点 Apache CXF端点在自己独立的Jetty引擎上运行 Apache CXF在CXF servlet提供的默认引擎上运行的端点 SSH和JMX管理员访问权限 Hawtio管理控制台 在Fuse 6中保护Web应用程序 您必须先安装Keycloak Karaf功能。 接下来，您需要根据要保护的应用程序类型执行这些步骤。 所有引用的Web应用程序都需要将Keycloak Jetty身份验证器注入底层Jetty服务器。 实现此目标的步骤取决于应用程序类型。 细节描述如下。 最好的起点是看看作为fuse目录中Keycloak示例的一部分捆绑的Fuse演示。 通过测试和理解演示，大多数步骤都应该是可以理解的。 安装Keycloak功能 您必须首先在JBoss Fuse环境中安装keycloak功能。 keycloak功能包括Fuse适配器和所有第三方依赖项。 您可以从Maven存储库或存档中安装它。 从Maven存储库安装 作为先决条件，您必须在线并且可以访问Maven存储库。 对于社区来说，只要在maven中央存储库中提供所有工件和第三方依赖项就足够了。 要使用Maven存储库安装keycloak功能，请完成以下步骤： 启动JBoss Fuse 6.3.0 Rollup 5; 然后在Karaf终端类型： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 您可能还需要安装Jetty 9功能： features:install keycloak-jetty9-adapter 确保已安装功能： features:list | grep keycloak 从ZIP捆绑包安装 如果您处于脱机状态或不想使用Maven获取JAR文件和其他工件，这将非常有用。 要从ZIP存档安装Fuse适配器，请完成以下步骤： 下载Keycloak Fuse适配器ZIP存档文件。 将其解压缩到JBoss Fuse的根目录中。 然后将依赖项安装在system目录下。 您可以覆盖所有现有的jar文件。 将此用于JBoss Fuse 6.3.0汇总5： cd /path-to-fuse/jboss-fuse-6.3.0.redhat-254 unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-6.0.1.zip 启动Fuse并在Fuse/karaf终端中运行以下命令: features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 安装相应的Jetty适配器。 由于artifacts可直接在JBoss Fusesystem目录中使用，因此您无需使用Maven存储库。 保护经典WAR应用程序 保护WAR应用程序所需的步骤如下： 在/WEB-INF/web.xml文件中，声明必要的： 元素中的安全性约束 元素中的登录配置 元素中的安全角色。 例如： customer-portal index.html Customers /customers/* user BASIC does-not-matter admin user 将带有验证器的jetty-web.xml文件添加到/WEB-INF/jetty-web.xml文件中。 例如： 在WAR的/WEB-INF/目录中，创建一个新文件keycloak.json。 该配置文件的格式在Java Adapters Config 部分中进行了描述。 也可以按配置外部适配器中的说明在外部使用此文件。 确保您的WAR应用程序在Import-Package标题下的META-INF/MANIFEST.MF文件中导入org.keycloak.adapters.jetty和更多软件包。 在项目中使用maven-bundle-plugin可以在清单中正确生成OSGI头文件。 请注意，包的“*”解析不会导入org.keycloak.adapters.jetty包，因为它不是由应用程序或Blueprint或Spring描述符使用，而是在jetty-web.xml文件中使用。 要导入的包的列表可能是这样的: org.keycloak.adapters.jetty;version=\"6.0.1\", org.keycloak.adapters;version=\"6.0.1\", org.keycloak.constants;version=\"6.0.1\", org.keycloak.util;version=\"6.0.1\", org.keycloak.*;version=\"6.0.1\", *;resolution:=optional 配置外部适配器 如果您不希望将keycloak.json适配器配置文件捆绑在WAR应用程序中，而是根据命名约定在外部提供并加载，请使用此配置方法。 要启用该功能，请将此部分添加到/WEB_INF/web.xml文件中： keycloak.config.resolver org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver 该组件使用keycloak.config或karaf.etc java属性来搜索基本文件夹以找到配置。 然后在其中一个文件夹中搜索名为 -keycloak.json的文件。 因此，例如，如果您的Web应用程序具有上下文my-portal，那么您的适配器配置将从$FUSE_HOME/etc/my-portal-keycloak.json文件加载。 保护部署为OSGI服务的Servlet 如果在OSGI捆绑项目中有一个未部署为经典WAR应用程序的servlet类，则可以使用此方法。 Fuse使用Pax Web Whiteboard Extender将这些servlet部署为Web应用程序。 要使用Keycloak保护您的servlet，请完成以下步骤： Keycloak提供了PaxWebIntegrationService，它允许注入jetty-web.xml并为您的应用程序配置安全性约束。 您需要在应用程序内的OSGI-INF/blueprint/blueprint.xml文件中声明此类服务。 请注意，您的servlet需要依赖它。 配置示例： user 您可能需要在项目中包含WEB-INF目录（即使您的项目不是Web应用程序）并创建/WEB-INF/jetty-web.xml和/WEB-INF/keycloak.json文件，如经典WAR应用程序部分。 请注意，您不需要web.xml文件，因为在蓝图配置文件中声明了安全性约束。 META-INF/MANIFEST.MF中的Import-Package必须至少包含以下导入： org.keycloak.adapters.jetty;version=\"6.0.1\", org.keycloak.adapters;version=\"6.0.1\", org.keycloak.constants;version=\"6.0.1\", org.keycloak.util;version=\"6.0.1\", org.keycloak.*;version=\"6.0.1\", *;resolution:=optional 保护Apache Camel应用程序 您可以通过添加带有KeycloakJettyAuthenticator的securityHandler并注入适当的安全约束来保护使用camel-jetty组件实现的Apache Camel端点。 您可以使用类似以下配置将OSGI-INF/blueprint/blueprint.xml文件添加到Camel应用程序中。 角色，安全约束映射和Keycloak适配器配置可能略有不同，具体取决于您的环境和需求。 例如： admin META-INF/MANIFEST.MF中的Import-Package需要包含这些导入： javax.servlet;version=\"[3,4)\", javax.servlet.http;version=\"[3,4)\", org.apache.camel.*, org.apache.camel;version=\"[2.13,3)\", org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.server.nio;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\", org.osgi.service.blueprint, org.osgi.service.blueprint.container, org.osgi.service.event, Camel RestDSL Camel Rest DSL是一种Camel功能，用于以流畅的方式定义REST端点。 但您仍必须使用特定的实现类，并提供有关如何与Keycloak集成的说明。 配置集成机制的方法取决于您为其配置RestDSL定义的路由的Camel组件。 以下示例显示如何使用Jetty组件配置集成，以及对先前Blueprint示例中定义的某些bean的引用。 Hello rest service Just an helllo (__This second sentence is returned from a Camel RestDSL endpoint__) 在单独的Jetty引擎上保护Apache CXF端点 要在单独的Jetty引擎上运行Keycloak保护的CXF端点，请完成以下步骤： 将META-INF/spring/beans.xml添加到您的应用程序中，并在其中使用Jetty SecurityHandler声明httpj：ngine-factory，并注入KeycloakJettyAuthenticator。 CFX JAX-WS应用程序的配置可能类似于以下内容： user true 对于CXF JAX-RS应用程序，唯一的区别可能在于依赖于engine-factory的端点配置： META-INF/MANIFEST.MF中的Import-Package必须包含那些导入： META-INF.cxf;version=\"[2.7,3.2)\", META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional, org.apache.cxf.bus;version=\"[2.7,3.2)\", org.apache.cxf.bus.spring;version=\"[2.7,3.2)\", org.apache.cxf.bus.resource;version=\"[2.7,3.2)\", org.apache.cxf.transport.http;version=\"[2.7,3.2)\", org.apache.cxf.*;version=\"[2.7,3.2)\", org.springframework.beans.factory.config, org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\" 在默认Jetty引擎上保护Apache CXF端点 某些服务会在启动时自动附带已部署的servlet。 一个这样的服务是在http://localhost:8181/cxf上下文中运行的CXF servlet。 保护这些端点可能很复杂。 Keycloak目前使用的一种方法是ServletReregistrationService，它在启动时取消部署内置servlet，使您能够在Keycloak保护的上下文中重新部署它。 应用程序中的配置文件OSGI-INF/blueprint/blueprint.xml可能类似于下面的那个。 请注意，它添加了JAX-RScustomerservice端点，它是特定于端点的应用程序，但更重要的是，它保护整个/cxf上下文。 user 因此，在默认CXF HTTP目标上运行的所有其他CXF服务也是安全的。 类似地，当取消部署应用程序时，整个/cxf上下文也变得不安全。 因此，如在单独的Jetty引擎上安全CXF应用程序中所述，为您的应用程序使用自己的Jetty引擎，然后为您提供 更好地控制每个应用程序的安全性。 WEB-INF目录可能需要在您的项目中（即使您的项目不是Web应用程序）。 您可能还需要以与经典WAR应用程序类似的方式编辑/WEB-INF/jetty-web.xml和/WEB-INF/keycloak.json文件。 请注意，您不需要web.xml文件，因为蓝图配置文件中声明了安全性约束。 META-INF/MANIFEST.MF中的Import-Package必须包含以下导入： META-INF.cxf;version=\"[2.7,3.2)\", META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional, org.apache.cxf.transport.http;version=\"[2.7,3.2)\", org.apache.cxf.*;version=\"[2.7,3.2)\", com.fasterxml.jackson.jaxrs.json;version=\"[2.5,3)\", org.eclipse.jetty.security;version=\"[9,10)\", org.eclipse.jetty.util.security;version=\"[9,10)\", org.keycloak.*;version=\"6.0.1\", org.keycloak.adapters.jetty;version=\"6.0.1\", *;resolution:=optional 安全Fuse管理服务 使用SSH身份验证来融合终端 Keycloak主要处理用于Web应用程序身份验证的用例; 但是，如果您的其他Web服务和应用程序受Keycloak保护，则使用Keycloak凭据保护非Web管理服务（如SSH）是最佳实践。 您可以使用JAAS登录模块执行此操作，该模块允许远程连接到Keycloak并根据资源所有者密码凭据验证凭据。 要启用SSH身份验证，请完成以下步骤： 在Keycloak中创建一个客户端（例如，ssh-jmx-admin-client），它将用于SSH身份验证。 此客户端需要将Direct Access Grants Enabled选为On。 在$FUSE_HOME/etc/org.apache.karaf.shell.cfg文件中，更新或指定此属性： sshRealm=keycloak 添加$FUSE_HOME/etc/keycloak-direct-access.json文件，其内容类似于以下内容（基于您的环境和Keycloak客户端设置）： { \"realm\": \"demo\", \"resource\": \"ssh-jmx-admin-client\", \"ssl-required\" : \"external\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"credentials\": { \"secret\": \"password\" } } 此文件指定客户端应用程序配置，该命令由来自keycloak JAAS领域的JAAS DirectAccessGrantsLoginModule用于SSH身份验证。 启动Fuse并安装keycloak JAAS领域。 最简单的方法是安装keycloak-jaas功能，它具有预定义的JAAS领域。 您可以使用自己的keycloak JAAS领域覆盖该功能的预定义领域。 有关详细信息，请参阅JBoss Fuse文档。 在Fuse终端中使用以下命令： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak-jaas 通过在终端中键入以下内容，使用SSH作为admin用户登录： ssh -o PubkeyAuthentication=no -p 8101 admin@localhost 使用密码password登录。 在某些更高版本的操作系统上，您可能还需要使用SSH命令的-o选项-o HostKeyAlgorithms=+ssh-dss，因为以后的SSH客户端默认情况下不允许使用ssh-dss算法。 但是，默认情况下，它目前用于JBoss Fuse 6.3.0 Rollup 5。 请注意，用户需要具有领域角色admin来执行所有操作或其他角色来执行操作子集（例如，viewer角色限制用户仅运行只读的Karaf命令）。 可用角色在$FUSE_HOME/etc/org.apache.karaf.shell.cfg或$FUSE_HOME/etc/system.properties中配置。 使用JMX身份验证 如果要使用jconsole或其他外部工具通过RMI远程连接到JMX，则可能需要JMX身份验证。 否则最好使用hawt.io/jolokia，因为jolokia代理默认安装在hawt.io中。 有关详细信息，请参阅Hawtio管理控制台。 要使用JMX身份验证，请完成以下步骤： 在$FUSE_HOME/etc/org.apache.karaf.management.cfg文件中，将jmxRealm属性更改为： jmxRealm=keycloak 安装keycloak-jaas功能并配置$FUSE_HOME/etc/keycloak-direct-access.json文件，如上面的SSH部分所述。 在jconsole中，您可以使用以下URL： service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root 和凭据：admin/password（根据您的环境，具有管理员权限的用户）。 保护Hawtio管理控制台 要使用Keycloak保护Hawtio管理控制台，请完成以下步骤: 将这些属性添加到$FUSE_HOME/etc/system.properties文件中： hawtio.keycloakEnabled=true hawtio.realm=keycloak hawtio.keycloakClientConfig=file://${karaf.base}/etc/keycloak-hawtio-client.json hawtio.rolePrincipalClasses=org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal 在您的领域的Keycloak管理控制台中创建一个客户端。 例如，在Keycloakdemo领域，创建一个客户端hawtio-client，指定public作为Access Type，并指定一个指向Hawtio的重定向URI：http://localhost:8181/hawtio/*。 您还必须配置相应的Web Origin（在本例中为http://localhost:8181）。 使用类似于下面示例中所示的内容在$FUSE_HOME/etc目录中创建keycloak-hawtio-client.json文件。 根据您的Keycloak环境更改realm，resource和auth-server-url属性。 resource属性必须指向上一步中创建的客户端。 该文件由客户端（Hawtio JavaScript应用程序）使用。 { \"realm\" : \"demo\", \"resource\" : \"hawtio-client\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"public-client\" : true } 使用类似于下面示例中所示的内容在$FUSE_HOME/etc 目录中创建keycloak-hawtio.json文件。 根据您的Keycloak环境更改realm和auth-server-url属性。 此文件由服务器（JAAS登录模块）端的适配器使用。 { \"realm\" : \"demo\", \"resource\" : \"jaas\", \"bearer-only\" : true, \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\": false, \"principal-attribute\": \"preferred_username\" } 启动JBoss Fuse 6.3.0 Rollup 5并安装keycloak功能（如果尚未安装）。 Karaf终端中的命令与此示例类似： features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak 转到http://localhost:8181/hawtio并以Keycloak领域的用户身份登录。 请注意，用户需要具有适当的领域角色才能成功向Hawtio进行身份验证。 可用角色在hawtio.roles中的$FUSE_HOME/etc/system.properties文件中配置。 保护JBoss EAP 6.4上的Hawtio 要在JBoss EAP 6.4服务器上运行Hawtio，请完成以下步骤: Set up Keycloak as described in the previous section, Securing the Hawtio Administration Console. It is assumed that: you have a Keycloak realm demo and client hawtio-client your Keycloak is running on localhost:8080 the JBoss EAP 6.4 server with deployed Hawtio will be running on localhost:8181. The directory with this server is referred in next steps as $EAP_HOME. Copy the hawtio-wildfly-1.4.0.redhat-630254.war archive to the $EAP_HOME/standalone/configurationdirectory. For more details about deploying Hawtio see the Fuse Hawtio documentation. Copy the keycloak-hawtio.json and keycloak-hawtio-client.json files with the above content to the $EAP_HOME/standalone/configuration directory. Install the Keycloak adapter subsystem to your JBoss EAP 6.4 server as described in the JBoss adapter documentation. In the $EAP_HOME/standalone/configuration/standalone.xml file configure the system properties as in this example: ... Add the Hawtio realm to the same file in the security-domains section: Add the secure-deployment section hawtio to the adapter subsystem. This ensures that the Hawtio WAR is able to find the JAAS login module classes. Restart the JBoss EAP 6.4 server with Hawtio: cd $EAP_HOME/bin ./standalone.sh -Djboss.socket.binding.port-offset=101 Access Hawtio at http://localhost:8181/hawtio. It is secured by Keycloak. 2.1.5. JBoss Fuse 7 适配器 Edit this sectionReport an issue Keycloak supports securing your web applications running inside JBoss Fuse 7. JBoss Fuse 7 leverages Undertow adapter which is essentially the same as EAP 7 / WildFly Adapter as JBoss Fuse 7.2.0 is bundled with Undertow HTTP engine under the covers and Undertow is used for running various kinds of web applications. The only supported version of Fuse 7 is the latest release. If you use earlier versions of Fuse 7, it is possible that some functions will not work correctly. In particular, integration will not work at all for versions of Fuse 7 lower than 7.0.1. Security for the following items is supported for Fuse: Classic WAR applications deployed on Fuse with Pax Web War Extender Servlets deployed on Fuse as OSGI services with Pax Web Whiteboard Extender and additionally servlets registered through org.osgi.service.http.HttpService#registerServlet() which is standard OSGi Enterprise HTTP Service Apache Camel Undertow endpoints running with the Camel Undertow component Apache CXF endpoints running on their own separate Undertow engine Apache CXF endpoints running on the default engine provided by the CXF servlet SSH and JMX admin access Hawtio administration console Securing Your Web Applications Inside Fuse 7 You must first install the Keycloak Karaf feature. Next you will need to perform the steps according to the type of application you want to secure. All referenced web applications require injecting the Keycloak Undertow authentication mechanism into the underlying web server. The steps to achieve this depend on the application type. The details are described below. The best place to start is look at Fuse demo bundled as part of Keycloak examples in directory fuse . Most of the steps should be understandable from testing and understanding the demo. Installing the Keycloak Feature Edit this sectionReport an issue You must first install the keycloak-pax-http-undertow and keycloak-jaas features in the JBoss Fuse environment. The keycloak-pax-http-undertow feature includes the Fuse adapter and all third-party dependencies. The keycloak-jaas contains JAAS module used in realm for SSH and JMX authentication. You can install it either from the Maven repository or from an archive. Installing from the Maven Repository As a prerequisite, you must be online and have access to the Maven repository. For community it’s sufficient to be online as all the artifacts and 3rd party dependencies should be available in the maven central repository. To install the keycloak feature using the Maven repository, complete the following steps: Start JBoss Fuse 7.2.0; then in the Karaf terminal type: feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features feature:install keycloak-pax-http-undertow keycloak-jaas You might also need to install the Undertow feature: feature:install pax-http-undertow Ensure that the features were installed: feature:list | grep keycloak Installing from the ZIP bundle This is useful if you are offline or do not want to use Maven to obtain the JAR files and other artifacts. To install the Fuse adapter from the ZIP archive, complete the following steps: Download the Keycloak Fuse adapter ZIP archive. Unzip it into the root directory of JBoss Fuse. The dependencies are then installed under the system directory. You can overwrite all existing jar files. Use this for JBoss Fuse 7.2.0: cd /path-to-fuse/fuse-karaf-7.z unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-6.0.1.zip Start Fuse and run these commands in the fuse/karaf terminal: feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features feature:install keycloak-pax-http-undertow keycloak-jaas Install the corresponding Undertow adapter. Since the artifacts are available directly in the JBoss Fuse system directory, you do not need to use the Maven repository. Securing a Classic WAR Application Edit this sectionReport an issue The needed steps to secure your WAR application are: In the /WEB-INF/web.xml file, declare the necessary: security constraints in the element login configuration in the element. Make sure that the is KEYCLOAK. security roles in the element For example: customer-portal index.html Customers /customers/* user KEYCLOAK does-not-matter admin user Within the /WEB-INF/ directory of your WAR, create a new file, keycloak.json. The format of this configuration file is described in the Java Adapters Config section. It is also possible to make this file available externally as described in Configuring the External Adapter. For example: { \"realm\": \"demo\", \"resource\": \"customer-portal\", \"auth-server-url\": \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"credentials\": { \"secret\": \"password\" } } Contrary to the Fuse 6 adapter, there are no special OSGi imports needed in MANIFEST.MF. Configuration Resolvers The keycloak.json adapter configuration file can be stored inside a bundle, which is default behaviour, or in a directory on a filesystem. To specify the actual source of the configuration file, set the keycloak.config.resolver deployment parameter to the desired configuration resolver class. For example, in a classic WAR application, set the keycloak.config.resolver context parameter in web.xml file like this: keycloak.config.resolver org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver The following resolvers are available for keycloak.config.resolver: org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver This is the default resolver. The configuration file is expected inside the OSGi bundle that is being secured. By default, it loads file named WEB-INF/keycloak.json but this file name can be configured via configLocation property. org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver This resolver searches for a file called -keycloak.json inside a folder that is specified by keycloak.config system property. If keycloak.config is not set, karaf.etc system property is used instead.For example, if your web application is deployed into context my-portal, then your adapter configuration would be loaded either from the ${keycloak.config}/my-portal-keycloak.json file, or from ${karaf.etc}/my-portal-keycloak.json. org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver This resolver is similar to PathBasedKeycloakConfigResolver above, where for given URI path, configuration locations are checked from most to least specific.For example, for /my/web-app/context URI, the following configuration locations are searched for existence until the first one exists:${karaf.etc}/my-web-app-context-keycloak.json``${karaf.etc}/my-web-app-keycloak.json``${karaf.etc}/my-keycloak.json``${karaf.etc}/keycloak.json Securing a Servlet Deployed as an OSGI Service Edit this sectionReport an issue You can use this method if you have a servlet class inside your OSGI bundled project that is not deployed as a classic WAR application. Fuse uses Pax Web Whiteboard Extender to deploy such servlets as web applications. To secure your servlet with Keycloak, complete the following steps: Keycloak provides org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService, which allows configuring authentication method and security constraints for your application. You need to declare such services in the OSGI-INF/blueprint/blueprint.xml file inside your application. Note that your servlet needs to depend on it. An example configuration: user You might need to have the WEB-INF directory inside your project (even if your project is not a web application) and create the /WEB-INF/keycloak.json file as described in the Classic WAR application section. Note you don’t need the web.xml file as the security-constraints are declared in the blueprint configuration file. Contrary to the Fuse 6 adapter, there are no special OSGi imports needed in MANIFEST.MF. Securing an Apache Camel Application Edit this sectionReport an issue You can secure Apache Camel endpoints implemented with the camel-undertow component by injecting the proper security constraints via blueprint and updating the used component to undertow-keycloak. You have to add the OSGI-INF/blueprint/blueprint.xml file to your Camel application with a similar configuration as below. The roles and security constraint mappings, and adapter configuration might differ slightly depending on your environment and needs. Compared to the standard undertow component, undertow-keycloak component adds two new properties: configResolver is a resolver bean that supplies Keycloak adapter configuration. Available resolvers are listed in Configuration Resolvers section. allowedRoles is a comma-separated list of roles. User accessing the service has to have at least one role to be permitted the access. For example: The Import-Package in META-INF/MANIFEST.MF needs to contain these imports: javax.servlet;version=\"[3,4)\", javax.servlet.http;version=\"[3,4)\", javax.net.ssl, org.apache.camel.*, org.apache.camel;version=\"[2.13,3)\", io.undertow.*, org.keycloak.*;version=\"6.0.1\", org.osgi.service.blueprint, org.osgi.service.blueprint.container Camel RestDSL Camel RestDSL is a Camel feature used to define your REST endpoints in a fluent way. But you must still use specific implementation classes and provide instructions on how to integrate with Keycloak. The way to configure the integration mechanism depends on the Camel component for which you configure your RestDSL-defined routes. The following example shows how to configure integration using the undertow-keycloak component, with references to some of the beans defined in previous Blueprint example. Hello rest service Just a hello (__This second sentence is returned from a Camel RestDSL endpoint__) Securing an Apache CXF Endpoint on a Separate Undertow Engine Edit this sectionReport an issue To run your CXF endpoints secured by Keycloak on a separate Undertow engine, complete the following steps: Add OSGI-INF/blueprint/blueprint.xml to your application, and in it, add the proper configuration resolver bean similarly to Camel configuration. In the httpu:engine-factory declare org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler handler using that camel configuration. The configuration for a CFX JAX-WS application might resemble this one: For the CXF JAX-RS application, the only difference might be in the configuration of the endpoint dependent on engine-factory: The Import-Package in META-INF/MANIFEST.MF must contain those imports: META-INF.cxf;version=\"[2.7,3.3)\", META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional, org.apache.cxf.bus;version=\"[2.7,3.3)\", org.apache.cxf.bus.spring;version=\"[2.7,3.3)\", org.apache.cxf.bus.resource;version=\"[2.7,3.3)\", org.apache.cxf.transport.http;version=\"[2.7,3.3)\", org.apache.cxf.*;version=\"[2.7,3.3)\", org.springframework.beans.factory.config, org.keycloak.*;version=\"6.0.1\" Securing an Apache CXF Endpoint on the Default Undertow Engine Edit this sectionReport an issue Some services automatically come with deployed servlets on startup. One such service is the CXF servlet running in the http://localhost:8181/cxf context. Fuse’s Pax Web supports altering existing contexts via configuration admin. This can be used to secure endpoints by Keycloak. The configuration file OSGI-INF/blueprint/blueprint.xml inside your application might resemble the one below. Note that it adds the JAX-RS customerservice endpoint, which is endpoint-specific to your application. Furthermore, you have to create ${karaf.etc}/org.ops4j.pax.web.context-*anyName*.cfg file. It will be treated as factory PID configuration that is tracked by pax-web-runtime bundle. Such configuration may contain the following properties that correspond to some of the properties of standard web.xml: bundle.symbolicName = org.apache.cxf.cxf-rt-transports-http context.id = default context.param.keycloak.config.resolver = org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver login.config.authMethod = KEYCLOAK security.cxf.url = /cxf/customerservice/* security.cxf.roles = admin, user For full description of available properties in configuration admin file, please refer to Fuse documentation. The properties above have the following meaning: bundle.symbolicName and context.id Identification of the bundle and its deployment context within org.ops4j.pax.web.service.WebContainer. context.param.keycloak.config.resolver Provides value of keycloak.config.resolver context parameter to the bundle just the same as in web.xml for classic WARs. Available resolvers are described in Configuration Resolvers section. login.config.authMethod Authentication method. Must be KEYCLOAK. security.*anyName*.url and security.*anyName*.roles Values of properties of individual security constraints just as they would be set in security-constraint/web-resource-collection/url-pattern and security-constraint/auth-constraint/role-name in web.xml, respectively. Roles are separated by comma and whitespace around it. The *anyName* identifier can be arbitrary but must match for individual properties of the same security constraint.Some Fuse versions contain a bug that requires roles to be separated by \", \" (comma and single space). Make sure you use precisely this notation for separating the roles. The Import-Package in META-INF/MANIFEST.MF must contain at least these imports: javax.ws.rs;version=\"[2,3)\", META-INF.cxf;version=\"[2.7,3.3)\", META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional, org.apache.cxf.transport.http;version=\"[2.7,3.3)\", org.apache.cxf.*;version=\"[2.7,3.3)\", com.fasterxml.jackson.jaxrs.json;version=\"${jackson.version}\" Securing Fuse Administration Services Edit this sectionReport an issue Using SSH Authentication to Fuse Terminal Keycloak mainly addresses use cases for authentication of web applications; however, if your other web services and applications are protected with Keycloak, protecting non-web administration services such as SSH with Keycloak credentials is a best pracrice. You can do this using the JAAS login module, which allows remote connection to Keycloak and verifies credentials based on Resource Owner Password Credentials. To enable SSH authentication, complete the following steps: In Keycloak create a client (for example, ssh-jmx-admin-client), which will be used for SSH authentication. This client needs to have Direct Access Grants Enabled selected to On. In the $FUSE_HOME/etc/org.apache.karaf.shell.cfg file, update or specify this property: sshRealm=keycloak Add the $FUSE_HOME/etc/keycloak-direct-access.json file with content similar to the following (based on your environment and Keycloak client settings): { \"realm\": \"demo\", \"resource\": \"ssh-jmx-admin-client\", \"ssl-required\" : \"external\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"credentials\": { \"secret\": \"password\" } } This file specifies the client application configuration, which is used by JAAS DirectAccessGrantsLoginModule from the keycloak JAAS realm for SSH authentication. Start Fuse and install the keycloak JAAS realm. The easiest way is to install the keycloak-jaas feature, which has the JAAS realm predefined. You can override the feature’s predefined realm by using your own keycloak JAAS realm with higher ranking. For details see the JBoss Fuse documentation. Use these commands in the Fuse terminal: features:addurl mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features features:install keycloak-jaas Log in using SSH as admin user by typing the following in the terminal: ssh -o PubkeyAuthentication=no -p 8101 admin@localhost Log in with password password. On some later operating systems, you might also need to use the SSH command’s -o option -o HostKeyAlgorithms=+ssh-dss because later SSH clients do not allow use of the ssh-dss algorithm, by default. However, by default, it is currently used in JBoss Fuse 7.2.0. Note that the user needs to have realm role admin to perform all operations or another role to perform a subset of operations (for example, the viewer role that restricts the user to run only read-only Karaf commands). The available roles are configured in $FUSE_HOME/etc/org.apache.karaf.shell.cfg or $FUSE_HOME/etc/system.properties. Using JMX Authentication JMX authentication might be necessary if you want to use jconsole or another external tool to remotely connect to JMX through RMI. Otherwise it might be better to use hawt.io/jolokia, since the jolokia agent is installed in hawt.io by default. For more details see Hawtio Admin Console. To use JMX authentication, complete the following steps: In the $FUSE_HOME/etc/org.apache.karaf.management.cfg file, change the jmxRealm property to: jmxRealm=keycloak Install the keycloak-jaas feature and configure the $FUSE_HOME/etc/keycloak-direct-access.json file as described in the SSH section above. In jconsole you can use a URL such as: service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root and credentials: admin/password (based on the user with admin privileges according to your environment). Securing the Hawtio Administration Console Edit this sectionReport an issue To secure the Hawtio Administration Console with Keycloak, complete the following steps: Create a client in the Keycloak administration console in your realm. For example, in the Keycloak demorealm, create a client hawtio-client, specify public as the Access Type, and specify a redirect URI pointing to Hawtio: http://localhost:8181/hawtio/*. Configure corresponding Web Origin (in this case, http://localhost:8181). Setup client scope mapping to include view-profile client role of account client in Scope tab in hawtio-client client detail. Create the keycloak-hawtio-client.json file in the $FUSE_HOME/etc directory using content similar to that shown in the example below. Change the realm, resource, and auth-server-url properties according to your Keycloak environment. The resource property must point to the client created in the previous step. This file is used by the client (Hawtio JavaScript application) side. { \"realm\" : \"demo\", \"clientId\" : \"hawtio-client\", \"url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"public-client\" : true } Create the keycloak-direct-access.json file in the $FUSE_HOME/etc directory using content similar to that shown in the example below. Change the realm and url properties according to your Keycloak environment. This file is used by JavaScript client. { \"realm\" : \"demo\", \"resource\" : \"ssh-jmx-admin-client\", \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"credentials\": { \"secret\": \"password\" } } Create the keycloak-hawtio.json file in the $FUSE_HOME/etc dicrectory using content similar to that shown in the example below. Change the realm and auth-server-url properties according to your Keycloak environment. This file is used by the adapters on the server (JAAS Login module) side. { \"realm\" : \"demo\", \"resource\" : \"jaas\", \"bearer-only\" : true, \"auth-server-url\" : \"http://localhost:8080/auth\", \"ssl-required\" : \"external\", \"use-resource-role-mappings\": false, \"principal-attribute\": \"preferred_username\" } Start JBoss Fuse 7.2.0, install the Keycloak feature. Then type in the Karaf terminal: system:property -p hawtio.keycloakEnabled true system:property -p hawtio.realm keycloak system:property -p hawtio.keycloakClientConfig file://\\${karaf.base}/etc/keycloak-hawtio-client.json system:property -p hawtio.rolePrincipalClasses org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal restart io.hawt.hawtio-war Go to http://localhost:8181/hawtio and log in as a user from your Keycloak realm. Note that the user needs to have the proper realm role to successfully authenticate to Hawtio. The available roles are configured in the $FUSE_HOME/etc/system.properties file in hawtio.roles. 2.1.6. Spring Boot 适配器 为了能够保护Spring Boot应用程序，您必须将Keycloak Spring Boot适配器JAR添加到您的应用程序。 然后，您必须通过正常的Spring Boot配置（application.properties）提供一些额外的配置。 我们来看看这些步骤。 适配器安装 Keycloak Spring Boot适配器利用Spring Boot的自动配置，因此您只需将Keycloak Spring Boot启动器添加到您的项目中即可。 他们的Keycloak Spring Boot Starter也可以从Spring Start Page直接获得。 要使用Maven手动添加它，请将以下内容添加到依赖项中： org.keycloak keycloak-spring-boot-starter 添加适配器BOM依赖项： org.keycloak.bom keycloak-adapter-bom 6.0.1 pom import 目前支持以下嵌入式容器，如果使用Starter，则不需要任何额外的依赖项： Tomcat Undertow Jetty 必需的Spring Boot Adapter配置 本节介绍如何配置Spring Boot应用程序以使用Keycloak。 不需要配置keycloak.json文件，您可以通过正常的Spring Boot配置为Spring Boot Keycloak适配器配置域。 例如： keycloak.realm = demorealm keycloak.auth-server-url = http://127.0.0.1:8080/auth keycloak.ssl-required = external keycloak.resource = demoapp keycloak.credentials.secret = 11111111-1111-1111-1111-111111111111 keycloak.use-resource-role-mappings = true 您可以通过设置keycloak.enabled=false来禁用Keycloak Spring Boot Adapter（例如在测试中）。 要配置策略强制实施器，与keycloak.json不同，必须使用policy-enforcer-config而不仅仅是policy-enforcer。 您还需要指定通常位于web.xml中的Java EE安全配置。 Spring Boot Adapter将login-method设置为KEYCLOAK并在启动时配置security-constraints。 这是一个示例配置： keycloak.securityConstraints[0].authRoles[0] = admin keycloak.securityConstraints[0].authRoles[1] = user keycloak.securityConstraints[0].securityCollections[0].name = insecure stuff keycloak.securityConstraints[0].securityCollections[0].patterns[0] = /insecure keycloak.securityConstraints[1].authRoles[0] = admin keycloak.securityConstraints[1].securityCollections[0].name = admin stuff keycloak.securityConstraints[1].securityCollections[0].patterns[0] = /admin 如果您计划将Spring应用程序部署为WAR，那么不应该使用Spring引导适配器，而应该为您正在使用的应用程序服务器或servlet容器使用专用适配器。您的Spring Boot还应该包含一个 web.xml文件。 2.1.7. Tomcat 6, 7 and 8 适配器 为了能够保护部署在Tomcat 6,7和8上的WAR应用程序，您必须在Tomcat安装中安装Keycloak Tomcat 6,7或8适配器。 然后，您必须在部署到Tomcat的每个WAR中提供一些额外的配置。 我们来看看这些步骤。 适配器安装 适配器不再包含在设备或war分发版中。每个适配器在Keycloak下载站点上都是单独的下载。它们也可以作为maven构件使用。 您必须将适配器发行版解压到Tomcat的lib/目录中。在WEB-INF/lib目录中包含适配器的jar将不起作用!Keycloak适配器实现为一个Valve，而Valve代码必须驻留在Tomcat的主lib/目录中。 $ cd $TOMCAT_HOME/lib $ unzip keycloak-tomcat6-adapter-dist.zip or $ unzip keycloak-tomcat7-adapter-dist.zip or $ unzip keycloak-tomcat8-adapter-dist.zip 每个WAR配置所需 本节描述如何通过在WAR包中添加配置和编辑文件来直接保护WAR。 您必须做的第一件事是在WAR包中创建一个META-INF/context.xml文件。 这是一个特定于Tomcat的配置文件，您必须定义一个Keycloak特定的Valve。 接下来，您必须在WAR的WEB-INF目录中创建一个keycloak.json适配器配置文件。 该配置文件的格式在Java适配器配置中进行了描述 最后，您必须同时指定login-config并使用标准servlet安全性来指定URL上的角色基础约束。 这是一个例子： customer-portal Customers /* user BASIC this is ignored currently admin user 2.1.8. Jetty 9.x 适配器 Edit this sectionReport an issue Keycloak has a separate adapter for Jetty 9.2.x, Jetty 9.3.x and Jetty 9.4.x that you will have to install into your Jetty installation. You then have to provide some extra configuration in each WAR you deploy to Jetty. Let’s go over these steps. Adapter Installation Adapters are no longer included with the appliance or war distribution. Each adapter is a separate download on the Keycloak download site. They are also available as a maven artifact. You must unzip the Jetty 9.x distro into Jetty 9.x’s base directory. Including adapter’s jars within your WEB-INF/lib directory will not work! In the example below, the Jetty base is named your-base: $ cd your-base $ unzip keycloak-jetty93-adapter-dist-2.5.0.Final.zip Next, you will have to enable the keycloak module for your Jetty base: $ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak Required Per WAR Configuration This section describes how to secure a WAR directly by adding config and editing files within your WAR package. The first thing you must do is create a WEB-INF/jetty-web.xml file in your WAR package. This is a Jetty specific config file and you must define a Keycloak specific authenticator within it. Next you must create a keycloak.json adapter config file within the WEB-INF directory of your WAR. The format of this config file is described in the Java adapter configuration section. The Jetty 9.x adapter will not be able to find the keycloak.json file. You will have to define all adapter settings within the jetty-web.xml file as described below. Instead of using keycloak.json, you can define everything within the jetty-web.xml. You’ll just have to figure out how the json settings match to the org.keycloak.representations.adapters.config.AdapterConfig class. tomcat customer-portal http://localhost:8081/auth external secret password You do not have to crack open your WAR to secure it with keycloak. Instead create the jetty-web.xml file in your webapps directory with the name of yourwar.xml. Jetty should pick it up. In this mode, you’ll have to declare keycloak.json configuration directly within the xml file. Finally you must specify both a login-config and use standard servlet security to specify role-base constraints on your URLs. Here’s an example: customer-portal Customers /* user CONFIDENTIAL BASIC this is ignored currently admin user 2.1.9. Spring Security 适配器 Edit this sectionReport an issue To secure an application with Spring Security and Keycloak, add this adapter as a dependency to your project. You then have to provide some extra beans in your Spring Security configuration file and add the Keycloak security filter to your pipeline. Unlike the other Keycloak Adapters, you should not configure your security in web.xml. However, keycloak.json is still required. Adapter Installation Add Keycloak Spring Security adapter as a dependency to your Maven POM or Gradle build. org.keycloak keycloak-spring-security-adapter 6.0.1 Spring Security Configuration The Keycloak Spring Security adapter takes advantage of Spring Security’s flexible security configuration syntax. Java Configuration Keycloak provides a KeycloakWebSecurityConfigurerAdapter as a convenient base class for creating a WebSecurityConfigurerinstance. The implementation allows customization by overriding methods. While its use is not required, it greatly simplifies your security context configuration. @KeycloakConfiguration public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { /** * Registers the KeycloakAuthenticationProvider with the authentication manager. */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(keycloakAuthenticationProvider()); } /** * Defines the session authentication strategy. */ @Bean @Override protected SessionAuthenticationStrategy sessionAuthenticationStrategy() { return new RegisterSessionAuthenticationStrategy(new SessionRegistryImpl()); } @Override protected void configure(HttpSecurity http) throws Exception { super.configure(http); http .authorizeRequests() .antMatchers(\"/customers*\").hasRole(\"USER\") .antMatchers(\"/admin*\").hasRole(\"ADMIN\") .anyRequest().permitAll(); } } You must provide a session authentication strategy bean which should be of type RegisterSessionAuthenticationStrategy for public or confidential applications and NullAuthenticatedSessionStrategy for bearer-only applications. Spring Security’s SessionFixationProtectionStrategy is currently not supported because it changes the session identifier after login via Keycloak. If the session identifier changes, universal log out will not work because Keycloak is unaware of the new session identifier. The @KeycloakConfiguration annotation is a metadata annotion that defines all annotations that are needed to integrate Keycloak in Spring Security. If you have a complexe Spring Security setup you can simply have a look ath the annotations of the @KeycloakConfiguration annotation and create your own custom meta annotation or just use specific Spring annotations for the Keycloak adapter. XML Configuration While Spring Security’s XML namespace simplifies configuration, customizing the configuration can be a bit verbose. Multi Tenancy The Keycloak Spring Security adapter also supports multi tenancy. Instead of injecting AdapterDeploymentContextFactoryBean with the path to keycloak.json you can inject an implementation of the KeycloakConfigResolver interface. More details on how to implement the KeycloakConfigResolver can be found in Multi Tenancy. Naming Security Roles Spring Security, when using role-based authentication, requires that role names start with ROLE_. For example, an administrator role must be declared in Keycloak as ROLE_ADMIN or similar, not simply ADMIN. The class org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider supports an optional org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper which can be used to map roles coming from Keycloak to roles recognized by Spring Security. Use, for example, org.springframework.security.core.authority.mapping.SimpleAuthorityMapper to insert the ROLE_ prefix and convert the role name to upper case. The class is part of Spring Security Core module. Client to Client Support To simplify communication between clients, Keycloak provides an extension of Spring’s RestTemplate that handles bearer token authentication for you. To enable this feature your security configuration must add the KeycloakRestTemplatebean. Note that it must be scoped as a prototype to function correctly. For Java configuration: @Configuration @EnableWebSecurity @ComponentScan(basePackageClasses = KeycloakSecurityComponents.class) public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { ... @Autowired public KeycloakClientRequestFactory keycloakClientRequestFactory; @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public KeycloakRestTemplate keycloakRestTemplate() { return new KeycloakRestTemplate(keycloakClientRequestFactory); } ... } For XML configuration: Your application code can then use KeycloakRestTemplate any time it needs to make a call to another client. For example: @Service public class RemoteProductService implements ProductService { @Autowired private KeycloakRestTemplate template; private String endpoint; @Override public List getProducts() { ResponseEntity response = template.getForEntity(endpoint, String[].class); return Arrays.asList(response.getBody()); } } Spring Boot Integration The Spring Boot and the Spring Security adapters can be combined. If you are using the Keycloak Spring Boot Starter to make use of the Spring Security adapter you just need to add the Spring Security starter : org.springframework.boot spring-boot-starter-security Using Spring Boot Configuration By Default, the Spring Security Adapter looks for a keycloak.json configuration file. You can make sure it looks at the configuration provided by the Spring Boot Adapter by adding this bean : @Bean public KeycloakConfigResolver KeycloakConfigResolver() { return new KeycloakSpringBootConfigResolver(); } Avoid double bean registration Spring Boot attempts to eagerly register filter beans with the web application context. Therefore, when running the Keycloak Spring Security adapter in a Spring Boot environment, it may be necessary to add FilterRegistrationBeans to your security configuration to prevent the Keycloak filters from being registered twice. Spring Boot 2.1 also disables spring.main.allow-bean-definition-overriding by default. This can mean that an BeanDefinitionOverrideException will be encountered if a Configuration class extending KeycloakWebSecurityConfigurerAdapter registers a bean that is already detected by a @ComponentScan. This can be avoided by overriding the registration to use the Boot-specific @ConditionalOnMissingBean annotation, as with HttpSessionManager below. @Configuration @EnableWebSecurity public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter { ... @Bean public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean( KeycloakAuthenticationProcessingFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean( KeycloakPreAuthActionsFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakAuthenticatedActionsFilterBean( KeycloakAuthenticatedActionsFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean public FilterRegistrationBean keycloakSecurityContextRequestFilterBean( KeycloakSecurityContextRequestFilter filter) { FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter); registrationBean.setEnabled(false); return registrationBean; } @Bean @Override @ConditionalOnMissingBean(HttpSessionManager.class) protected HttpSessionManager httpSessionManager() { return new HttpSessionManager(); } ... } 2.1.10. Java Servlet Filter 适配器 Edit this sectionReport an issue If you are deploying your Java Servlet application on a platform where there is no Keycloak adapter you opt to use the servlet filter adapter. This adapter works a bit differently than the other adapters. You do not define security constraints in web.xml. Instead you define a filter mapping using the Keycloak servlet filter adapter to secure the url patterns you want to secure. Backchannel logout works a bit differently than the standard adapters. Instead of invalidating the HTTP session it marks the session id as logged out. There’s no standard way to invalidate an HTTP session based on a session id. application Keycloak Filter org.keycloak.adapters.servlet.KeycloakOIDCFilter Keycloak Filter /keycloak/* /protected/* In the snippet above there are two url-patterns. /protected/** are the files we want protected, while the /keycloak/** url-pattern handles callbacks from the Keycloak server. If you need to exclude some paths beneath the configured url-patterns you can use the Filter init-param keycloak.config.skipPattern to configure a regular expression that describes a path-pattern for which the keycloak filter should immediately delegate to the filter-chain. By default no skipPattern is configured. Patterns are matched against the requestURI without the context-path. Given the context-path /myapp a request for /myapp/index.html will be matched with /index.html against the skip pattern. keycloak.config.skipPattern ^/(path1|path2|path3).* Note that you should configure your client in the Keycloak Admin Console with an Admin URL that points to a secured section covered by the filter’s url-pattern. The Admin URL will make callbacks to the Admin URL to do things like backchannel logout. So, the Admin URL in this example should be http[s]://hostname/{context-root}/keycloak. The Keycloak filter has the same configuration parameters as the other adapters except you must define them as filter init params instead of context params. To use this filter, include this maven artifact in your WAR poms: org.keycloak keycloak-servlet-filter-adapter 6.0.1 Using on OSGi The servlet filter adapter is packaged as an OSGi bundle, and thus is usable in a generic OSGi environment (R6 and above) with HTTP Service and HTTP Whiteboard. Installation The adapter and its dependencies are distributed as Maven artifacts, so you’ll need either working Internet connection to access Maven Central, or have the artifacts cached in your local Maven repo. If you are using Apache Karaf, you can simply install a feature from the Keycloak feature repo: karaf@root()> feature:repo-add mvn:org.keycloak/keycloak-osgi-features/6.0.1/xml/features karaf@root()> feature:install keycloak-servlet-filter-adapter For other OSGi runtimes, please refer to the runtime documentation on how to install the adapter bundle and its dependencies. If your OSGi platform is Apache Karaf with Pax Web, you should consider using JBoss Fuse 6 or JBoss Fuse 7adapters instead. Configuration First, the adapter needs to be registered as a servlet filter with the OSGi HTTP Service. The most common ways to do this are programmatic (e.g. via bundle activator) and declarative (using OSGi annotations). We recommend using the latter since it simplifies the process of dynamically registering and un-registering the filter: package mypackage; import javax.servlet.Filter; import org.keycloak.adapters.servlet.KeycloakOIDCFilter; import org.osgi.service.component.annotations.Component; import org.osgi.service.http.whiteboard.HttpWhiteboardConstants; @Component( immediate = true, service = Filter.class, property = { KeycloakOIDCFilter.CONFIG_FILE_PARAM + \"=\" + \"keycloak.json\", HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN + \"=\" +\"/*\", HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT + \"=\" + \"(osgi.http.whiteboard.context.name=mycontext)\" } ) public class KeycloakFilter extends KeycloakOIDCFilter { // } The above snippet uses OSGi declarative service specification to expose the filter as an OSGI service under javax.servlet.Filter class. Once the class is published in the OSGi service registry, it is going to be picked up by OSGi HTTP Service implementation and used for filtering requests for the specified servlet context. This will trigger Keycloak adapter for every request that matches servlet context path + filter path. Since the component is put under the control of OSGi Configuration Admin Service, it’s properties can be configured dynamically. To do that, either create a mypackage.KeycloakFilter.cfg file under the standard config location for your OSGi runtime: keycloak.config.file = /path/to/keycloak.json osgi.http.whiteboard.filter.pattern = /secure/* or use interactive console, if your runtime allows for that: karaf@root()> config:edit mypackage.KeycloakFilter karaf@root()> config:property-set keycloak.config.file '${karaf.etc}/keycloak.json' karaf@root()> config:update If you need more control, like e.g. providing custom KeycloakConfigResolver to implement multi tenancy, you can register the filter programmatically: public class Activator implements BundleActivator { private ServiceRegistration registration; public void start(BundleContext context) throws Exception { Hashtable props = new Hashtable(); props.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN, \"/secure/*\"); props.put(KeycloakOIDCFilter.CONFIG_RESOLVER_PARAM, new MyConfigResolver()); this.registration = context.registerService(Filter.class.getName(), new KeycloakOIDCFilter(), props); } public void stop(BundleContext context) throws Exception { this.registration.unregister(); } } Please refer to Apache Felix HTTP Service for more info on programmatic registration. 2.1.11. JAAS 插件 Edit this sectionReport an issue It’s generally not needed to use JAAS for most of the applications, especially if they are HTTP based, and you should most likely choose one of our other adapters. However, some applications and systems may still rely on pure legacy JAAS solution. Keycloak provides two login modules to help in these situations. The provided login modules are: org.keycloak.adapters.jaas.DirectAccessGrantsLoginModule This login module allows to authenticate with username/password from Keycloak. It’s using Resource Owner Password Credentials flow to validate if the provided username/password is valid. It’s useful for non-web based systems, which need to rely on JAAS and want to use Keycloak, but can’t use the standard browser based flows due to their non-web nature. Example of such application could be messaging or SSH. org.keycloak.adapters.jaas.BearerTokenLoginModule This login module allows to authenticate with Keycloak access token passed to it through CallbackHandler as password. It may be useful for example in case, when you have Keycloak access token from standard based authentication flow and your web application then needs to talk to external non-web based system, which rely on JAAS. For example a messaging system. Both modules use the following configuration properties: keycloak-config-file The location of the keycloak.json configuration file. The configuration file can either be located on the filesystem or on the classpath. If it’s located on the classpath you need to prefix the location with classpath: (for example classpath:/path/keycloak.json). This is REQUIRED. role-principal-class Configure alternative class for Role principals attached to JAAS Subject. Default value is org.keycloak.adapters.jaas.RolePrincipal. Note: The class is required to have a constructor with a single Stringargument. scope This option is only applicable to the DirectAccessGrantsLoginModule. The specified value will be used as the OAuth2 scope parameter in the Resource Owner Password Credentials Grant request. 2.1.12. CLI / Desktop 应用 Edit this sectionReport an issue Keycloak supports securing desktop (e.g. Swing, JavaFX) or CLI applications via the KeycloakInstalledadapter by performing the authentication step via the system browser. The KeycloakInstalled adapter supports a desktop and a manual variant. The desktop variant uses the system browser to gather the user credentials. The manual variant reads the user credentials from STDIN. Tip: Google provides some more information about this approach on at OAuth2InstalledApp. How it works To authenticate a user with the desktop variant the KeycloakInstalled adapter opens a desktop browser window where a user uses the regular Keycloak login pages to login when the loginDesktop() method is called on the KeycloakInstalled object. The login page URL is opened with redirect parameter that points to a local ServerSocket listening on a free ephemeral port on localhost which is started by the adapter. After a succesful login the KeycloakInstalled receives the authorization code from the incoming HTTP request and performs the authorization code flow. Once the code to token exchange is completed the ServerSocket is shutdown. If the user already has an active Keycloak session then the login form is not shown but the code to token exchange is continued, which enables a smooth Web based SSO experience. The client eventually receives the tokens (access_token, refresh_token, id_token) which can then be used to call backend services. The KeycloakInstalled adapter provides support for renewal of stale tokens. Adapter Installation org.keycloak keycloak-installed-adapter 6.0.1 Client Configuration The application needs to be configured as a public OpenID Connect client with Standard Flow Enabled and http://localhost:* as an allowed Valid Redirect URI. Usage The KeycloakInstalled adapter reads it’s configuration from META-INF/keycloak.json on the classpath. Custom configurations can be supplied with an InputStream or a KeycloakDeployment through the KeycloakInstalledconstructor. In the example below, the client configuration for desktop-app uses the following keycloak.json: { \"realm\": \"desktop-app-auth\", \"auth-server-url\": \"http://localhost:8081/auth\", \"ssl-required\": \"external\", \"resource\": \"desktop-app\", \"public-client\": true, \"use-resource-role-mappings\": true } the following sketch demonstrates working with the KeycloakInstalled adapter: // reads the configuration from classpath: META-INF/keycloak.json KeycloakInstalled keycloak = new KeycloakInstalled(); // opens desktop browser keycloak.loginDesktop(); AccessToken token = keycloak.getToken(); // use token to send backend request // ensure token is valid for at least 30 seconds long minValidity = 30L; String tokenString = keycloak.getTokenString(minValidity, TimeUnit.SECONDS); // when you want to logout the user. keycloak.logout(); The KeycloakInstalled class supports customization of the http responses returned by login / logout requests via the loginResponseWriter and logoutResponseWriter attributes. Example The following provides an example for the configuration mentioned above. import java.util.Locale; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import org.keycloak.adapters.installed.KeycloakInstalled; import org.keycloak.representations.AccessToken; public class DesktopApp { public static void main(String[] args) throws Exception { KeycloakInstalled keycloak = new KeycloakInstalled(); keycloak.setLocale(Locale.ENGLISH); keycloak.loginDesktop(); AccessToken token = keycloak.getToken(); Executors.newSingleThreadExecutor().submit(() -> { System.out.println(\"Logged in...\"); System.out.println(\"Token: \" + token.getSubject()); System.out.println(\"Username: \" + token.getPreferredUsername()); try { System.out.println(\"AccessToken: \" + keycloak.getTokenString()); } catch (Exception ex) { ex.printStackTrace(); } int timeoutSeconds = 20; System.out.printf(\"Logging out in...%d Seconds%n\", timeoutSeconds); try { TimeUnit.SECONDS.sleep(timeoutSeconds); } catch (Exception e) { e.printStackTrace(); } try { keycloak.logout(); } catch (Exception e) { e.printStackTrace(); } System.out.println(\"Exiting...\"); System.exit(0); }); } } 2.1.13. 安全上下文 Edit this sectionReport an issue The KeycloakSecurityContext interface is available if you need to access to the tokens directly. This could be useful if you want to retrieve additional details from the token (such as user profile information) or you want to invoke a RESTful service that is protected by Keycloak. In servlet environments it is available in secured invocations as an attribute in HttpServletRequest: httpServletRequest .getAttribute(KeycloakSecurityContext.class.getName()); Or, it is available in insecured requests in the HttpSession: httpServletRequest.getSession() .getAttribute(KeycloakSecurityContext.class.getName()); 2.1.14. 错误处理 Edit this sectionReport an issue Keycloak has some error handling facilities for servlet based client adapters. When an error is encountered in authentication, Keycloak will call HttpServletResponse.sendError(). You can set up an error-page within your web.xml file to handle the error however you want. Keycloak can throw 400, 401, 403, and 500 errors. 403 /ErrorHandler Keycloak also sets a HttpServletRequest attribute that you can retrieve. The attribute name is org.keycloak.adapters.spi.AuthenticationError, which should be casted to org.keycloak.adapters.OIDCAuthenticationError. For example: import org.keycloak.adapters.OIDCAuthenticationError; import org.keycloak.adapters.OIDCAuthenticationError.Reason; ... OIDCAuthenticationError error = (OIDCAuthenticationError) httpServletRequest .getAttribute('org.keycloak.adapters.spi.AuthenticationError'); Reason reason = error.getReason(); System.out.println(reason.name()); 2.1.15. 注销 Edit this sectionReport an issue You can log out of a web application in multiple ways. For Java EE servlet containers, you can call HttpServletRequest.logout(). For other browser applications, you can redirect the browser tohttp://auth-server/auth/realms/{realm-name}/protocol/openid-connect/logout?redirect_uri=encodedRedirectUri, which logs you out if you have an SSO session with your browser. When using the HttpServletRequest.logout() option the adapter executes a back-channel POST call against the Keycloak server passing the refresh token. If the method is executed from an unprotected page (a page that does not check for a valid token) the refresh token can be unavailable and, in that case, the adapter skips the call. For this reason, using a protected page to execute HttpServletRequest.logout() is recommended so that current tokens are always taken into account and an interaction with the Keycloak server is performed if needed. If you want to avoid logging out of an external identity provider as part of the logout process, you can supply the parameter initiating_idp, with the value being the identity (alias) of the identity provider in question. This is useful when the logout endpoint is invoked as part of single logout initiated by the external identity provider. 2.1.16. 参数转发 Edit this sectionReport an issue The Keycloak initial authorization endpoint request has support for various parameters. Most of the parameters are described in OIDC specification. Some parameters are added automatically by the adapter based on the adapter configuration. However, there are also a few parameters that can be added on a per-invocation basis. When you open the secured application URI, the particular parameter will be forwarded to the Keycloak authorization endpoint. For example, if you request an offline token, then you can open the secured application URI with the scope parameter like: http://myappserver/mysecuredapp?scope=offline_access and the parameter scope=offline_access will be automatically forwarded to the Keycloak authorization endpoint. The supported parameters are: scope - Use a space-delimited list of scopes. A space-delimited list typically references Client scopes defined on particular client. Note that the scope openid will be always be added to the list of scopes by the adapter. For example, if you enter the scope options address phone, then the request to Keycloak will contain the scope parameter scope=openid address phone. prompt - Keycloak supports these settings: login - SSO will be ignored and the Keycloak login page will be always shown, even if the user is already authenticated consent - Applicable only for the clients with Consent Required. If it is used, the Consent page will always be displayed, even if the user previously granted consent to this client. none - The login page will never be shown; instead the user will be redirected to the application, with an error if the user is not yet authenticated. This setting allows you to create a filter/interceptor on the application side and show a custom error page to the user. See more details in the specification. max_age - Used only if a user is already authenticated. Specifies maximum permitted time for the authentication to persist, measured from when the user authenticated. If user is authenticated longer than maxAge, the SSO is ignored and he must re-authenticate. login_hint - Used to pre-fill the username/email field on the login form. kc_idp_hint - Used to tell Keycloak to skip showing login page and automatically redirect to specified identity provider instead. More info in the Identity Provider documentation. Most of the parameters are described in the OIDC specification. The only exception is parameter kc_idp_hint, which is specific to Keycloak and contains the name of the identity provider to automatically use. For more information see the Identity Brokering section in Server Administration Guide. If you open the URL using the attached parameters, the adapter will not redirect you to Keycloak if you are already authenticated in the application. For example, opening http://myappserver/mysecuredapp?prompt=login will not automatically redirect you to the Keycloak login page if you are already authenticated to the application mysecredapp . This behavior may be changed in the future. 2.1.17. 客户端身份验证 Edit this sectionReport an issue When a confidential OIDC client needs to send a backchannel request (for example, to exchange code for the token, or to refresh the token) it needs to authenticate against the Keycloak server. By default, there are three ways to authenticate the client: client ID and client secret, client authentication with signed JWT, or client authentication with signed JWT using client secret. Client ID and Client Secret This is the traditional method described in the OAuth2 specification. The client has a secret, which needs to be known to both the adapter (application) and the Keycloak server. You can generate the secret for a particular client in the Keycloak administration console, and then paste this secret into the keycloak.json file on the application side: \"credentials\": { \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\" } Client Authentication with Signed JWT This is based on the RFC7523 specification. It works this way: The client must have the private key and certificate. For Keycloak this is available through the traditional keystore file, which is either available on the client application’s classpath or somewhere on the file system. Once the client application is started, it allows to download its public key in JWKS format using a URL such as http://myhost.com/myapp/k_jwks, assuming that http://myhost.com/myapp is the base URL of your client application. This URL can be used by Keycloak (see below). During authentication, the client generates a JWT token and signs it with its private key and sends it to Keycloak in the particular backchannel request (for example, code-to-token request) in the client_assertion parameter. Keycloak must have the public key or certificate of the client so that it can verify the signature on JWT. In Keycloak you need to configure client credentials for your client. First you need to choose Signed JWT as the method of authenticating your client in the tab Credentials in administration console. Then you can choose to either: Configure the JWKS URL where Keycloak can download the client’s public keys. This can be a URL such as http://myhost.com/myapp/k_jwks (see details above). This option is the most flexible, since the client can rotate its keys anytime and Keycloak then always downloads new keys when needed without needing to change the configuration. More accurately, Keycloak downloads new keys when it sees the token signed by an unknown kid (Key ID). Upload the client’s public key or certificate, either in PEM format, in JWK format, or from the keystore. With this option, the public key is hardcoded and must be changed when the client generates a new key pair. You can even generate your own keystore from the Keycloak admininstration console if you don’t have your own available. For more details on how to set up the Keycloak administration console see Server Administration Guide. For set up on the adapter side you need to have something like this in your keycloak.json file: \"credentials\": { \"jwt\": { \"client-keystore-file\": \"classpath:keystore-client.jks\", \"client-keystore-type\": \"JKS\", \"client-keystore-password\": \"storepass\", \"client-key-password\": \"keypass\", \"client-key-alias\": \"clientkey\", \"token-expiration\": 10 } } With this configuration, the keystore file keystore-client.jks must be available on classpath in your WAR. If you do not use the prefix classpath: you can point to any file on the file system where the client application is running. For inspiration, you can take a look at the examples distribution into the main demo example into the product-portalapplication. Client Authentication with Signed JWT using Client Secret This is the same as Client Authentication with Signed JWT except for using the client secret instead of the private key and certificate. The client has a secret, which needs to be known to both the adapter (application) and the Keycloak server. You need to choose Signed JWT with Client Secret as the method of authenticating your client in the tab Credentials in administration console, and then paste this secret into the keycloak.json file on the application side: \"credentials\": { \"secret-jwt\": { \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\" } } Add Your Own Client Authentication Method You can add your own client authentication method as well. You will need to implement both client-side and server-side providers. For more details see the Authentication SPI section in Server Developer Guide. 2.1.18. 多租户 Edit this sectionReport an issue Multi Tenancy, in our context, means that a single target application (WAR) can be secured with multiple Keycloak realms. The realms can be located one the same Keycloak instance or on different instances. In practice, this means that the application needs to have multiple keycloak.json adapter configuration files. You could have multiple instances of your WAR with different adapter configuration files deployed to different context-paths. However, this may be inconvenient and you may also want to select the realm based on something else than context-path. Keycloak makes it possible to have a custom config resolver so you can choose what adapter config is used for each request. To achieve this first you need to create an implementation of org.keycloak.adapters.KeycloakConfigResolver. For example: package example; import org.keycloak.adapters.KeycloakConfigResolver; import org.keycloak.adapters.KeycloakDeployment; import org.keycloak.adapters.KeycloakDeploymentBuilder; public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver { @Override public KeycloakDeployment resolve(OIDCHttpFacade.Request request) { if (path.startsWith(\"alternative\")) { KeycloakDeployment deployment = cache.get(realm); if (null == deployment) { InputStream is = getClass().getResourceAsStream(\"/tenant1-keycloak.json\"); return KeycloakDeploymentBuilder.build(is); } } else { InputStream is = getClass().getResourceAsStream(\"/default-keycloak.json\"); return KeycloakDeploymentBuilder.build(is); } } } You also need to configure which KeycloakConfigResolver implementation to use with the keycloak.config.resolvercontext-param in your web.xml: ... keycloak.config.resolver example.PathBasedKeycloakConfigResolver 2.1.19. 应用程序集群 Edit this sectionReport an issue This chapter is related to supporting clustered applications deployed to JBoss EAP, WildFly and JBoss AS. There are a few options available depending on whether your application is: Stateless or stateful Distributable (replicated http session) or non-distributable Relying on sticky sessions provided by load balancer Hosted on same domain as Keycloak Dealing with clustering is not quite as simple as for a regular application. Mainly due to the fact that both the browser and the server-side application sends requests to Keycloak, so it’s not as simple as enabling sticky sessions on your load balancer. Stateless token store By default, the web application secured by Keycloak uses the HTTP session to store security context. This means that you either have to enable sticky sessions or replicate the HTTP session. As an alternative to storing the security context in the HTTP session the adapter can be configured to store this in a cookie instead. This is useful if you want to make your application stateless or if you don’t want to store the security context in the HTTP session. To use the cookie store for saving the security context, edit your applications WEB-INF/keycloak.json and add: \"token-store\": \"cookie\" The default value for token-store is session, which stores the security context in the HTTP session. One limitation of using the cookie store is that the whole security context is passed in the cookie for every HTTP request. This may impact performance. Another small limitation is limited support for Single-Sign Out. It works without issues if you init servlet logout (HttpServletRequest.logout) from the application itself as the adapter will delete the KEYCLOAK_ADAPTER_STATE cookie. However, back-channel logout initialized from a different application isn’t propagated by Keycloak to applications using cookie store. Hence it’s recommended to use a short value for the access token timeout (for example 1 minute). Some load balancers do not allow any configuration of the sticky session cookie name or contents, such as Amazon ALB. For these, it is recommended to set the shouldAttachRoute option to false. Relative URI optimization In deployment scenarios where Keycloak and the application is hosted on the same domain (through a reverse proxy or load balancer) it can be convenient to use relative URI options in your client configuration. With relative URIs the URI is resolved as relative to the URL used to access Keycloak. For example if the URL to your application is https://acme.org/myapp and the URL to Keycloak is https://acme.org/auth, then you can use the redirect-uri /myapp instead of https://acme.org/myapp. Admin URL configuration Admin URL for a particular client can be configured in the Keycloak Administration Console. It’s used by the Keycloak server to send backend requests to the application for various tasks, like logout users or push revocation policies. For example the way backchannel logout works is: User sends logout request from one application The application sends logout request to Keycloak The Keycloak server invalidates the user session The Keycloak server then sends a backchannel request to application with an admin url that are associated with the session When an application receives the logout request it invalidates the corresponding HTTP session If admin URL contains ${application.session.host} it will be replaced with the URL to the node associated with the HTTP session. Registration of application nodes The previous section describes how Keycloak can send logout request to node associated with a specific HTTP session. However, in some cases admin may want to propagate admin tasks to all registered cluster nodes, not just one of them. For example to push a new not before policy to the application or to logout all users from the application. In this case Keycloak needs to be aware of all application cluster nodes, so it can send the event to all of them. To achieve this, we support auto-discovery mechanism: When a new application node joins the cluster, it sends a registration request to the Keycloak server The request may be re-sent to Keycloak in configured periodic intervals If the Keycloak server doesn’t receive a re-registration request within a specified timeout then it automatically unregisters the specific node The node is also unregistered in Keycloak when it sends an unregistration request, which is usually during node shutdown or application undeployment. This may not work properly for forced shutdown when undeployment listeners are not invoked, which results in the need for automatic unregistration Sending startup registrations and periodic re-registration is disabled by default as it’s only required for some clustered applications. To enable the feature edit the WEB-INF/keycloak.json file for your application and add: \"register-node-at-startup\": true, \"register-node-period\": 600, This means the adapter will send the registration request on startup and re-register every 10 minutes. In the Keycloak Administration Console you can specify the maximum node re-registration timeout (should be larger than register-node-period from the adapter configuration). You can also manually add and remove cluster nodes in through the Adminstration Console, which is useful if you don’t want to rely on the automatic registration feature or if you want to remove stale application nodes in the event your not using the automatic unregistration feature. Refresh token in each request By default the application adapter will only refresh the access token when it’s expired. However, you can also configure the adapter to refresh the token on every request. This may have a performance impact as your application will send more requests to the Keycloak server. To enable the feature edit the WEB-INF/keycloak.json file for your application and add: \"always-refresh-token\": true This may have a significant impact on performance. Only enable this feature if you can’t rely on backchannel messages to propagate logout and not before policies. Another thing to consider is that by default access tokens has a short expiration so even if logout is not propagated the token will expire within minutes of the logout. 2.2. JavaScript 适配器 Edit this sectionReport an issue Keycloak comes with a client-side JavaScript library that can be used to secure HTML5/JavaScript applications. The JavaScript adapter has built-in support for Cordova applications. The library can be retrieved directly from the Keycloak server at /auth/js/keycloak.js and is also distributed as a ZIP archive. A best practice is to load the JavaScript adapter directly from Keycloak Server as it will automatically be updated when you upgrade the server. If you copy the adapter to your web application instead, make sure you upgrade the adapter only after you have upgraded the server. One important thing to note about using client-side applications is that the client has to be a public client as there is no secure way to store client credentials in a client-side application. This makes it very important to make sure the redirect URIs you have configured for the client are correct and as specific as possible. To use the JavaScript adapter you must first create a client for your application in the Keycloak Administration Console. Make sure public is selected for Access Type. You also need to configure valid redirect URIs and valid web origins. Be as specific as possible as failing to do so may result in a security vulnerability. Once the client is created click on the Installation tab select Keycloak OIDC JSON for Format Option then click Download. The downloaded keycloak.json file should be hosted on your web server at the same location as your HTML pages. Alternatively, you can skip the configuration file and manually configure the adapter. The following example shows how to initialize the JavaScript adapter: var keycloak = Keycloak(); keycloak.init().success(function(authenticated) { alert(authenticated ? 'authenticated' : 'not authenticated'); }).error(function() { alert('failed to initialize'); }); If the keycloak.json file is in a different location you can specify it: var keycloak = Keycloak('http://localhost:8080/myapp/keycloak.json'); Alternatively, you can pass in a JavaScript object with the required configuration instead: var keycloak = Keycloak({ url: 'http://keycloak-server/auth', realm: 'myrealm', clientId: 'myapp' }); By default to authenticate you need to call the login function. However, there are two options available to make the adapter automatically authenticate. You can pass login-required or check-sso to the init function. login-requiredwill authenticate the client if the user is logged-in to Keycloak or display the login page if not. check-sso will only authenticate the client if the user is already logged-in, if the user is not logged-in the browser will be redirected back to the application and remain unauthenticated. To enable login-required set onLoad to login-required and pass to the init method: keycloak.init({ onLoad: 'login-required' }) After the user is authenticated the application can make requests to RESTful services secured by Keycloak by including the bearer token in the Authorization header. For example: var loadData = function () { document.getElementById('username').innerText = keycloak.subject; var url = 'http://localhost:8080/restful-service'; var req = new XMLHttpRequest(); req.open('GET', url, true); req.setRequestHeader('Accept', 'application/json'); req.setRequestHeader('Authorization', 'Bearer ' + keycloak.token); req.onreadystatechange = function () { if (req.readyState == 4) { if (req.status == 200) { alert('Success'); } else if (req.status == 403) { alert('Forbidden'); } } } req.send(); }; One thing to keep in mind is that the access token by default has a short life expiration so you may need to refresh the access token prior to sending the request. You can do this by the updateToken method. The updateToken method returns a promise object which makes it easy to invoke the service only if the token was successfully refreshed and for example display an error to the user if it wasn’t. For example: keycloak.updateToken(30).success(function() { loadData(); }).error(function() { alert('Failed to refresh token'); }); 2.2.1. Session Status iframe By default, the JavaScript adapter creates a hidden iframe that is used to detect if a Single-Sign Out has occurred. This does not require any network traffic, instead the status is retrieved by looking at a special status cookie. This feature can be disabled by setting checkLoginIframe: false in the options passed to the init method. You should not rely on looking at this cookie directly. Its format can change and it’s also associated with the URL of the Keycloak server, not your application. 2.2.2. Implicit and Hybrid Flow By default, the JavaScript adapter uses the Authorization Code flow. With this flow the Keycloak server returns an authorization code, not an authentication token, to the application. The JavaScript adapter exchanges the code for an access token and a refresh token after the browser is redirected back to the application. Keycloak also supports the Implicit flow where an access token is sent immediately after successful authentication with Keycloak. This may have better performance than standard flow, as there is no additional request to exchange the code for tokens, but it has implications when the access token expires. However, sending the access token in the URL fragment can be a security vulnerability. For example the token could be leaked through web server logs and or browser history. To enable implicit flow, you need to enable the Implicit Flow Enabled flag for the client in the Keycloak Administration Console. You also need to pass the parameter flow with value implicit to init method: keycloak.init({ flow: 'implicit' }) One thing to note is that only an access token is provided and there is no refresh token. This means that once the access token has expired the application has to do the redirect to the Keycloak again to obtain a new access token. Keycloak also supports the Hybrid flow. This requires the client to have both the Standard Flow Enabled and Implicit Flow Enabled flags enabled in the admin console. The Keycloak server will then send both the code and tokens to your application. The access token can be used immediately while the code can be exchanged for access and refresh tokens. Similar to the implicit flow, the hybrid flow is good for performance because the access token is available immediately. But, the token is still sent in the URL, and the security vulnerability mentioned earlier may still apply. One advantage in the Hybrid flow is that the refresh token is made available to the application. For the Hybrid flow, you need to pass the parameter flow with value hybrid to the init method: keycloak.init({ flow: 'hybrid' }) 2.2.3. Hybrid Apps with Cordova Keycloak support hybrid mobile apps developed with Apache Cordova. The Javascript adapter has two modes for this: cordova and cordova-native: The default is cordova, which the adapter will automatically select if no adapter type has been configured and window.cordova is present. When logging in, it will open an InApp Browser that lets the user interact with Keycloak and afterwards returns to the app by redirecting to http://localhost. Because of this, you must whitelist this URL as a valid redirect-uri in the client configuration section of the Administration Console. While this mode is easy to setup, it also has some disadvantages: The InApp-Browser is a browser embedded in the app and is not the phone’s default browser. Therefore it will have different settings and stored credentials will not be available. The InApp-Browser might also be slower, especially when rendering more complex themes. * There are security concerns to consider, before using this mode, such as that it is possible for the app to gain access to the credentials of the user, as it has full control of the browser rendering the login page, so do not allow its use in apps you do not trust. Use this example app to help you get started: https://github.com/keycloak/keycloak/tree/master/examples/cordova The alternative mode cordova-nativei takes a different approach. It opens the login page using the system’s browser. After the user has authenticated, the browser redirects back into the app using a special URL. From there, the Keycloak adapter can finish the login by reading the code or token from the URL. You can activate the native mode by passing the adapter type cordova-native to the init method: keycloak.init({ adapter: 'cordova-native' }) This adapter required two additional plugins: cordova-plugin-browsertab: allows the app to open webpages in the system’s browser cordova-plugin-deeplinks: allow the browser to redirect back to your app by special URLs The technical details for linking to an app differ on each plattform and special setup is needed. Please refer to the Android and iOS sections of the deeplinks plugin documentation for further instructions. There are different kinds of links for opening apps: custom schemes (i.e. myapp://login or android-app://com.example.myapp/https/example.com/login) and Universal Links (iOS)) / Deep Links (Android). While the former are easier to setup and tend to work more reliably, the later offer extra security as they are unique and only the owner of a domain can register them. Custom-URLs are deprecated on iOS. We recommend that you use universal links, combined with a fallback site with a custom-url link on it for best reliability. Furthermore, we recommend the following steps to improve compatibility with the Keycloak Adapter: Universal Links on iOS seem to work more reliably with response-mode set to query To prevent Android from opening a new instance of your app on redirect add the following snippet to config.xml: There is an example app that shows how to use the native-mode: https://github.com/keycloak/keycloak/tree/master/examples/cordova-native 2.2.4. Earlier Browsers The JavaScript adapter depends on Base64 (window.btoa and window.atob), HTML5 History API and optionally the Promise API. If you need to support browsers that do not have these available (for example, IE9) you need to add polyfillers. Example polyfill libraries: Base64 - https://github.com/davidchambers/Base64.js HTML5 History - https://github.com/devote/HTML5-History-API Promise - https://github.com/stefanpenner/es6-promise 2.2.5. JavaScript Adapter Reference Constructor new Keycloak(); new Keycloak('http://localhost/keycloak.json'); new Keycloak({ url: 'http://localhost/auth', realm: 'myrealm', clientId: 'myApp' }); Properties authenticated Is true if the user is authenticated, false otherwise. token The base64 encoded token that can be sent in the Authorization header in requests to services. tokenParsed The parsed token as a JavaScript object. subject The user id. idToken The base64 encoded ID token. idTokenParsed The parsed id token as a JavaScript object. realmAccess The realm roles associated with the token. resourceAccess The resource roles associated with the token. refreshToken The base64 encoded refresh token that can be used to retrieve a new token. refreshTokenParsed The parsed refresh token as a JavaScript object. timeSkew The estimated time difference between the browser time and the Keycloak server in seconds. This value is just an estimation, but is accurate enough when determining if a token is expired or not. responseMode Response mode passed in init (default value is fragment). flow Flow passed in init. adapter Allows you to override the way that redirects and other browser-related functions will be handled by the library. Available options:\"default\" - the library uses the browser api for redirects (this is the default)\"cordova\" - the library will try to use the InAppBrowser cordova plugin to load keycloak login/registration pages (this is used automatically when the library is working in a cordova ecosystem)\"cordova-native\" - the library tries to open the login and registration page using the phone’s system browser using the BrowserTabs cordova plugin. This requires extra setup for redirecting back to the app (see Hybrid Apps with Cordova).custom - allows you to implement a custom adapter (only for advanced use cases) responseType Response type sent to Keycloak with login requests. This is determined based on the flow value used during initialization, but can be overridden by setting this value. Methods init(options) Called to initialize the adapter. Options is an Object, where: onLoad - Specifies an action to do on load. Supported values are 'login-required' or 'check-sso'. token - Set an initial value for the token. refreshToken - Set an initial value for the refresh token. idToken - Set an initial value for the id token (only together with token or refreshToken). timeSkew - Set an initial value for skew between local time and Keycloak server in seconds (only together with token or refreshToken). checkLoginIframe - Set to enable/disable monitoring login state (default is true). checkLoginIframeInterval - Set the interval to check login state (default is 5 seconds). responseMode - Set the OpenID Connect response mode send to Keycloak server at login request. Valid values are query or fragment . Default value is fragment, which means that after successful authentication will Keycloak redirect to javascript application with OpenID Connect parameters added in URL fragment. This is generally safer and recommended over query. flow - Set the OpenID Connect flow. Valid values are standard, implicit or hybrid. promiseType - If set to native all methods returning a promise will return a native JavaScript promise. If not set will return Keycloak specific promise objects. Returns promise to set functions to be invoked on success or error. login(options) Redirects to login form on (options is an optional object with redirectUri and/or prompt fields). Options is an Object, where: redirectUri - Specifies the uri to redirect to after login. prompt - This parameter allows to slightly customize the login flow on the Keycloak server side. For example enforce displaying the login screen in case of value login. See Parameters Forwarding Section for the details and all the possible values of the prompt parameter. maxAge - Used just if user is already authenticated. Specifies maximum time since the authentication of user happened. If user is already authenticated for longer time than maxAge, the SSO is ignored and he will need to re-authenticate again. loginHint - Used to pre-fill the username/email field on the login form. scope - Used to forward the scope parameter to the Keycloak login endpoint. Use a space-delimited list of scopes. Those typically reference Client scopes defined on particular client. Note that the scope openid will be always be added to the list of scopes by the adapter. For example, if you enter the scope options address phone, then the request to Keycloak will contain the scope parameter scope=openid address phone. idpHint - Used to tell Keycloak to skip showing the login page and automatically redirect to the specified identity provider instead. More info in the Identity Provider documentation. action - If value is 'register' then user is redirected to registration page, otherwise to login page. locale - Sets the 'ui_locales' query param in compliance with section 3.1.2.1 of the OIDC 1.0 specification. kcLocale - Specifies the desired Keycloak locale for the UI. This differs from the locale param in that it tells the Keycloak server to set a cookie and update the user’s profile to a new preferred locale. cordovaOptions - Specifies the arguments that are passed to the Cordova in-app-browser (if applicable). Options hiddenand location are not affected by these arguments. All available options are defined at https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/. Example of use: { zoom: \"no\", hardwareback: \"yes\" }; createLoginUrl(options) Returns the URL to login form on (options is an optional object with redirectUri and/or prompt fields). Options is an Object, which supports same options like the function login . logout(options) Redirects to logout. Options is an Object, where: redirectUri - Specifies the uri to redirect to after logout. createLogoutUrl(options) Returns the URL to logout the user. Options is an Object, where: redirectUri - Specifies the uri to redirect to after logout. register(options) Redirects to registration form. Shortcut for login with option action = 'register' Options are same as for the login method but 'action' is set to 'register' createRegisterUrl(options) Returns the url to registration page. Shortcut for createLoginUrl with option action = 'register' Options are same as for the createLoginUrl method but 'action' is set to 'register' accountManagement() Redirects to the Account Management Console. createAccountUrl() Returns the URL to the Account Management Console. hasRealmRole(role) Returns true if the token has the given realm role. hasResourceRole(role, resource) Returns true if the token has the given role for the resource (resource is optional, if not specified clientId is used). loadUserProfile() Loads the users profile. Returns promise to set functions to be invoked if the profile was loaded successfully, or if the profile could not be loaded. For example: keycloak.loadUserProfile().success(function(profile) { alert(JSON.stringify(profile, null, \" \")); }).error(function() { alert('Failed to load user profile'); }); isTokenExpired(minValidity) Returns true if the token has less than minValidity seconds left before it expires (minValidity is optional, if not specified 0 is used). updateToken(minValidity) If the token expires within minValidity seconds (minValidity is optional, if not specified 5 is used) the token is refreshed. If the session status iframe is enabled, the session status is also checked. Returns promise to set functions that can be invoked if the token is still valid, or if the token is no longer valid. For example: keycloak.updateToken(5).success(function(refreshed) { if (refreshed) { alert('Token was successfully refreshed'); } else { alert('Token is still valid'); } }).error(function() { alert('Failed to refresh the token, or the session has expired'); }); clearToken() Clear authentication state, including tokens. This can be useful if application has detected the session was expired, for example if updating token fails. Invoking this results in onAuthLogout callback listener being invoked. Callback Events The adapter supports setting callback listeners for certain events. For example: keycloak.onAuthSuccess = function() { alert('authenticated'); } The available events are: onReady(authenticated) - Called when the adapter is initialized. onAuthSuccess - Called when a user is successfully authenticated. onAuthError - Called if there was an error during authentication. onAuthRefreshSuccess - Called when the token is refreshed. onAuthRefreshError - Called if there was an error while trying to refresh the token. onAuthLogout - Called if the user is logged out (will only be called if the session status iframe is enabled, or in Cordova mode). onTokenExpired - Called when the access token is expired. If a refresh token is available the token can be refreshed with updateToken, or in cases where it is not (that is, with implicit flow) you can redirect to login screen to obtain a new access token. 2.3. Node.js 适配器 Edit this sectionReport an issue Keycloak provides a Node.js adapter built on top of Connect to protect server-side JavaScript apps - the goal was to be flexible enough to integrate with frameworks like Express.js. The library can be downloaded directly from Keycloak organization and the source is available at GitHub. To use the Node.js adapter, first you must create a client for your application in the Keycloak Administration Console. The adapter supports public, confidential, and bearer-only access type. Which one to choose depends on the use-case scenario. Once the client is created click the Installation tab, select Keycloak OIDC JSON for Format Option, and then click Download. The downloaded keycloak.json file should be at the root folder of your project. 2.3.1. Installation Assuming you’ve already installed Node.js, create a folder for your application: mkdir myapp && cd myapp Use npm init command to create a package.json for your application. Now add the Keycloak connect adapter in the dependencies list: \"dependencies\": { \"keycloak-connect\": \"6.0.1\" } 2.3.2. Usage Instantiate a Keycloak class The Keycloak class provides a central point for configuration and integration with your application. The simplest creation involves no arguments. var session = require('express-session'); var Keycloak = require('keycloak-connect'); var memoryStore = new session.MemoryStore(); var keycloak = new Keycloak({ store: memoryStore }); By default, this will locate a file named keycloak.json alongside the main executable of your application to initialize keycloak-specific settings (public key, realm name, various URLs). The keycloak.json file is obtained from the Keycloak Admin Console. Instantiation with this method results in all of the reasonable defaults being used. As alternative, it’s also possible to provide a configuration object, rather than the keycloak.json file: let kcConfig = { clientId: 'myclient', bearerOnly: true, serverUrl: 'http://localhost:8080/auth', realm: 'myrealm', realmPublicKey: 'MIIBIjANB...' }; let keycloak = new Keycloak({ store: memoryStore }, kcConfig); Applications can also redirect users to their preferred identity provider by using: let keycloak = new Keycloak({ store: memoryStore, idpHint: myIdP }, kcConfig); Configuring a web session store If you want to use web sessions to manage server-side state for authentication, you need to initialize the Keycloak(…)with at least a store parameter, passing in the actual session store that express-session is using. var session = require('express-session'); var memoryStore = new session.MemoryStore(); var keycloak = new Keycloak({ store: memoryStore }); Passing a custom scope value By default, the scope value openid is passed as a query parameter to Keycloak’s login URL, but you can add an additional custom value: var keycloak = new Keycloak({ scope: 'offline_access' }); 2.3.3. Installing Middleware Once instantiated, install the middleware into your connect-capable app: var app = express(); app.use( keycloak.middleware() ); 2.3.4. Checking Authentication To check that a user is authenticated before accessing a resource, simply use keycloak.checkSso(). It will only authenticate if the user is already logged-in. If the user is not logged-in, the browser will be redirected back to the originally-requested URL and remain unauthenticated: app.get( '/check-sso', keycloak.checkSso(), checkSsoHandler ); 2.3.5. Protecting Resources Simple authentication To enforce that a user must be authenticated before accessing a resource, simply use a no-argument version of keycloak.protect(): app.get( '/complain', keycloak.protect(), complaintHandler ); Role-based authorization To secure a resource with an application role for the current app: app.get( '/special', keycloak.protect('special'), specialHandler ); To secure a resource with an application role for a different app: app.get( '/extra-special', keycloak.protect('other-app:special'), extraSpecialHandler ); To secure a resource with a realm role: app.get( '/admin', keycloak.protect( 'realm:admin' ), adminHandler ); Advanced authorization To secure resources based on parts of the URL itself, assuming a role exists for each section: function protectBySection(token, request) { return token.hasRole( request.params.section ); } app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler ); 2.3.6. Additional URLs Explicit user-triggered logout By default, the middleware catches calls to /logout to send the user through a Keycloak-centric logout workflow. This can be changed by specifying a logout configuration parameter to the middleware() call: app.use( keycloak.middleware( { logout: '/logoff' } )); Keycloak Admin Callbacks Also, the middleware supports callbacks from the Keycloak console to log out a single session or all sessions. By default, these type of admin callbacks occur relative to the root URL of / but can be changed by providing an admin parameter to the middleware() call: app.use( keycloak.middleware( { admin: '/callbacks' } ); 2.4. Keycloak 看门人 Edit this sectionReport an issue Keycloak provides a Go programming language adapter for use with OpenID Connect (OIDC) that supports both access tokens in a browser cookie or bearer tokens. This documentation details how to build and configure keycloak-gatekeeper followed by details of how to use each of its features. For further information, see the included help file which includes a full list of commands and switches. View the file by entering the following at the command line (modify the location to match where you install keycloak-gatekeeper): $ bin/keycloak-gatekeeper help 2.4.1. Building Prerequisites Golang must be installed. Make must be installed. Procedure Run make dep-install to install all needed dependencies. Run make test to run the included tests. Run make to build the project. You can instead use make static if you prefer to build a binary that includes within it all of the required dependencies. You can also build via docker container: make docker-build. A Docker image is available at https://hub.docker.com/r/keycloak/keycloak-gatekeeper/. 2.4.2. Configuration options Configuration can come from a yaml/json file or by using command line options. Here is a list of options. # is the url for retrieve the OpenID configuration - normally the /auth/realm/ discovery-url: https://keycloak.example.com/auth/realms/ # the client id for the 'client' application client-id: # the secret associated to the 'client' application client-secret: # the interface definition you wish the proxy to listen, all interfaces is specified as ':', unix sockets as unix://| listen: 127.0.0.1:3000 # whether to enable refresh tokens enable-refresh-tokens: true # the location of a certificate you wish the proxy to use for TLS support tls-cert: # the location of a private key for TLS tls-private-key: # the redirection url, essentially the site url, note: /oauth/callback is added at the end redirection-url: http://127.0.0.1:3000 # the encryption key used to encode the session state encryption-key: # the upstream endpoint which we should proxy request upstream-url: http://127.0.0.1:80 # additional scopes to add to add to the default (openid+email+profile) scopes: - vpn-user # a collection of resource i.e. urls that you wish to protect resources: - uri: /admin/test # the methods on this url that should be protected, if missing, we assuming all methods: - GET # a list of roles the user must have in order to access urls under the above # If all you want is authentication ONLY, simply remove the roles array - the user must be authenticated but # no roles are required roles: - openvpn:vpn-user - openvpn:prod-vpn - test - uri: /admin/* methods: - GET roles: - openvpn:vpn-user - openvpn:commons-prod-vpn Options issued at the command line have a higher priority and will override or merge with options referenced in a config file. Examples of each style are shown here. 2.4.3. Example usage and configuration Assuming you have some web service you wish protected by Keycloak: Create the client using the Keycloak GUI or CLI; the client protocol is 'openid-connect', access-type: confidential. Add a Valid Redirect URI of http://127.0.0.1:3000/oauth/callback. Grab the client id and client secret. Create the various roles under the client or existing clients for authorization purposes. Here is an example configuration file. client-id: client-secret: # require for access_type: confidential # Note the redirection-url is optional, it will default to the X-Forwarded-Proto / X-Forwarded-Host r the URL scheme and host not found discovery-url: https://keycloak.example.com/auth/realms/ enable-default-deny: true encryption_key: AgXa7xRcoClDEU0ZDSH4X0XhL5Qy2Z2j listen: 127.0.0.1:3000 redirection-url: http://127.0.0.1:3000 upstream-url: http://127.0.0.1:80 resources: - uri: /admin* methods: - GET roles: - client:test1 - client:test2 require-any-role: true groups: - admins - users - uri: /backend* roles: - client:test1 - uri: /public/* white-listed: true - uri: /favicon white-listed: true - uri: /css/* white-listed: true - uri: /img/* white-listed: true headers: myheader1: value_1 myheader2: value_2 Anything defined in a configuration file can also be configured using command line options, such as in this example. bin/keycloak-gatekeeper \\ --discovery-url=https://keycloak.example.com/auth/realms/ \\ --client-id= \\ --client-secret= \\ --listen=127.0.0.1:3000 \\ # unix sockets format unix://path --redirection-url=http://127.0.0.1:3000 \\ --enable-refresh-tokens=true \\ --encryption-key=AgXa7xRcoClDEU0ZDSH4X0XhL5Qy2Z2j \\ --upstream-url=http://127.0.0.1:80 \\ --enable-default-deny=true \\ --resources=\"uri=/admin*|roles=test1,test2\" \\ --resources=\"uri=/backend*|roles=test1\" \\ --resources=\"uri=/css/*|white-listed=true\" \\ --resources=\"uri=/img/*|white-listed=true\" \\ --resources=\"uri=/public/*|white-listed=true\" \\ --headers=\"myheader1=value1\" \\ --headers=\"myheader2=value2\" By default the roles defined on a resource perform a logical AND so all roles specified must be present in the claims, this behavior can be altered by the require-any-role option, however, so as long as one role is present the permission is granted. 2.4.4. OpenID Provider Communication By default the communication with the OpenID provider is direct. If you wish, you can specify a forwarding proxy server in your configuration file: openid-provider-proxy: http://proxy.example.com:8080 2.4.5. HTTP routing By default all requests will be proxyed on to the upstream, if you wish to ensure all requests are authentication you can use this: --resource=uri=/* # note, unless specified the method is assumed to be 'any|ANY' The HTTP routing rules follow the guidelines from chi. The ordering of the resources do not matter, the router will handle that for you. 2.4.6. Session-only cookies By default the access and refresh cookies are session-only and disposed of on browser close; you can disable this feature using the --enable-session-cookies option. 2.4.7. Forward-signing proxy Forward-signing provides a mechanism for authentication and authorization between services using tokens issued from the IdP. When operating in this mode the proxy will automatically acquire an access token (handling the refreshing or logins on your behalf) and tag outbound requests with a Authorization header. You can control which domains are tagged with the --forwarding-domains option. Note, this option use a contains comparison on domains. So, if you wanted to match all domains under *.svc.cluster.local you can use: --forwarding-domain=svc.cluster.local. At present the service performs a login using oauth client_credentials grant type, so your IdP service must support direct (username/password) logins. Example setup: You have collection of micro-services which are permitted to speak to one another; you have already set up the credentials, roles, and clients in Keycloak, providing granular role controls over issue tokens. - name: keycloak-gatekeeper image: quay.io/gambol99/keycloak-generic-adapter:latest args: - --enable-forwarding=true - --forwarding-username=projecta - --forwarding-password=some_password - --forwarding-domains=projecta.svc.cluster.local - --forwarding-domains=projectb.svc.cluster.local - --tls-ca-certificate=/etc/secrets/ca.pem - --tls-ca-key=/etc/secrets/ca-key.pem # Note: if you don't specify any forwarding domains, all domains will be signed; Also the code checks is the # domain 'contains' the value (it's not a regex) so if you wanted to sign all requests to svc.cluster.local, just use # svc.cluster.local volumeMounts: - name: keycloak-socket mountPoint: /var/run/keycloak - name: projecta image: some_images # test the forward proxy $ curl -k --proxy http://127.0.0.1:3000 https://test.projesta.svc.cluster.local On the receiver side you could set up the Keycloak Gatekeeper (--no=redirects=true) and permit this to verify and handle admission for you. Alternatively, the access token can found as a bearer token in the request. 2.4.8. Forwarding signed HTTPS connections Handling HTTPS requires a man-in-the-middle sort of TLS connection. By default, if no --tls-ca-certificate and --tls-ca-key are provided the proxy will use the default certificate. If you wish to verify the trust, you’ll need to generate a CA, for example. $ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ca.key -out ca.pem $ bin/keycloak-gatekeeper \\ --enable-forwarding \\ --forwarding-username=USERNAME \\ --forwarding-password=PASSWORD \\ --client-id=CLIENT_ID \\ --client-secret=SECRET \\ --discovery-url=https://keycloak.example.com/auth/realms/test \\ --tls-ca-certificate=ca.pem \\ --tls-ca-key=ca-key.pem 2.4.9. HTTPS redirect The proxy supports an HTTP listener, so the only real requirement here is to perform an HTTP → HTTPS redirect. You can enable the option like this: --listen-http=127.0.0.1:80 --enable-security-filter=true # is required for the https redirect --enable-https-redirection 2.4.10. Let’s Encrypt configuration Here is an example of the required configuration for Let’s Encrypt support: listen: 0.0.0.0:443 enable-https-redirection: true enable-security-filter: true use-letsencrypt: true letsencrypt-cache-dir: ./cache/ redirection-url: https://domain.tld:443/ hostnames: - domain.tld Listening on port 443 is mandatory. 2.4.11. Access token encryption By default, the session token is placed into a cookie in plaintext. If you prefer to encrypt the session cookie, use the --enable-encrypted-token and --encryption-key options. Note that the access token forwarded in the X-Auth-Token header to upstream is unaffected. 2.4.12. Upstream headers On protected resources, the upstream endpoint will receive a number of headers added by the proxy, along with custom claims, like this: # add the header to the upstream endpoint id := user.(*userContext) cx.Request().Header.Set(\"X-Auth-Email\", id.email) cx.Request().Header.Set(\"X-Auth-ExpiresIn\", id.expiresAt.String()) cx.Request().Header.Set(\"X-Auth-Groups\", strings.Join(id.groups, \",\")) cx.Request().Header.Set(\"X-Auth-Roles\", strings.Join(id.roles, \",\")) cx.Request().Header.Set(\"X-Auth-Subject\", id.id) cx.Request().Header.Set(\"X-Auth-Token\", id.token.Encode()) cx.Request().Header.Set(\"X-Auth-Userid\", id.name) cx.Request().Header.Set(\"X-Auth-Username\", id.name) // step: add the authorization header if requested if r.config.EnableAuthorizationHeader { cx.Request().Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", id.token.Encode())) } To control the Authorization header use the enable-authorization-header yaml configuration or the --enable-authorization-header command line option. By default this option is set to true. 2.4.13. Custom claim headers You can inject additional claims from the access token into the authorization headers with the --add-claims option. For example, a token from a Keycloak provider might include the following claims: \"resource_access\": {}, \"name\": \"Beloved User\", \"preferred_username\": \"beloved.user\", \"given_name\": \"Beloved\", \"family_name\": \"User\", \"email\": \"beloved@example.com\" In order to request you receive the given_name, family_name and name in the authentication header we would add --add-claims=given_name and --add-claims=family_name and so on, or we can do it in the configuration file, like this: add-claims: - given_name - family_name - name This would add the additional headers to the authenticated request along with standard ones. X-Auth-Family-Name: User X-Auth-Given-Name: Beloved X-Auth-Name: Beloved User 2.4.14. Custom headers You can inject custom headers using the --headers=\"name=value\" option or the configuration file: headers: name: value 2.4.15. Encryption key In order to remain stateless and not have to rely on a central cache to persist the refresh_tokens, the refresh token is encrypted and added as a cookie using crypto/aes. The key must be the same if you are running behind a load balancer. The key length should be either 16 or 32 bytes, depending or whether you want AES-128 or AES-256. 2.4.16. Claim matching The proxy supports adding a variable list of claim matches against the presented tokens for additional access control. You can match the 'iss' or 'aud' to the token or custom attributes; each of the matches are regex’s. For example, --match-claims 'aud=sso.*' or --claim iss=https://.*' or via the configuration file, like this: match-claims: aud: openvpn iss: https://keycloak.example.com/auth/realms/commons or via the CLI, like this: --match-claims=auth=openvpn --match-claims=iss=http://keycloak.example.com/realms/commons You can limit the email domain permitted; for example if you want to limit to only users on the example.com domain: match-claims: email: ^.*@example.com$ The adapter supports matching on multi-value strings claims. The match will succeed if one of the values matches, for example: match-claims: perms: perm1 will successfully match { \"iss\": \"https://sso.example.com\", \"sub\": \"\", \"perms\": [\"perm1\", \"perm2\"] } 2.4.17. Group claims You can match on the group claims within a token via the groups parameter available within the resource. While roles are implicitly required, such as roles=admin,user where the user MUST have roles 'admin' AND 'user', groups are applied with an OR operation, so groups=users,testers requires that the user MUST be within either 'users' OR 'testers'. The claim name is hard-coded to groups, so a JWT token would look like this: { \"iss\": \"https://sso.example.com\", \"sub\": \"\", \"aud\": \"test\", \"exp\": 1515269245, \"iat\": 1515182845, \"email\": \"beloved@example.com\", \"groups\": [ \"group_one\", \"group_two\" ], \"name\": \"Beloved\" } 2.4.18. Custom pages By default, Keycloak Gatekeeper will immediately redirect you for authentication and hand back a 403 for access denied. Most users will probably want to present the user with a more friendly sign-in and access denied page. You can pass the command line options (or via config file) paths to the files with --signin-page=PATH. The sign-in page will have a 'redirect' variable passed into the scope and holding the oauth redirection url. If you wish to pass additional variables into the templates, such as title, sitename and so on, you can use the --tags key=pair option, like this: --tags title=\"This is my site\" and the variable would be accessible from ``. Sign-in 2.4.19. White-listed URL’s Depending on how the application URL’s are laid out, you might want protect the root / url but have exceptions on a list of paths, for example /health. While this is best solved by adjusting the paths, you can add exceptions to the protected resources, like this: resources: - uri: /some_white_listed_url white-listed: true - uri: /* methods: - GET roles: - : - : Or on the command line --resources \"uri=/some_white_listed_url|white-listed=true\" --resources \"uri=/*\" # requires authentication on the rest --resources \"uri=/admin*|roles=admin,superuser|methods=POST,DELETE\" 2.4.20. Mutual TLS The proxy support enforcing mutual TLS for the clients by adding the --tls-ca-certificate command line option or configuration file option. All clients connecting must present a certificate which was signed by the CA being used. 2.4.21. Certificate rotation The proxy will automatically rotate the server certificates if the files change on disk. Note, no down time will occur as the change is made inline. Clients who connected prior to the certificate rotation will be unaffected and will continue as normal with all new connections presented with the new certificate. 2.4.22. Refresh tokens If a request for an access token contains a refresh token and --enable-refresh-tokens is set to true, the proxy will automatically refresh the access token for you. The tokens themselves are kept either as an encrypted (--encryption-key=KEY) cookie (cookie name: kc-state). or a store (still requires encryption key). At present the only store options supported are Redis and Boltdb. To enable a local boltdb store use --store-url boltdb:///PATH or using a relative path boltdb://PATH. To enable a local redis store use redis://[USER:PASSWORD@]HOST:PORT. In both cases the refresh token is encrypted before being placed into the store. 2.4.23. Logout endpoint A /oauth/logout?redirect=url is provided as a helper to log users out. In addition to dropping any session cookies, we also attempt to revoke access via revocation url (config revocation-url or --revocation-url) with the provider. For Keycloak, the url for this would be https://keycloak.example.com/auth/realms/REALM_NAME/protocol/openid-connect/logout. If the url is not specified we will attempt to grab the url from the OpenID discovery response. 2.4.24. Cross-origin resource sharing (CORS) You can add a CORS header via the --cors-[method] with these configuration options. Access-Control-Allow-Origin Access-Control-Allow-Methods Access-Control-Allow-Headers Access-Control-Expose-Headers Access-Control-Allow-Credentials Access-Control-Max-Age You can add using the config file: cors-origins: - '*' cors-methods: - GET - POST or via the command line: --cors-origins [--cors-origins option] a set of origins to add to the CORS access control (Access-Control-Allow-Origin) --cors-methods [--cors-methods option] the method permitted in the access control (Access-Control-Allow-Methods) --cors-headers [--cors-headers option] a set of headers to add to the CORS access control (Access-Control-Allow-Headers) --cors-exposes-headers [--cors-exposes-headers option] set the expose cors headers access control (Access-Control-Expose-Headers) 2.4.25. Upstream URL You can control the upstream endpoint via the --upstream-url option. Both HTTP and HTTPS are supported with TLS verification and keep-alive support configured via the --skip-upstream-tls-verify / --upstream-keepalives option. Note, the proxy can also upstream via a UNIX socket, --upstream-url unix://path/to/the/file.sock. 2.4.26. Endpoints /oauth/authorize is authentication endpoint which will generate the OpenID redirect to the provider /oauth/callback is provider OpenID callback endpoint /oauth/expired is a helper endpoint to check if a access token has expired, 200 for ok and, 401 for no token and 401 for expired /oauth/health is the health checking endpoint for the proxy, you can also grab version from headers /oauth/login provides a relay endpoint to login via grant_type=password, for example, POST /oauth/login form values are username=USERNAME&password=PASSWORD (must be enabled) /oauth/logout provides a convenient endpoint to log the user out, it will always attempt to perform a back channel log out of offline tokens /oauth/token is a helper endpoint which will display the current access token for you /oauth/metrics is a Prometheus metrics handler 2.4.27. Metrics Assuming --enable-metrics has been set, a Prometheus endpoint can be found on /oauth/metrics; at present the only metric being exposed is a counter per HTTP code. 2.4.28. Limitations Keep in mind browser cookie limits if you use access or refresh tokens in the browser cookie. Keycloak-generic-adapter divides the cookie automatically if your cookie is longer than 4093 bytes. Real size of the cookie depends on the content of the issued access token. Also, encryption might add additional bytes to the cookie size. If you have large cookies (>200 KB), you might reach browser cookie limits. All cookies are part of the header request, so you might find a problem with the max headers size limits in your infrastructure (some load balancers have very low this value, such as 8 KB). Be sure that all network devices have sufficient header size limits. Otherwise, your users won’t be able to obtain an access token. 2.4.29. Known Issues There is a known issue with the Keycloak server 4.7.0.Final in which Gatekeeper is unable to find the client_id in the audclaim. This is due to the fact the client_id is not in the audience anymore. The workaround is to add the \"Audience\" protocol mapper to the client with the audience pointed to the client_id. For more information, see KEYCLOAK-8954. ==== mod_auth_openidc Apache HTTPD Module Edit this sectionReport an issue The mod_auth_openidc is an Apache HTTP plugin for OpenID Connect. If your language/environment supports using Apache HTTPD as a proxy, then you can use mod_auth_openidc to secure your web application with OpenID Connect. Configuration of this module is beyond the scope of this document. Please see the mod_auth_openidc GitHub repo for more details on configuration. To configure mod_auth_openidc you’ll need The client_id. The client_secret. The redirect_uri to your application. The Keycloak openid-configuration url mod_auth_openidc specific Apache HTTPD module config. An example configuration would look like the following. LoadModule auth_openidc_module modules/mod_auth_openidc.so ServerName ${HOSTIP} ServerAdmin webmaster@localhost DocumentRoot /var/www/html #this is required by mod_auth_openidc OIDCCryptoPassphrase a-random-secret-used-by-apache-oidc-and-balancer OIDCProviderMetadataURL ${KC_ADDR}/auth/realms/${KC_REALM}/.well-known/openid-configuration OIDCClientID ${CLIENT_ID} OIDCClientSecret ${CLIENT_SECRET} OIDCRedirectURI http://${HOSTIP}/${CLIENT_APP_NAME}/redirect_uri # maps the prefered_username claim to the REMOTE_USER environment variable OIDCRemoteUserClaim preferred_username AuthType openid-connect Require valid-user Further information on how to configure mod_auth_openidc can be found on the mod_auth_openidc project page. 2.5. 其他OpenID连接库 Edit this sectionReport an issue Keycloak can be secured by supplied adapters that are usually easier to use and provide better integration with Keycloak. However, if an adapter is not available for your programming language, framework, or platform you might opt to use a generic OpenID Connect Resource Provider (RP) library instead. This chapter describes details specific to Keycloak and does not contain specific protocol details. For more information see the OpenID Connect specifications and OAuth2 specification. 2.5.1. Endpoints The most important endpoint to understand is the well-known configuration endpoint. It lists endpoints and other configuration options relevant to the OpenID Connect implementation in Keycloak. The endpoint is: /realms/{realm-name}/.well-known/openid-configuration To obtain the full URL, add the base URL for Keycloak and replace {realm-name} with the name of your realm. For example: http://localhost:8080/auth/realms/master/.well-known/openid-configuration Some RP libraries retrieve all required endpoints from this endpoint, but for others you might need to list the endpoints individually. Authorization Endpoint /realms/{realm-name}/protocol/openid-connect/auth The authorization endpoint performs authentication of the end-user. This is done by redirecting the user agent to this endpoint. For more details see the Authorization Endpoint section in the OpenID Connect specification. Token Endpoint /realms/{realm-name}/protocol/openid-connect/token The token endpoint is used to obtain tokens. Tokens can either be obtained by exchanging an authorization code or by supplying credentials directly depending on what flow is used. The token endpoint is also used to obtain new access tokens when they expire. For more details see the Token Endpoint section in the OpenID Connect specification. Userinfo Endpoint /realms/{realm-name}/protocol/openid-connect/userinfo The userinfo endpoint returns standard claims about the authenticated user, and is protected by a bearer token. For more details see the Userinfo Endpoint section in the OpenID Connect specification. Logout Endpoint /realms/{realm-name}/protocol/openid-connect/logout The logout endpoint logs out the authenticated user. The user agent can be redirected to the endpoint, in which case the active user session is logged out. Afterward the user agent is redirected back to the application. The endpoint can also be invoked directly by the application. To invoke this endpoint directly the refresh token needs to be included as well as the credentials required to authenticate the client. Certificate Endpoint /realms/{realm-name}/protocol/openid-connect/certs The certificate endpoint returns the public keys enabled by the realm, encoded as a JSON Web Key (JWK). Depending on the realm settings there can be one or more keys enabled for verifying tokens. For more information see the Server Administration Guide and the JSON Web Key specification. Introspection Endpoint /realms/{realm-name}/protocol/openid-connect/token/introspect The introspection endpoint is used to retrieve the active state of a token. In other words, you can use it to validate an access or refresh token. It can only be invoked by confidential clients. For more details on how to invoke on this endpoint, see OAuth 2.0 Token Introspection specification. Dynamic Client Registration Endpoint /realms/{realm-name}/clients-registrations/openid-connect The dynamic client registration endpoint is used to dynamically register clients. For more details see the Client Registration chapter and the OpenID Connect Dynamic Client Registration specification. 2.5.2. Validating Access Tokens If you need to manually validate access tokens issued by Keycloak you can invoke the Introspection Endpoint. The downside to this approach is that you have to make a network invocation to the Keycloak server. This can be slow and possibily overload the server if you have too many validation requests going on at the same time. Keycloak issued access tokens are JSON Web Tokens (JWT) digitally signed and encoded using JSON Web Signature (JWS). Because they are encoded in this way, this allows you to locally validate access tokens using the public key of the issuing realm. You can either hard code the realm’s public key in your validation code, or lookup and cache the public key using the certificate endpoint with the Key ID (KID) embedded within the JWS. Depending what language you code in, there are a multitude of third party libraries out there that can help you with JWS validation. 2.5.3. Flows Authorization Code The Authorization Code flow redirects the user agent to Keycloak. Once the user has successfully authenticated with Keycloak an Authorization Code is created and the user agent is redirected back to the application. The application then uses the authorization code along with its credentials to obtain an Access Token, Refresh Token and ID Token from Keycloak. The flow is targeted towards web applications, but is also recommended for native applications, including mobile applications, where it is possible to embed a user agent. For more details refer to the Authorization Code Flow in the OpenID Connect specification. Implicit The Implicit flow redirects works similarly to the Authorization Code flow, but instead of returning an Authorization Code the Access Token and ID Token is returned. This reduces the need for the extra invocation to exchange the Authorization Code for an Access Token. However, it does not include a Refresh Token. This results in the need to either permit Access Tokens with a long expiration, which is problematic as it’s very hard to invalidate these. Or requires a new redirect to obtain new Access Token once the initial Access Token has expired. The Implicit flow is useful if the application only wants to authenticate the user and deals with logout itself. There’s also a Hybrid flow where both the Access Token and an Authorization Code is returned. One thing to note is that both the Implicit flow and Hybrid flow has potential security risks as the Access Token may be leaked through web server logs and browser history. This is somewhat mitigated by using short expiration for Access Tokens. For more details refer to the Implicit Flow in the OpenID Connect specification. Resource Owner Password Credentials Resource Owner Password Credentials, referred to as Direct Grant in Keycloak, allows exchanging user credentials for tokens. It’s not recommended to use this flow unless you absolutely need to. Examples where this could be useful are legacy applications and command-line interfaces. There are a number of limitations of using this flow, including: User credentials are exposed to the application Applications need login pages Application needs to be aware of the authentication scheme Changes to authentication flow requires changes to application No support for identity brokering or social login Flows are not supported (user self-registration, required actions, etc.) For a client to be permitted to use the Resource Owner Password Credentials grant the client has to have the Direct Access Grants Enabled option enabled. This flow is not included in OpenID Connect, but is a part of the OAuth 2.0 specification. For more details refer to the Resource Owner Password Credentials Grant chapter in the OAuth 2.0 specification. Example using CURL The following example shows how to obtain an access token for a user in the realm master with username user and password password. The example is using the confidential client myclient: curl \\ -d \"client_id=myclient\" \\ -d \"client_secret=40cc097b-2a57-4c17-b36a-8fdf3fc2d578\" \\ -d \"username=user\" \\ -d \"password=password\" \\ -d \"grant_type=password\" \\ \"http://localhost:8080/auth/realms/master/protocol/openid-connect/token\" Client Credentials Client Credentials is used when clients (applications and services) wants to obtain access on behalf of themselves rather than on behalf of a user. This can for example be useful for background services that applies changes to the system in general rather than for a specific user. Keycloak provides support for clients to authenticate either with a secret or with public/private keys. This flow is not included in OpenID Connect, but is a part of the OAuth 2.0 specification. For more details refer to the Client Credentials Grant chapter in the OAuth 2.0 specification. 2.5.4. Redirect URIs When using the redirect based flows it’s important to use valid redirect uris for your clients. The redirect uris should be as specific as possible. This especially applies to client-side (public clients) applications. Failing to do so could result in: Open redirects - this can allow attackers to create spoof links that looks like they are coming from your domain Unauthorized entry - when users are already authenticated with Keycloak an attacker can use a public client where redirect uris have not be configured correctly to gain access by redirecting the user without the users knowledge In production for web applications always use https for all redirect URIs. Do not allow redirects to http. There’s also a few special redirect URIs: http://localhost This redirect URI is useful for native applications and allows the native application to create a web server on a random port that can be used to obtain the authorization code. This redirect uri allows any port. urn:ietf:wg:oauth:2.0:oob If its not possible to start a web server in the client (or a browser is not available) it is possible to use the special urn:ietf:wg:oauth:2.0:oob redirect uri. When this redirect uri is used Keycloak displays a page with the code in the title and in a box on the page. The application can either detect that the browser title has changed, or the user can copy/paste the code manually to the application. With this redirect uri it is also possible for a user to use a different device to obtain a code to paste back to the application. 3. SAML Edit this sectionReport an issue This section describes how you can secure applications and services with SAML using either Keycloak client adapters or generic SAML provider libraries. 3.1. Java 适配器 Edit this sectionReport an issue Keycloak comes with a range of different adapters for Java application. Selecting the correct adapter depends on the target platform. 3.1.1. General Adapter Config Edit this sectionReport an issue Each SAML client adapter supported by Keycloak can be configured by a simple XML text file. This is what one might look like: Some of these configuration switches may be adapter specific and some are common across all adapters. For Java adapters you can use ${…} enclosure as System property replacement. For example ${jboss.server.config.dir}. SP Element Edit this sectionReport an issue Here is the explanation of the SP element attributes: ... entityID This is the identifier for this client. The IdP needs this value to determine who the client is that is communicating with it. This setting is REQUIRED. sslPolicy This is the SSL policy the adapter will enforce. Valid values are: ALL, EXTERNAL, and NONE. For ALL, all requests must come in via HTTPS. For EXTERNAL, only non-private IP addresses must come over the wire via HTTPS. For NONE, no requests are required to come over via HTTPS. This setting is OPTIONAL. Default value is EXTERNAL. nameIDPolicyFormat SAML clients can request a specific NameID Subject format. Fill in this value if you want a specific format. It must be a standard SAML format identifier: urn:oasis:names:tc:SAML:2.0:nameid-format:transient. This setting is OPTIONAL. By default, no special format is requested. forceAuthentication SAML clients can request that a user is re-authenticated even if they are already logged in at the IdP. Set this to true to enable. This setting is OPTIONAL. Default value is false. isPassive SAML clients can request that a user is never asked to authenticate even if they are not logged in at the IdP. Set this to true if you want this. Do not use together with forceAuthentication as they are opposite. This setting is OPTIONAL. Default value is false. turnOffChangeSessionIdOnLogin The session ID is changed by default on a successful login on some platforms to plug a security attack vector. Change this to true to disable this. It is recommended you do not turn it off. Default value is false. autodetectBearerOnly This should be set to true if your application serves both a web application and web services (e.g. SOAP or REST). It allows you to redirect unauthenticated users of the web application to the Keycloak login page, but send an HTTP 401 status code to unauthenticated SOAP or REST clients instead as they would not understand a redirect to the login page. Keycloak auto-detects SOAP or REST clients based on typical headers like X-Requested-With, SOAPAction or Accept. The default value is false. logoutPage This sets the page to display after logout. If the page is a full URL, such as http://web.example.com/logout.html, the user is redirected after logout to that page using the HTTP 302 status code. If a link without scheme part is specified, such as /logout.jsp, the page is displayed after logout, regardless of whether it lies in a protected area according to security-constraint declarations in web.xml, and the page is resolved relative to the deployment context root. Service Provider Keys and Key Elements Edit this sectionReport an issue If the IdP requires that the client application (or SP) sign all of its requests and/or if the IdP will encrypt assertions, you must define the keys used to do this. For client-signed documents you must define both the private and public key or certificate that is used to sign documents. For encryption, you only have to define the private key that is used to decrypt it. There are two ways to describe your keys. They can be stored within a Java KeyStore or you can copy/paste the keys directly within keycloak-saml.xml in the PEM format. ... The Key element has two optional attributes signing and encryption. When set to true these tell the adapter what the key will be used for. If both attributes are set to true, then the key will be used for both signing documents and decrypting encrypted assertions. You must set at least one of these attributes to true. KeyStore element Edit this sectionReport an issue Within the Key element you can load your keys and certificates from a Java Keystore. This is declared within a KeyStore element. Here are the XML config attributes that are defined with the KeyStore element. file File path to the key store. This option is OPTIONAL. The file or resource attribute must be set. resource WAR resource path to the KeyStore. This is a path used in method call to ServletContext.getResourceAsStream(). This option is OPTIONAL. The file or resource attribute must be set. password The password of the KeyStore. This option is REQUIRED. If you are defining keys that the SP will use to sign document, you must also specify references to your private keys and certificates within the Java KeyStore. The PrivateKey and Certificate elements in the above example define an aliasthat points to the key or cert within the keystore. Keystores require an additional password to access private keys. In the PrivateKey element you must define this password within a password attribute. Key PEMS Edit this sectionReport an issue Within the Key element you declare your keys and certificates directly using the sub elementsPrivateKeyPem, PublicKeyPem, and CertificatePem. The values contained in these elements must conform to the PEM key format. You usually use this option if you are generating keys using openssl or similar command line tool. 2341251234AB31234==231BB998311222423522334 211111341251234AB31234==231BB998311222423522334 SP PrincipalNameMapping element Edit this sectionReport an issue This element is optional. When creating a Java Principal object that you obtain from methods such as HttpServletRequest.getUserPrincipal(), you can define what name is returned by the Principal.getName() method. The policy attribute defines the policy used to populate this value. The possible values for this attribute are: FROM_NAME_ID This policy just uses whatever the SAML subject value is. This is the default setting FROM_ATTRIBUTE This will pull the value from one of the attributes declared in the SAML assertion received from the server. You’ll need to specify the name of the SAML assertion attribute to use within the attribute XML attribute. RoleIdentifiers Element Edit this sectionReport an issue The RoleIdentifiers element defines what SAML attributes within the assertion received from the user should be used as role identifiers within the Java EE Security Context for the user. By default Role attribute values are converted to Java EE roles. Some IdPs send roles using a member or memberOfattribute assertion. You can define one or more Attribute elements to specify which SAML attributes must be converted into roles. IDP Element Edit this sectionReport an issue Everything in the IDP element describes the settings for the identity provider (authentication server) the SP is communicating with. ... Here are the attribute config options you can specify within the IDP element declaration. entityID This is the issuer ID of the IDP. This setting is REQUIRED. signaturesRequired If set to true, the client adapter will sign every document it sends to the IDP. Also, the client will expect that the IDP will be signing any documents sent to it. This switch sets the default for all request and response types, but you will see later that you have some fine grain control over this. This setting is OPTIONAL and will default to false. signatureAlgorithm This is the signature algorithm that the IDP expects signed documents to use. Allowed values are: RSA_SHA1, RSA_SHA256, RSA_SHA512, and DSA_SHA1. This setting is OPTIONAL and defaults to RSA_SHA256. signatureCanonicalizationMethod This is the signature canonicalization method that the IDP expects signed documents to use. This setting is OPTIONAL. The default value is http://www.w3.org/2001/10/xml-exc-c14n# and should be good for most IDPs. metadataUrl The URL used to retrieve the IDP metadata, currently this is only used to pick up signing and encryption keys periodically which allow cycling of these keys on the IDP without manual changes on the SP side. IDP SingleSignOnService sub element Edit this sectionReport an issue The SingleSignOnService sub element defines the login SAML endpoint of the IDP. The client adapter will send requests to the IDP formatted via the settings within this element when it wants to login. Here are the config attributes you can define on this element: signRequest Should the client sign authn requests? This setting is OPTIONAL. Defaults to whatever the IDP signaturesRequiredelement value is. validateResponseSignature Should the client expect the IDP to sign the assertion response document sent back from an auhtn request? This setting OPTIONAL. Defaults to whatever the IDP signaturesRequired element value is. requestBinding This is the SAML binding type used for communicating with the IDP. This setting is OPTIONAL. The default value is POST, but you can set it to REDIRECT as well. responseBinding SAML allows the client to request what binding type it wants authn responses to use. The values of this can be POST or REDIRECT. This setting is OPTIONAL. The default is that the client will not request a specific binding type for responses. assertionConsumerServiceUrl URL of the assertion consumer service (ACS) where the IDP login service should send responses to. This setting is OPTIONAL. By default it is unset, relying on the configuration in the IdP. When set, it must end in /saml, e.g. http://sp.domain.com/my/endpoint/for/saml. The value of this property is sent in AssertionConsumerServiceURLattribute of SAML AuthnRequest message. This property is typically accompanied by the responseBinding attribute. bindingUrl This is the URL for the IDP login service that the client will send requests to. This setting is REQUIRED. IDP SingleLogoutService sub element Edit this sectionReport an issue The SingleLogoutService sub element defines the logout SAML endpoint of the IDP. The client adapter will send requests to the IDP formatted via the settings within this element when it wants to logout. signRequest Should the client sign logout requests it makes to the IDP? This setting is OPTIONAL. Defaults to whatever the IDP signaturesRequired element value is. signResponse Should the client sign logout responses it sends to the IDP requests? This setting is OPTIONAL. Defaults to whatever the IDP signaturesRequired element value is. validateRequestSignature Should the client expect signed logout request documents from the IDP? This setting is OPTIONAL. Defaults to whatever the IDP signaturesRequired element value is. validateResponseSignature Should the client expect signed logout response documents from the IDP? This setting is OPTIONAL. Defaults to whatever the IDP signaturesRequired element value is. requestBinding This is the SAML binding type used for communicating SAML requests to the IDP. This setting is OPTIONAL. The default value is POST, but you can set it to REDIRECT as well. responseBinding This is the SAML binding type used for communicating SAML responses to the IDP. The values of this can be POST or REDIRECT. This setting is OPTIONAL. The default value is POST, but you can set it to REDIRECT as well. postBindingUrl This is the URL for the IDP’s logout service when using the POST binding. This setting is REQUIRED if using the POSTbinding. redirectBindingUrl This is the URL for the IDP’s logout service when using the REDIRECT binding. This setting is REQUIRED if using the REDIRECT binding. IDP Keys sub element Edit this sectionReport an issue The Keys sub element of IDP is only used to define the certificate or public key to use to verify documents signed by the IDP. It is defined in the same way as the SP’s Keys element. But again, you only have to define one certificate or public key reference. Note that, if both IDP and SP are realized by Keycloak server and adapter, respectively, there is no need to specify the keys for signature validation, see below. It is possible to configure SP to obtain public keys for IDP signature validation from published certificates automatically, provided both SP and IDP are implemented by Keycloak. This is done by removing all declarations of signature validation keys in Keys sub element. If the Keys sub element would then remain empty, it can be omitted completely. The keys are then automatically obtained by SP from SAML descriptor, location of which is derived from SAML endpoint URL specified in the IDP SingleSignOnService sub element. Settings of the HTTP client that is used for SAML descriptor retrieval usually needs no additional configuration, however it can be configured in the IDP HttpClient sub element. It is also possible to specify multiple keys for signature verification. This is done by declaring multiple Key elements within Keys sub element that have signing attribute set to true. This is useful for example in situation when the IDP signing keys are rotated: There is usually a transition period when new SAML protocol messages and assertions are signed with the new key but those signed by previous key should still be accepted. It is not possible to configure Keycloak to both obtain the keys for signature verification automatically and define additional static signature verification keys. ... IDP HttpClient sub element Edit this sectionReport an issue The HttpClient optional sub element defines the properties of HTTP client used for automatic obtaining of certificates containing public keys for IDP signature verification via SAML descriptor of the IDP when enabled. connectionPoolSize Adapters will make separate HTTP invocations to the Keycloak server to turn an access code into an access token. This config option defines how many connections to the Keycloak server should be pooled. This is OPTIONAL. The default value is 10. disableTrustManager If the Keycloak server requires HTTPS and this config option is set to true you do not have to specify a truststore. This setting should only be used during development and never in production as it will disable verification of SSL certificates. This is OPTIONAL. The default value is false. allowAnyHostname If the Keycloak server requires HTTPS and this config option is set to true the Keycloak server’s certificate is validated via the truststore, but host name validation is not done. This setting should only be used during development and never in production as it will partly disable verification of SSL certificates. This seting may be useful in test environments. This is OPTIONAL. The default value is false. truststore The value is the file path to a truststore file. If you prefix the path with classpath:, then the truststore will be obtained from the deployment’s classpath instead. Used for outgoing HTTPS communications to the Keycloak server. Client making HTTPS requests need a way to verify the host of the server they are talking to. This is what the trustore does. The keystore contains one or more trusted host certificates or certificate authorities. You can create this truststore by extracting the public certificate of the Keycloak server’s SSL keystore. This is REQUIRED unless disableTrustManager is true. truststorePassword Password for the truststore. This is REQUIRED if truststore is set and the truststore requires a password. clientKeystore This is the file path to a keystore file. This keystore contains client certificate for two-way SSL when the adapter makes HTTPS requests to the Keycloak server. This is OPTIONAL. clientKeystorePassword Password for the client keystore and for the client’s key. This is REQUIRED if clientKeystore is set. proxyUrl URL to HTTP proxy to use for HTTP connections. This is OPTIONAL. Edit this sectionReport an issue 3.1.2. JBoss EAP/WildFly Adapter To be able to secure WAR apps deployed on JBoss EAP or WildFly, you must install and configure the Keycloak SAML Adapter Subsystem. You then provide a keycloak config, /WEB-INF/keycloak-saml.xml file in your WAR and change the auth-method to KEYCLOAK-SAML within web.xml. Both methods are described in this section. Adapter Installation Edit this sectionReport an issue Each adapter is a separate download on the Keycloak download site. We only test and maintain adapter with the most recent version of WildFly available upon the release. Once new version of WildFly is released, the current adapters become deprecated and support for them will be removed after next WildFly release. The other alternative is to switch your applications from WildFly to the JBoss EAP, as the JBoss EAP adapter is supported for much longer period. Install on WildFly 9 or newer or on JBoss EAP 7: $ cd $WILDFLY_HOME $ unzip keycloak-saml-wildfly-adapter-dist.zip Install on JBoss EAP 6.x: $ cd $JBOSS_HOME $ unzip keycloak-saml-eap6-adapter-dist.zip These zip files create new JBoss Modules specific to the WildFly/JBoss EAP SAML Adapter within your WildFly or JBoss EAP distro. After adding the modules, you must then enable the Keycloak SAML Subsystem within your app server’s server configuration: domain.xml or standalone.xml. There is a CLI script that will help you modify your server configuration. Start the server and run the script from the server’s bin directory: WildFly 11 or newer $ cd $JBOSS_HOME $ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install-saml.cli WildFly 10 and older $ cd $JBOSS_HOME $ /bin/boss-cli.sh -c --file=bin/adapter-install-saml.cli It is possible to use the legacy non-Elytron adapter on WildFly 11 or newer as well, meaning you can use adapter-install-saml.cli even on those versions. However, we recommend to use the newer Elytron adapter. The script will add the extension, subsystem, and optional security-domain as described below. ... ... The keycloak security domain should be used with EJBs and other components when you need the security context created in the secured web tier to be propagated to the EJBs (other EE component) you are invoking. Otherwise this configuration is optional. ... For example, if you have a JAX-RS service that is an EJB within your WEB-INF/classes directory, you’ll want to annotate it with the @SecurityDomain annotation as follows: import org.jboss.ejb3.annotation.SecurityDomain; import org.jboss.resteasy.annotations.cache.NoCache; import javax.annotation.security.RolesAllowed; import javax.ejb.EJB; import javax.ejb.Stateless; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import java.util.ArrayList; import java.util.List; @Path(\"customers\") @Stateless @SecurityDomain(\"keycloak\") public class CustomerService { @EJB CustomerDB db; @GET @Produces(\"application/json\") @NoCache @RolesAllowed(\"db_user\") public List getCustomers() { return db.getCustomers(); } } We hope to improve our integration in the future so that you don’t have to specify the @SecurityDomain annotation when you want to propagate a keycloak security context to the EJB tier. JBoss SSO WildFly has built-in support for single sign-on for web applications deployed to the same WildFly instance. This should not be enabled when using Keycloak. 3.1.3. Installing JBoss EAP Adapter from an RPM Edit this sectionReport an issue Install the EAP 7 Adapters from an RPM: With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used. You must subscribe to the JBoss EAP 7 repository before you can install the EAP 7 adapters from an RPM. Prerequisites Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the Red Hat Subscription Management documentation. If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first. Using Red Hat Subscription Manager, subscribe to the JBoss EAP 7 repository using the following command. Replace with either 6 or 7 depending on your Red Hat Enterprise Linux version. $ sudo subscription-manager repos --enable=jb-eap-7-for-rhel--server-rpms Install the EAP 7 adapters for SAML using the following command: $ sudo yum install eap7-keycloak-saml-adapter-sso7_2 The default EAP_HOME path for the RPM installation is /opt/rh/eap7/root/usr/share/wildfly. Run the appropriate module installation script. For the SAML module, enter the following command: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli Your installation is complete. Install the EAP 6 Adapters from an RPM: With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used. You must subscribe to the JBoss EAP 6 repository before you can install the EAP 6 adapters from an RPM. Prerequisites Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the Red Hat Subscription Management documentation. If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first. Using Red Hat Subscription Manager, subscribe to the JBoss EAP 6 repository using the following command. Replace with either 6 or 7 depending on your Red Hat Enterprise Linux version. $ sudo subscription-manager repos --enable=jb-eap-6-for-rhel--server-rpms Install the EAP 6 adapters for SAML using the following command: $ sudo yum install keycloak-saml-adapter-sso7_2-eap6 The default EAP_HOME path for the RPM installation is /opt/rh/eap6/root/usr/share/wildfly. Run the appropriate module installation script. For the SAML module, enter the following command: $ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli Your installation is complete. Per WAR Configuration Edit this sectionReport an issue This section describes how to secure a WAR directly by adding config and editing files within your WAR package. The first thing you must do is create a keycloak-saml.xml adapter config file within the WEB-INF directory of your WAR. The format of this config file is described in the General Adapter Config section. Next you must set the auth-method to KEYCLOAK-SAML in web.xml. You also have to use standard servlet security to specify role-base constraints on your URLs. Here’s an example web.xml file: customer-portal Admins /admin/* admin CONFIDENTIAL Customers /customers/* user CONFIDENTIAL KEYCLOAK-SAML this is ignored currently admin user All standard servlet settings except the auth-method setting. Securing WARs via Keycloak SAML Subsystem Edit this sectionReport an issue You do not have to crack open a WAR to secure it with Keycloak. Alternatively, you can externally secure it via the Keycloak SAML Adapter Subsystem. While you don’t have to specify KEYCLOAK-SAML as an auth-method, you still have to define the security-constraints in web.xml. You do not, however, have to create a WEB-INF/keycloak-saml.xml file. This metadata is instead defined within the XML in your server’s domain.xml or standalone.xml subsystem configuration section. ... The secure-deployment name attribute identifies the WAR you want to secure. Its value is the module-name defined in web.xml with .war appended. The rest of the configuration uses the same XML syntax as keycloak-saml.xmlconfiguration defined in General Adapter Config. An example configuration: 3.1.4. Tomcat SAML adapters Edit this sectionReport an issue To be able to secure WAR apps deployed on Tomcat 6, 7 and 8 you must install the Keycloak Tomcat 6, 7 or 8 SAML adapter into your Tomcat installation. You then have to provide some extra configuration in each WAR you deploy to Tomcat. Let’s go over these steps. Adapter Installation Edit this sectionReport an issue Adapters are no longer included with the appliance or war distribution. Each adapter is a separate download on the Keycloak download site. They are also available as a maven artifact. You must unzip the adapter distro into Tomcat’s lib/ directory. Including adapter’s jars within your WEB-INF/lib directory will not work! The Keycloak SAML adapter is implemented as a Valve and valve code must reside in Tomcat’s main lib/ directory. $ cd $TOMCAT_HOME/lib $ unzip keycloak-saml-tomcat6-adapter-dist.zip or $ unzip keycloak-saml-tomcat7-adapter-dist.zip or $ unzip keycloak-saml-tomcat8-adapter-dist.zip Per WAR Configuration Edit this sectionReport an issue This section describes how to secure a WAR directly by adding config and editing files within your WAR package. The first thing you must do is create a META-INF/context.xml file in your WAR package. This is a Tomcat specific config file and you must define a Keycloak specific Valve. Next you must create a keycloak-saml.xml adapter config file within the WEB-INF directory of your WAR. The format of this config file is described in the General Adapter Config section. Finally you must specify both a login-config and use standard servlet security to specify role-base constraints on your URLs. Here’s an example: customer-portal Customers /* user BASIC this is ignored currently admin user 3.1.5. Jetty SAML Adapters Edit this sectionReport an issue To be able to secure WAR apps deployed on Jetty you must install the Keycloak Jetty 9.x SAML adapter into your Jetty installation. You then have to provide some extra configuration in each WAR you deploy to Jetty. Let’s go over these steps. Jetty 9 Adapter Installation Edit this sectionReport an issue Keycloak has a separate SAML adapter for Jetty 9.x. You then have to provide some extra configuration in each WAR you deploy to Jetty. Let’s go over these steps. Adapters are no longer included with the appliance or war distribution. Each adapter is a separate download on the Keycloak download site. They are also available as a maven artifact. You must unzip the Jetty 9.x distro into Jetty 9.x’s root directory. Including adapter’s jars within your WEB-INF/lib directory will not work! $ cd $JETTY_HOME $ unzip keycloak-saml-jetty92-adapter-dist.zip Next, you will have to enable the keycloak module for your jetty.base. $ cd your-base $ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak Jetty 9 Per WAR Configuration Edit this sectionReport an issue This section describes how to secure a WAR directly by adding config and editing files within your WAR package. The first thing you must do is create a WEB-INF/jetty-web.xml file in your WAR package. This is a Jetty specific config file and you must define a Keycloak specific authenticator within it. Next you must create a keycloak-saml.xml adapter config file within the WEB-INF directory of your WAR. The format of this config file is described in the General Adapter Config section. Finally you must specify both a login-config and use standard servlet security to specify role-base constraints on your URLs. Here’s an example: customer-portal Customers /* user CONFIDENTIAL BASIC this is ignored currently admin user 3.1.6. Java Servlet Filter Adapter Edit this sectionReport an issue If you want to use SAML with a Java servlet application that doesn’t have an adapter for that servlet platform, you can opt to use the servlet filter adapter that Keycloak has. This adapter works a little differently than the other adapters. You still have to specify a /WEB-INF/keycloak-saml.xml file as defined in the General Adapter Config section, but you do not define security constraints in web.xml. Instead you define a filter mapping using the Keycloak servlet filter adapter to secure the url patterns you want to secure. Backchannel logout works a bit differently than the standard adapters. Instead of invalidating the http session it instead marks the session ID as logged out. There’s just no way of arbitrarily invalidating an http session based on a session ID. Backchannel logout does not currently work when you have a clustered application that uses the SAML filter. customer-portal Keycloak Filter org.keycloak.adapters.saml.servlet.SamlFilter Keycloak Filter /* The Keycloak filter has the same configuration parameters available as the other adapters except you must define them as filter init params instead of context params. You can define multiple filter mappings if you have various different secure and unsecure url patterns. You must have a filter mapping that covers /saml. This mapping covers all server callbacks. When registering SPs with an IdP, you must register http[s]://hostname/{context-root}/saml as your Assert Consumer Service URL and Single Logout Service URL. To use this filter, include this maven artifact in your WAR poms: org.keycloak keycloak-saml-servlet-filter-adapter 6.0.1 In order to use Multi Tenancy the keycloak.config.resolver parameter should be passed as a filter parameter. Keycloak Filter org.keycloak.adapters.saml.servlet.SamlFilter keycloak.config.resolver example.SamlMultiTenantResolver 3.1.7. Registering with an Identity Provider Edit this sectionReport an issue For each servlet-based adapter, the endpoint you register for the assert consumer service URL and single logout service must be the base URL of your servlet application with /saml appended to it, that is, https://example.com/contextPath/saml. 3.1.8. Logout Edit this sectionReport an issue There are multiple ways you can logout from a web application. For Java EE servlet containers, you can call HttpServletRequest.logout(). For any other browser application, you can point the browser at any url of your web application that has a security constraint and pass in a query parameter GLO, i.e. http://myapp?GLO=true. This will log you out if you have an SSO session with your browser. Logout in Clustered Environment Internally, the SAML adapter stores a mapping between the SAML session index, principal name (when known), and HTTP session ID. This mapping can be maintained in JBoss application server family (WildFly 10/11, EAP 6/7) across cluster for distributable applications. As a precondition, the HTTP sessions need to be distributed across cluster (i.e. application is marked with tag in application’s web.xml). To enable the functionality, add the following section to your /WEB_INF/web.xml file: For EAP 7, WildFly 10/11: keycloak.sessionIdMapperUpdater.classes org.keycloak.adapters.saml.wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater For EAP 6: keycloak.sessionIdMapperUpdater.classes org.keycloak.adapters.saml.jbossweb.infinispan.InfinispanSessionCacheIdMapperUpdater If the session cache of the deployment is named *deployment-cache*, the cache used for SAML mapping will be named as *deployment-cache*.ssoCache. The name of the cache can be overridden by a context parameterkeycloak.sessionIdMapperUpdater.infinispan.cacheName. The cache container containing the cache will be the same as the one containing the deployment session cache, but can be overridden by a context parameterkeycloak.sessionIdMapperUpdater.infinispan.containerName. By default, the configuration of the SAML mapping cache will be derived from session cache. The configuration can be manually overridden in cache configuration section of the server just the same as other caches. Currently, to provide reliable service, it is recommended to use replicated cache for the SAML session cache. Using distributed cache may lead to results where the SAML logout request would land to a node with no access to SAML session index to HTTP session mapping which would lead to unsuccessful logout. Logout in Cross DC Scenario The cross DC scenario only applies to WildFly 10 and higher, and EAP 7 and higher. Special handling is needed for handling sessions that span multiple data centers. Imagine the following scenario: Login requests are handled within cluster in data center 1. Admin issues logout request for a particular SAML session, the request lands in data center 2. The data center 2 has to log out all sessions that are present in data center 1 (and all other data centers that share HTTP sessions). To cover this case, the SAML session cache described above needs to be replicated not only within individual clusters but across all the data centers e.g. via standalone Infinispan/JDG server: A cache has to be added to the standalone Infinispan/JDG server. The cache from previous item has to be added as a remote store for the respective SAML session cache. Once remote store is found to be present on SAML session cache during deployment, it is watched for changes and the local SAML session cache is updated accordingly. 3.1.9. Obtaining Assertion Attributes Edit this sectionReport an issue After a successful SAML login, your application code may want to obtain attribute values passed with the SAML assertion. HttpServletRequest.getUserPrincipal() returns a Principal object that you can typecast into a Keycloak specific class called org.keycloak.adapters.saml.SamlPrincipal. This object allows you to look at the raw assertion and also has convenience functions to look up attribute values. package org.keycloak.adapters.saml; public class SamlPrincipal implements Serializable, Principal { /** * Get full saml assertion * * @return */ public AssertionType getAssertion() { ... } /** * Get SAML subject sent in assertion * * @return */ public String getSamlSubject() { ... } /** * Subject nameID format * * @return */ public String getNameIDFormat() { ... } @Override public String getName() { ... } /** * Convenience function that gets Attribute value by attribute name * * @param name * @return */ public List getAttributes(String name) { ... } /** * Convenience function that gets Attribute value by attribute friendly name * * @param friendlyName * @return */ public List getFriendlyAttributes(String friendlyName) { ... } /** * Convenience function that gets first value of an attribute by attribute name * * @param name * @return */ public String getAttribute(String name) { ... } /** * Convenience function that gets first value of an attribute by attribute name * * * @param friendlyName * @return */ public String getFriendlyAttribute(String friendlyName) { ... } /** * Get set of all assertion attribute names * * @return */ public Set getAttributeNames() { ... } /** * Get set of all assertion friendly attribute names * * @return */ public Set getFriendlyNames() { ... } } 3.1.10. Error Handling Edit this sectionReport an issue Keycloak has some error handling facilities for servlet based client adapters. When an error is encountered in authentication, the client adapter will call HttpServletResponse.sendError(). You can set up an error-page within your web.xml file to handle the error however you want. The client adapter can throw 400, 401, 403, and 500 errors. 403 /ErrorHandler The client adapter also sets an HttpServletRequest attribute that you can retrieve. The attribute name is org.keycloak.adapters.spi.AuthenticationError. Typecast this object to: org.keycloak.adapters.saml.SamlAuthenticationError. This class can tell you exactly what happened. If this attribute is not set, then the adapter was not responsible for the error code. public class SamlAuthenticationError implements AuthenticationError { public static enum Reason { EXTRACTION_FAILURE, INVALID_SIGNATURE, ERROR_STATUS } public Reason getReason() { return reason; } public StatusResponseType getStatus() { return status; } } 3.1.11. Troubleshooting Edit this sectionReport an issue The best way to troubleshoot problems is to turn on debugging for SAML in both the client adapter and Keycloak Server. Using your logging framework, set the log level to DEBUG for the org.keycloak.samlpackage. Turning this on allows you to see the SAML requests and response documents being sent to and from the server. 3.1.12. Multi Tenancy Edit this sectionReport an issue SAML offers the same functionality as OIDC for Multi Tenancy, meaning that a single target application (WAR) can be secured with multiple Keycloak realms. The realms can be located on the same Keycloak instance or on different instances. To do this, the application must have multiple keycloak-saml.xml adapter configuration files. While you could have multiple instances of your WAR with different adapter configuration files deployed to different context-paths, this may be inconvenient and you may also want to select the realm based on something other than context-path. Keycloak makes it possible to have a custom config resolver, so you can choose which adapter config is used for each request. In SAML, the configuration is only interesting in the login processing; once the user is logged in, the session is authenticated and it does not matter if the keycloak-saml.xml returned is different. For that reason, returning the same configuration for the same session is the correct way to go. To achieve this, create an implementation of org.keycloak.adapters.saml.SamlConfigResolver. The following example uses the Host header to locate the proper configuration and load it and the associated elements from the applications’s Java classpath: package example; import java.io.InputStream; import org.keycloak.adapters.saml.SamlConfigResolver; import org.keycloak.adapters.saml.SamlDeployment; import org.keycloak.adapters.saml.config.parsers.DeploymentBuilder; import org.keycloak.adapters.saml.config.parsers.ResourceLoader; import org.keycloak.adapters.spi.HttpFacade; import org.keycloak.saml.common.exceptions.ParsingException; public class SamlMultiTenantResolver implements SamlConfigResolver { @Override public SamlDeployment resolve(HttpFacade.Request request) { String host = request.getHeader(\"Host\"); String realm = null; if (host.contains(\"tenant1\")) { realm = \"tenant1\"; } else if (host.contains(\"tenant2\")) { realm = \"tenant2\"; } else { throw new IllegalStateException(\"Not able to guess the keycloak-saml.xml to load\"); } InputStream is = getClass().getResourceAsStream(\"/\" + realm + \"-keycloak-saml.xml\"); if (is == null) { throw new IllegalStateException(\"Not able to find the file /\" + realm + \"-keycloak-saml.xml\"); } ResourceLoader loader = new ResourceLoader() { @Override public InputStream getResourceAsStream(String path) { return getClass().getResourceAsStream(path); } }; try { return new DeploymentBuilder().build(is, loader); } catch (ParsingException e) { throw new IllegalStateException(\"Cannot load SAML deployment\", e); } } } You must also configure which SamlConfigResolver implementation to use with the keycloak.config.resolvercontext-param in your web.xml: ... keycloak.config.resolver example.SamlMultiTenantResolver 3.1.13. Migration from older versions Edit this sectionReport an issue Migrating to 1.9.0 SAML SP Client Adapter Changes Keycloak SAML SP Client Adapter now requires a specific endpoint, /saml to be registered with your IdP. The SamlFilter must also be bound to /saml in addition to any other binding it has. This had to be done because SAML POST binding would eat the request input stream and this would be really bad for clients that relied on it. 3.2. mod_auth_mellon Apache HTTPD 模块 Edit this sectionReport an issue The mod_auth_mellon module is an Apache HTTPD plugin for SAML. If your language/environment supports using Apache HTTPD as a proxy, then you can use mod_auth_mellon to secure your web application with SAML. For more details on this module see the mod_auth_mellon GitHub repo. To configure mod_auth_mellon you’ll need: An Identity Provider (IdP) entity descriptor XML file, which describes the connection to Keycloak or another SAML IdP An SP entity descriptor XML file, which describes the SAML connections and configuration for the application you are securing. A private key PEM file, which is a text file in the PEM format that defines the private key the application uses to sign documents. A certificate PEM file, which is a text file that defines the certificate for your application. mod_auth_mellon-specific Apache HTTPD module configuration. If you have already defined and registered the client application within a realm on the Keycloak application server, Keycloak can generate all the files you need except the Apache HTTPD module configuration. To generate the Apache HTTPD module configuration, complete the following steps: Go to the Installation page of your SAML client and select the Mod Auth Mellon files option. mod_auth_mellon config download Click Download to download a zip file that contains the XML descriptor and PEM files you need. 3.2.1. Configuring mod_auth_mellon with Keycloak There are two hosts involved: The host on which Keycloak is running, which will be referred to as $idp_host because Keycloak is a SAML identity provider (IdP). The host on which the web application is running, which will be referred to as $sp_host. In SAML an application using an IdP is called a service provider (SP). All of the following steps need to performed on $sp_host with root privileges. Installing the Packages To install the necessary packages, you will need: Apache Web Server (httpd) Mellon SAML SP add-on module for Apache Tools to create X509 certificates To install the necessary packages, run this command: yum install httpd mod_auth_mellon mod_ssl openssl Creating a Configuration Directory for Apache SAML It is advisable to keep configuration files related to Apache’s use of SAML in one location. Create a new directory named saml2 located under the Apache configuration root /etc/httpd: mkdir /etc/httpd/saml2 Configuring the Mellon Service Provider Configuration files for Apache add-on modules are located in the /etc/httpd/conf.d directory and have a file name extension of .conf. You need to create the /etc/httpd/conf.d/mellon.conf file and place Mellon’s configuration directives in it. Mellon’s configuration directives can roughly be broken down into two classes of information: Which URLs to protect with SAML authentication What SAML parameters will be used when a protected URL is referenced. Apache configuration directives typically follow a hierarchical tree structure in the URL space, which are known as locations. You need to specify one or more URL locations for Mellon to protect. You have flexibility in how you add the configuration parameters that apply to each location. You can either add all the necessary parameters to the location block or you can add Mellon parameters to a common location high up in the URL location hierarchy that specific protected locations inherit (or some combination of the two). Since it is common for an SP to operate in the same way no matter which location triggers SAML actions, the example configuration used here places common Mellon configuration directives in the root of the hierarchy and then specific locations to be protected by Mellon can be defined with minimal directives. This strategy avoids duplicating the same parameters for each protected location. This example has just one protected location: https://$sp_host/protected. To configure the Mellon service provider, complete the following steps: Create the file /etc/httpd/conf.d/mellon.conf with this content: MellonEnable info MellonEndpointPath /mellon/ MellonSPMetadataFile /etc/httpd/saml2/mellon_metadata.xml MellonSPPrivateKeyFile /etc/httpd/saml2/mellon.key MellonSPCertFile /etc/httpd/saml2/mellon.crt MellonIdPMetadataFile /etc/httpd/saml2/idp_metadata.xml AuthType Mellon MellonEnable auth Require valid-user Some of the files referenced in the code above are created in later steps. Creating the Service Provider Metadata In SAML IdPs and SPs exchange SAML metadata, which is in XML format. The schema for the metadata is a standard, thus assuring participating SAML entities can consume each other’s metadata. You need: Metadata for the IdP that the SP utilizes Metadata describing the SP provided to the IdP One of the components of SAML metadata is X509 certificates. These certificates are used for two purposes: Sign SAML messages so the receiving end can prove the message originated from the expected party. Encrypt the message during transport (seldom used because SAML messages typically occur on TLS-protected transports) You can use your own certificates if you already have a Certificate Authority (CA) or you can generate a self-signed certificate. For simplicity in this example a self-signed certificate is used. Because Mellon’s SP metadata must reflect the capabilities of the installed version of mod_auth_mellon, must be valid SP metadata XML, and must contain an X509 certificate (whose creation can be obtuse unless you are familiar with X509 certificate generation) the most expedient way to produce the SP metadata is to use a tool included in the mod_auth_mellon package (mellon_create_metadata.sh). The generated metadata can always be edited later because it is a text file. The tool also creates your X509 key and certificate. SAML IdPs and SPs identify themselves using a unique name known as an EntityID. To use the Mellon metadata creation tool you need: The EntityID, which is typically the URL of the SP, and often the URL of the SP where the SP metadata can be retrieved The URL where SAML messages for the SP will be consumed, which Mellon calls the MellonEndPointPath. To create the SP metadata, complete the following steps: Create a few helper shell variables: fqdn=`hostname` mellon_endpoint_url=\"https://${fqdn}/mellon\" mellon_entity_id=\"${mellon_endpoint_url}/metadata\" file_prefix=\"$(echo \"$mellon_entity_id\" | sed 's/[^A-Za-z.]/_/g' | sed 's/__*/_/g')\" Invoke the Mellon metadata creation tool by running this command: /usr/libexec/mod_auth_mellon/mellon_create_metadata.sh $mellon_entity_id $mellon_endpoint_url Move the generated files to their destination (referenced in the /etc/httpd/conf.d/mellon.conf file created above): mv ${file_prefix}.cert /etc/httpd/saml2/mellon.crt mv ${file_prefix}.key /etc/httpd/saml2/mellon.key mv ${file_prefix}.xml /etc/httpd/saml2/mellon_metadata.xml Adding the Mellon Service Provider to the Keycloak Identity Provider Assumption: The Keycloak IdP has already been installed on the $idp_host. Keycloak supports multiple tenancy where all users, clients, and so on are grouped in what is called a realm. Each realm is independent of other realms. You can use an existing realm in your Keycloak, but this example shows how to create a new realm called test_realm and use that realm. All these operations are performed using the Keycloak administration web console. You must have the admin username and password for $idp_host. To complete the following steps: Open the Admin Console and log on by entering the admin username and password. After logging into the administration console there will be an existing realm. When Keycloak is first set up a root realm, master, is created by default. Any previously created realms are listed in the upper left corner of the administration console in a drop-down list. From the realm drop-down list select Add realm. In the Name field type test_realm and click Create. Adding the Mellon Service Provider as a Client of the Realm In Keycloak SAML SPs are known as clients. To add the SP we must be in the Clients section of the realm. Click the Clients menu item on the left and click Create in the upper right corner to create a new client. Adding the Mellon SP Client To add the Mellon SP client, complete the following steps: Set the client protocol to SAML. From the Client Protocol drop down list, select saml. Provide the Mellon SP metadata file created above (/etc/httpd/saml2/mellon_metadata.xml). Depending on where your browser is running you might have to copy the SP metadata from $sp_host to the machine on which your browser is running so the browser can find the file. Click Save. Editing the Mellon SP Client There are several client configuration parameters we suggest setting: Ensure \"Force POST Binding\" is On. Add paosResponse to the Valid Redirect URIs list: Copy the postResponse URL in \"Valid Redirect URIs\" and paste it into the empty add text fields just below the \"+\". Change \"postResponse\" to \"paosResponse\". (The paosResponse URL is needed for SAML ECP.) Click Save at the bottom. Many SAML SPs determine authorization based on a user’s membership in a group. The Keycloak IdP can manage user group information but it does not supply the user’s groups unless the IdP is configured to supply it as a SAML attribute. To configure the IdP to supply the user’s groups as as a SAML attribute, complete the following steps: Click the Mappers tab of the client. In the upper right corner of the Mappers page, click Create. From the Mapper Type drop-down list select Group list. Set Name to \"group list\". Set the SAML attribute name to \"groups\". Click Save. The remaining steps are performed on $sp_host. Retrieving the Identity Provider Metadata Now that you have created the realm on the IdP you need to retrieve the IdP metadata associated with it so the Mellon SP recognizes it. In the /etc/httpd/conf.d/mellon.conf file created previously, the MellonIdPMetadataFile is specified as /etc/httpd/saml2/idp_metadata.xml but until now that file has not existed on $sp_host. To get that file we will retrieve it from the IdP. Retrieve the file from the IdP by substituting $idp_host with the correct value: curl -k -o /etc/httpd/saml2/idp_metadata.xml \\ https://$idp_host/auth/realms/test_realm/protocol/saml/descriptor Mellon is now fully configured. To run a syntax check for Apache configuration files: apachectl configtest | | Configtest is equivalent to the -t argument to apachectl. If the configuration test shows any errors, correct them before proceeding. | | ---- | ------------------------------------------------------------ | | | | Restart the Apache server: systemctl restart httpd.service You have now set up both Keycloak as a SAML IdP in the test_realm and mod_auth_mellon as SAML SP protecting the URL $sp_host/protected (and everything beneath it) by authenticating against the $idp_host IdP. 4. Docker注册表配置 Edit this sectionReport an issue Docker authentication is disabled by default. To enable see Profiles. This section describes how you can configure a Docker registry to use Keycloak as its authentication server. For more information on how to set up and configure a Docker registry, see the Docker Registry Configuration Guide. 4.1. Docker注册表配置文件安装 For users with more advanced Docker registry configurations, it is generally recommended to provide your own registry configuration file. The Keycloak Docker provider supports this mechanism via the Registry Config File Format Option. Choosing this option will generate output similar to the following: auth: token: realm: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth service: docker-test issuer: http://localhost:8080/auth/realms/master This output can then be copied into any existing registry config file. See the registry config file specification for more information on how the file should be set up, or start with a basic example. Don’t forget to configure the rootcertbundle field with the location of the Keycloak realm’s pulic certificate. The auth configuration will not work without this argument. 4.2. Docker注册表环境变量覆盖安装 Often times it is appropriate to use a simple environment variable override for develop or POC Docker registries. While this approach is usually not recommended for production use, it can be helpful when one requires quick-and-dirty way to stand up a registry. Simply use the Variable Override Format Option from the client installation tab, and an output should appear like the one below: REGISTRY_AUTH_TOKEN_REALM: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth REGISTRY_AUTH_TOKEN_SERVICE: docker-test REGISTRY_AUTH_TOKEN_ISSUER: http://localhost:8080/auth/realms/master Don’t forget to configure the REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE override with the location of the Keycloak realm’s pulic certificate. The auth configuration will not work without this argument. 4.3. Docker撰写YAML文件 This installation method is meant to be an easy way to get a docker registry authenticating against a Keycloak server. It is intended for development purposes only and should never be used in a production or production-like environment. The zip file installation mechanism provides a quickstart for developers who want to understand how the Keycloak server can interact with the Docker registry. In order to configure: From the desired realm, create a client configuration. At this point you won’t have a Docker registry - the quickstart will take care of that part. Choose the \"Docker Compose YAML\" option from the installation tab and download the .zip file Unzip the archive to the desired location, and open the directory. Start the Docker registry with docker-compose up it is recommended that you configure the Docker registry client in a realm other than 'master', since the HTTP Basic auth flow will not present forms. Once the above configuration has taken place, and the keycloak server and Docker registry are running, docker authentication should be successful: [user ~]#??docker login localhost:5000 -u $username Password: ******* Login Succeeded 5. 客户端注册 Edit this sectionReport an issue In order for an application or service to utilize Keycloak it has to register a client in Keycloak. An admin can do this through the admin console (or admin REST endpoints), but clients can also register themselves through the Keycloak client registration service. The Client Registration Service provides built-in support for Keycloak Client Representations, OpenID Connect Client Meta Data and SAML Entity Descriptors. The Client Registration Service endpoint is /auth/realms//clients-registrations/. The built-in supported providers are: default - Keycloak Client Representation (JSON) install - Keycloak Adapter Configuration (JSON) openid-connect - OpenID Connect Client Metadata Description (JSON) saml2-entity-descriptor - SAML Entity Descriptor (XML) The following sections will describe how to use the different providers. 5.1. 认证 To invoke the Client Registration Services you usually need a token. The token can be a bearer token, an initial access token or a registration access token. There is an alternative to register new client without any token as well, but then you need to configure Client Registration Policies (see below). 5.1.1. Bearer Token The bearer token can be issued on behalf of a user or a Service Account. The following permissions are required to invoke the endpoints (see Server Administration Guide for more details): create-client or manage-client - To create clients view-client or manage-client - To view clients manage-client - To update or delete client If you are using a bearer token to create clients it’s recommend to use a token from a Service Account with only the create-client role (see Server Administration Guide for more details). 5.1.2. Initial Access Token The recommended approach to registering new clients is by using initial access tokens. An initial access token can only be used to create clients and has a configurable expiration as well as a configurable limit on how many clients can be created. An initial access token can be created through the admin console. To create a new initial access token first select the realm in the admin console, then click on Realm Settings in the menu on the left, followed by Client Registration in the tabs displayed in the page. Then finally click on Initial Access Tokens sub-tab. You will now be able to see any existing initial access tokens. If you have access you can delete tokens that are no longer required. You can only retrieve the value of the token when you are creating it. To create a new token click on Create. You can now optionally add how long the token should be valid, also how many clients can be created using the token. After you click on Save the token value is displayed. It is important that you copy/paste this token now as you won’t be able to retrieve it later. If you forget to copy/paste it, then delete the token and create another one. The token value is used as a standard bearer token when invoking the Client Registration Services, by adding it to the Authorization header in the request. For example: Authorization: bearer eyJhbGciOiJSUz... 5.1.3. Registration Access Token When you create a client through the Client Registration Service the response will include a registration access token. The registration access token provides access to retrieve the client configuration later, but also to update or delete the client. The registration access token is included with the request in the same way as a bearer token or initial access token. Registration access tokens are only valid once, when it’s used the response will include a new token. If a client was created outside of the Client Registration Service it won’t have a registration access token associated with it. You can create one through the admin console. This can also be useful if you loose the token for a particular client. To create a new token find the client in the admin console and click on Credentials. Then click on Generate registration access token. 5.2. Keycloak表示 The default client registration provider can be used to create, retrieve, update and delete a client. It uses Keycloak Client Representation format which provides support for configuring clients exactly as they can be configured through the admin console, including for example configuring protocol mappers. To create a client create a Client Representation (JSON) then perform an HTTP POST request to /auth/realms//clients-registrations/default. It will return a Client Representation that also includes the registration access token. You should save the registration access token somewhere if you want to retrieve the config, update or delete the client later. To retrieve the Client Representation perform an HTTP GET request to /auth/realms//clients-registrations/default/. It will also return a new registration access token. To update the Client Representation perform an HTTP PUT request with the updated Client Representation to:/auth/realms//clients-registrations/default/. It will also return a new registration access token. To delete the Client Representation perform an HTTP DELETE request to: /auth/realms//clients-registrations/default/ 5.3. Keycloak适配器配置 The installation client registration provider can be used to retrieve the adapter configuration for a client. In addition to token authentication you can also authenticate with client credentials using HTTP basic authentication. To do this include the following header in the request: Authorization: basic BASE64(client-id + ':' + client-secret) To retrieve the Adapter Configuration then perform an HTTP GET request to /auth/realms//clients-registrations/install/. No authentication is required for public clients. This means that for the JavaScript adapter you can load the client configuration directly from Keycloak using the above URL. 5.4. OpenID连接动态客户端注册 Keycloak implements OpenID Connect Dynamic Client Registration, which extends OAuth 2.0 Dynamic Client Registration Protocol and OAuth 2.0 Dynamic Client Registration Management Protocol. The endpoint to use these specifications to register clients in Keycloak is /auth/realms//clients-registrations/openid-connect[/]. This endpoint can also be found in the OpenID Connect Discovery endpoint for the realm, /auth/realms//.well-known/openid-configuration. 5.5. SAML实体描述符 The SAML Entity Descriptor endpoint only supports using SAML v2 Entity Descriptors to create clients. It doesn’t support retrieving, updating or deleting clients. For those operations the Keycloak representation endpoints should be used. When creating a client a Keycloak Client Representation is returned with details about the created client, including a registration access token. To create a client perform an HTTP POST request with the SAML Entity Descriptor to /auth/realms//clients-registrations/saml2-entity-descriptor. 5.6. 使用CURL的示例 The following example creates a client with the clientId myclient using CURL. You need to replace eyJhbGciOiJSUz… with a proper initial access token or bearer token. curl -X POST \\ -d '{ \"clientId\": \"myclient\" }' \\ -H \"Content-Type:application/json\" \\ -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\ http://localhost:8080/auth/realms/master/clients-registrations/default 5.7. 使用Java客户端注册API的示例 The Client Registration Java API makes it easy to use the Client Registration Service using Java. To use include the dependency org.keycloak:keycloak-client-registration-api:>VERSION from Maven. For full instructions on using the Client Registration refer to the JavaDocs. Below is an example of creating a client. You need to replace eyJhbGciOiJSUz… with a proper initial access token or bearer token. String token = \"eyJhbGciOiJSUz...\"; ClientRepresentation client = new ClientRepresentation(); client.setClientId(CLIENT_ID); ClientRegistration reg = ClientRegistration.create() .url(\"http://localhost:8080/auth\", \"myrealm\") .build(); reg.auth(Auth.token(token)); client = reg.create(client); String registrationAccessToken = client.getRegistrationAccessToken(); 5.8. 客户端注册政策 Keycloak currently supports 2 ways how can be new clients registered through Client Registration Service. Authenticated requests - Request to register new client must contain either Initial Access Token or Bearer Tokenas mentioned above. Anonymous requests - Request to register new client doesn’t need to contain any token at all Anonymous client registration requests are very interesting and powerful feature, however you usually don’t want that anyone is able to register new client without any limitations. Hence we have Client Registration Policy SPI, which provide a way to limit who can register new clients and under which conditions. In Keycloak admin console, you can click to Client Registration tab and then Client Registration Policies sub-tab. Here you will see what policies are configured by default for anonymous requests and what policies are configured for authenticated requests. The anonymous requests (requests without any token) are allowed just for creating (registration) of new clients. So when you register new client through anonymous request, the response will contain Registration Access Token, which must be used for Read, Update or Delete request of particular client. However using this Registration Access Token from anonymous registration will be then subject to Anonymous Policy too! This means that for example request for update client also needs to come from Trusted Host if you have Trusted Hosts policy. Also for example it won’t be allowed to disable Consent Required when updating client and when Consent Required policy is present etc. Currently we have these policy implementations: Trusted Hosts Policy - You can configure list of trusted hosts and trusted domains. Request to Client Registration Service can be sent just from those hosts or domains. Request sent from some untrusted IP will be rejected. URLs of newly registered client must also use just those trusted hosts or domains. For example it won’t be allowed to set Redirect URIof client pointing to some untrusted host. By default, there is not any whitelisted host, so anonymous client registration is de-facto disabled. Consent Required Policy - Newly registered clients will have Consent Allowed switch enabled. So after successful authentication, user will always see consent screen when he needs to approve permissions (client scopes). It means that client won’t have access to any personal info or permission of user unless user approves it. Protocol Mappers Policy - Allows to configure list of whitelisted protocol mapper implementations. New client can’t be registered or updated if it contains some non-whitelisted protocol mapper. Note that this policy is used for authenticated requests as well, so even for authenticated request there are some limitations which protocol mappers can be used. Client Scope Policy - Allow to whitelist Client Scopes, which can be used with newly registered or updated clients. There are no whitelisted scopes by default; only the client scopes, which are defined as Realm Default Client Scopes are whitelisted by default. Full Scope Policy - Newly registered clients will have Full Scope Allowed switch disabled. This means they won’t have any scoped realm roles or client roles of other clients. Max Clients Policy - Rejects registration if current number of clients in the realm is same or bigger than specified limit. It’s 200 by default for anonymous registrations. Client Disabled Policy - Newly registered client will be disabled. This means that admin needs to manually approve and enable all newly registered clients. This policy is not used by default even for anonymous registration. 6. 客户端注册 CLI Edit this sectionReport an issue The Client Registration CLI is a command-line interface (CLI) tool for application developers to configure new clients in a self-service manner when integrating with Keycloak. It is specifically designed to interact with Keycloak Client Registration REST endpoints. It is necessary to create or obtain a client configuration for any application to be able to use Keycloak. You usually configure a new client for each new application hosted on a unique host name. When an application interacts with Keycloak, the application identifies itself with a client ID so Keycloak can provide a login page, single sign-on (SSO) session management, and other services. You can configure application clients from a command line with the Client Registration CLI, and you can use it in shell scripts. To allow a particular user to use Client Registration CLI the Keycloak administrator typically uses the Admin Console to configure a new user with proper roles or to configure a new client and client secret to grant access to the Client Registration REST API. 6.1. 配置新常规用户以使用客户端注册CLI Log in to the Admin Console (for example, http://localhost:8080/auth/admin) as admin. Select a realm to administer. If you want to use an existing user, select that user to edit; otherwise, create a new user. Select Role Mappings > Client Roles > realm-management. If you are in the master realm, select NAME-realm, where NAME is the name of the target realm. You can grant access to any other realm to users in the master realm. Select Available Roles > manage-client to grant a full set of client management permissions. Another option is to choose view-clients for read-only or create-client to create new clients. | | These permissions grant the user the capability to perform operations without the use of Initial Access Token or Registration Access Token. | | ---- | ------------------------------------------------------------ | | | | It is possible to not assign any realm-management roles to a user. In that case, a user can still log in with the Client Registration CLI but cannot use it without an Initial Access Token. Trying to perform any operations without a token results in a 403 Forbidden error. The Administrator can issue Initial Access Tokens from the Admin Console through the Realm Settings > Client Registration > Initial Access Token menu. 6.2. 配置客户端以与客户端注册CLI一起使用 By default, the server recognizes the Client Registration CLI as the admin-cli client, which is configured automatically for every new realm. No additional client configuration is necessary when logging in with a user name. Create a new client (for example, reg-cli) if you want to use a separate client configuration for the Client Registration CLI. Toggle the Standard Flow Enabled setting it to Off. Strengthen the security by configuring the client Access Type as Confidential and selecting Credentials > ClientId and Secret. You can configure either Client Id and Secret or Signed JWT under the Credentials tab . Enable service accounts if you want to use a service account associated with the client by selecting a client to edit in the Clients section of the Admin Console. Under Settings, change the Access Type to Confidential, toggle the Service Accounts Enabled setting to On, and click Save. Click Service Account Roles and select desired roles to configure the access for the service account. For the details on what roles to select, see Configuring a new regular user for use with Client Registration CLI. Toggle the Direct Access Grants Enabled setting it to On if you want to use a regular user account instead of a service account. If the client is configured as Confidential, provide the configured secret when running kcreg config credentialsby using the --secret option. Specify which clientId to use (for example, --client reg-cli) when running kcreg config credentials. With the service account enabled, you can omit specifying the user when running kcreg config credentials and only provide the client secret or keystore information. 6.3. 安装客户端注册CLI The Client Registration CLI is packaged inside the Keycloak Server distribution. You can find execution scripts inside the bindirectory. The Linux script is called kcreg.sh, and the Windows script is called kcreg.bat. Add the Keycloak server directory to your PATH when setting up the client for use from any location on the file system. For example, on: Linux: $ export PATH=$PATH:$KEYCLOAK_HOME/bin $ kcreg.sh Windows: c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin c:\\> kcreg KEYCLOAK_HOME refers to a directory where the Keycloak Server distribution was unpacked. 6.4. 使用客户端注册CLI Start an authenticated session by logging in with your credentials. Run commands on the Client Registration REST endpoint. For example, on: Linux: $ kcreg.sh config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli $ kcreg.sh create -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]' $ kcreg.sh get my_client Windows: c:\\> kcreg config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli c:\\> kcreg create -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\" c:\\> kcreg get my_client | | In a production environment, Keycloak has to be accessed with https: to avoid exposing tokens to network sniffers. | | ---- | ------------------------------------------------------------ | | | | If a server’s certificate is not issued by one of the trusted certificate authorities (CAs) that are included in Java’s default certificate truststore, prepare a truststore.jks file and instruct the Client Registration CLI to use it. For example, on: Linux: $ kcreg.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks Windows: c:\\> kcreg config truststore --trustpass %PASSWORD% %HOMEPATH%\\.keycloak\\truststore.jks 6.4.1. Logging in Specify a server endpoint URL and a realm when you log in with the Client Registration CLI. Specify a user name or a client id, which results in a special service account being used. When using a user name, you must use a password for the specified user. When using a client ID, you use a client secret or a Signed JWT instead of a password. Regardless of the login method, the account that logs in needs proper permissions to be able to perform client registration operations. Keep in mind that any account in a non-master realm can only have permissions to manage clients within the same realm. If you need to manage different realms, you can either configure multiple users in different realms, or you can create a single user in the master realm and add roles for managing clients in different realms. You cannot configure users with the Client Registration CLI. Use the Admin Console web interface or the Admin Client CLI to configure users. See Server Administration Guide for more details. When kcreg successfully logs in, it receives authorization tokens and saves them in a private configuration file so the tokens can be used for subsequent invocations. See Working with alternative configurations for more information on configuration files. See the built-in help for more information on using the Client Registration CLI. For example, on: Linux: $ kcreg.sh help Windows: c:\\> kcreg help See kcreg config credentials --help for more information about starting an authenticated session. 6.4.2. Working with alternative configurations By default, the Client Registration CLI automatically maintains a configuration file at a default location, ./.keycloak/kcreg.config, under the user’s home directory. You can use the --config option to point to a different file or location to mantain multiple authenticated sessions in parallel. It is the safest way to perform operations tied to a single configuration file from a single thread. Do not make the configuration file visible to other users on the system. The configuration file contains access tokens and secrets that should be kept private. You might want to avoid storing secrets inside a configuration file by using the --no-config option with all of your commands, even though it is less convenient and requires more token requests to do so. Specify all authentication information with each kcreg invocation. 6.4.3. Initial Access and Registration Access Tokens Developers who do not have an account configured at the Keycloak server they want to use can use the Client Registration CLI. This is possible only when the realm administrator issues a developer an Initial Access Token. It is up to the realm administrator to decide how and when to issue and distribute these tokens. The realm administrator can limit the maximum age of the Initial Access Token and the total number of clients that can be created with it. Once a developer has an Initial Access Token, the developer can use it to create new clients without authenticating with kcreg config credentials. The Initial Access Token can be stored in the configuration file or specified as part of the kcreg create command. For example, on: Linux: $ kcreg.sh config initial-token $TOKEN $ kcreg.sh create -s clientId=myclient or $ kcreg.sh create -s clientId=myclient -t $TOKEN Windows: c:\\> kcreg config initial-token %TOKEN% c:\\> kcreg create -s clientId=myclient or c:\\> kcreg create -s clientId=myclient -t %TOKEN% When using an Initial Access Token, the server response includes a newly issued Registration Access Token. Any subsequent operation for that client needs to be performed by authenticating with that token, which is only valid for that client. The Client Registration CLI automatically uses its private configuration file to save and use this token with its associated client. As long as the same configuration file is used for all client operations, the developer does not need to authenticate to read, update, or delete a client that was created this way. See Client Registration for more information about Initial Access and Registration Access Tokens. Run the kcreg config initial-token --help and kcreg config registration-token --help commands for more information on how to configure tokens with the Client Registration CLI. 6.4.4. Creating a client configuration The first task after authenticating with credentials or configuring an Initial Access Token is usually to create a new client. Often you might want to use a prepared JSON file as a template and set or override some of the attributes. The following example shows how to read a JSON file, override any client id it may contain, set any other attributes, and print the configuration to a standard output after successful creation. Linux: $ kcreg.sh create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s 'redirectUris=[\"/myclient/*\"]' -o Windows: C:\\> kcreg create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s \"redirectUris=[\\\"/myclient/*\\\"]\" -o Run the kcreg create --help for more information about the kcreg create command. You can use kcreg attrs to list available attributes. Keep in mind that many configuration attributes are not checked for validity or consistency. It is up to you to specify proper values. Remember that you should not have any id fields in your template and should not specify them as arguments to the kcreg create command. 6.4.5. Retrieving a client configuration You can retrieve an existing client by using the kcreg get command. For example, on: Linux: $ kcreg.sh get myclient Windows: C:\\> kcreg get myclient You can also retrieve the client configuration as an adapter configuration file, which you can package with your web application. For example, on: Linux: $ kcreg.sh get myclient -e install > keycloak.json Windows: C:\\> kcreg get myclient -e install > keycloak.json Run the kcreg get --help command for more information about the kcreg get command. 6.4.6. Modifying a client configuration There are two methods for updating a client configuration. One method is to submit a complete new state to the server after getting the current configuration, saving it to a file, editing it, and posting it back to the server. For example, on: Linux: $ kcreg.sh get myclient > myclient.json $ vi myclient.json $ kcreg.sh update myclient -f myclient.json Windows: C:\\> kcreg get myclient > myclient.json C:\\> notepad myclient.json C:\\> kcreg update myclient -f myclient.json The second method fetches the current client, sets or deletes fields on it, and posts it back in one step. For example, on: Linux: $ kcreg.sh update myclient -s enabled=false -d redirectUris Windows: C:\\> kcreg update myclient -s enabled=false -d redirectUris You can also use a file that contains only changes to be applied so you do not have to specify too many values as arguments. In this case, specify --merge to tell the Client Registration CLI that rather than treating the JSON file as a full, new configuration, it should treat it as a set of attributes to be applied over the existing configuration. For example, on: Linux: $ kcreg.sh update myclient --merge -d redirectUris -f mychanges.json Windows: C:\\> kcreg update myclient --merge -d redirectUris -f mychanges.json Run the kcreg update --help command for more information about the kcreg update command. 6.4.7. Deleting a client configuration Use the following example to delete a client. Linux: $ kcreg.sh delete myclient Windows: C:\\> kcreg delete myclient Run the kcreg delete --help command for more information about the kcreg delete command. 6.4.8. Refreshing invalid Registration Access Tokens When performing a create, read, update, and delete (CRUD) operation using the --no-config mode, the Client Registration CLI cannot handle Registration Access Tokens for you. In that case, it is possible to lose track of the most recently issued Registration Access Token for a client, which makes it impossible to perform any further CRUD operations on that client without authenticating with an account that has manage-clients permissions. If you have permissions, you can issue a new Registration Access Token for the client and have it printed to a standard output or saved to a configuration file of your choice. Otherwise, you have to ask the realm administrator to issue a new Registration Access Token for your client and send it to you. You can then pass it to any CRUD command via the --token option. You can also use the kcreg config registration-token command to save the new token in a configuration file and have the Client Registration CLI automatically handle it for you from that point on. Run the kcreg update-token --help command for more information about the kcreg update-token command. 6.5. 故障排除 Q: When logging in, I get an error: *Parameter client_assertion_type is missing [invalid_client]. A: This error means your client is configured with Signed JWT token credentials, which means you have to use the --keystore parameter when logging in. 7. 令牌交换 Edit this sectionReport an issue Token Exchange is Technology Preview and is not fully supported. This feature is disabled by default.To enable start the server with -Dkeycloak.profile=preview or -Dkeycloak.profile.feature.token_exchange=enabled . For more details see Profiles. In Keycloak, token exchange is the process of using a set of credentials or token to obtain an entirely different token. A client may want to invoke on a less trusted application so it may want to downgrade the current token it has. A client may want to exchange a Keycloak token for a token stored for a linked social provider account. You may want to trust external tokens minted by other Keycloak realms or foreign IDPs. A client may have a need to impersonate a user. Here’s a short summary of the current capabilities of Keycloak around token exchange. A client can exchange an existing Keycloak token created for a specific client for a new token targeted to a different client A client can exchange an existing Keycloak token for an external token, i.e. a linked Facebook account A client can exchange an external token for a Keycloak token. A client can impersonate a user Token exchange in Keycloak is a very loose implementation of the OAuth Token Exchange specification at the IETF. We have extended it a little, ignored some of it, and loosely interpreted other parts of the specification. It is a simple grant type invocation on a realm’s OpenID Connect token endpoint. /auth/realms/{realm}/protocol/openid-connect/token It accepts form parameters (application/x-www-form-urlencoded) as input and the output depends on the type of token you requested an exchange for. Token exchange is a client endpoint so requests must provide authentication information for the calling client. Public clients specify their client identifier as a form parameter. Confidential clients can also use form parameters to pass their client id and secret, Basic Auth, or however your admin has configured the client authentication flow in your realm. Here’s a list of form parameters client_id REQUIRED MAYBE. This parameter is required for clients using form parameters for authentication. If you are using Basic Auth, a client JWT token, or client cert authentication, then do not specify this parameter. client_secret REQUIRED MAYBE. This parameter is required for clients using form parameters for authentication and using a client secret as a credential. Do not specify this parameter if client invocations in your realm are authenticated by a different means. grant_type REQUIRED. The value of the parameter must be urn:ietf:params:oauth:grant-type:token-exchange. subject_token OPTIONAL. A security token that represents the identity of the party on behalf of whom the request is being made. It is required if you are exchanging an existing token for a new one. subject_issuer OPTIONAL. Identifies the issuer of the subject_token. It can be left blank if the token comes from the current realm or if the issuer can be determined from the subject_token_type. Otherwise it is required to be specified. Valid values are the alias of an Identity Provider configured for your realm. Or an issuer claim identifier configured by a specific Identity Provider. subject_token_type OPTIONAL. This parameter is the type of the token passed with the subject_token parameter. This defaults to urn:ietf:params:oauth:token-type:access_token if the subject_token comes from the realm and is an access token. If it is an external token, this parameter may or may not have to be specified depending on the requirements of thesubject_issuer. requested_token_type OPTIONAL. This parameter represents the type of token the client wants to exchange for. Currently only oauth and OpenID Connect token types are supported. The default value for this depends on whether the is urn:ietf:params:oauth:token-type:refresh_token in which case you will be returned both an access token and refresh token within the response. Other appropriate values are urn:ietf:params:oauth:token-type:access_tokenand urn:ietf:params:oauth:token-type:id_token audience OPTIONAL. This parameter specifies the target client you want the new token minted for. requested_issuer OPTIONAL. This parameter specifies that the client wants a token minted by an external provider. It must be the alias of an Identity Provider configured within the realm. requested_subject OPTIONAL. This specifies a username or user id if your client wants to impersonate a different user. scope NOT IMPLEMENTED. This parameter represents the target set of OAuth and OpenID Connect scopes the client is requesting. It is not implemented at this time but will be once Keycloak has better support for scopes in general. We currently only support OpenID Connect and OAuth exchanges. Support for SAML based clients and identity providers may be added in the future depending on user demand. A successful response from an exchange invocation will return the HTTP 200 response code with a content type that depends on the requested-token-type and requested_issuer the client asks for. OAuth requested token types will return a JSON document as described in the OAuth Token Exchange specification. { \"access_token\" : \".....\", \"refresh_token\" : \".....\", \"expires_in\" : \"....\" } Clients requesting a refresh token will get back both an access and refresh token in the response. Clients requesting only access token type will only get an access token in the response. Expiration information may or may not be included for clients requesting an external issuer through the requested_issuer paramater. Error responses generally fall under the 400 HTTP response code category, but other error status codes may be returned depending on the severity of the error. Error responses may include content depending on the requested_issuer. OAuth based exchanges may return a JSON document as follows: { \"error\" : \"....\" \"error_description\" : \"....\" } Additional error claims may be returned depending on the exchange type. For example, OAuth Identity Providers may include an additional account-link-url claim if the user does not have a link to an identity provider. This link can be used for a client initiated link request. Token exchange setup requires knowledge of fine grain admin permissions (See the Server Administration Guide for more information). You will need to grant clients permission to exchange. This is discussed more later in this chapter. The rest of this chapter discusses the setup requirements and provides examples for different exchange scenarios. For simplicity’s sake, let’s call a token minted by the current realm as an internal token and a token minted by an external realm or identity provider as an external token. 7.1. 内部令牌到内部令牌交换 With an internal token to token exchange you have an existing token minted to a specific client and you want to exchange this token for a new one minted for a different target client. Why would you want to do this? This generally happens when a client has a token minted for itself, and needs to make additional requests to other applications that require different claims and permissions within the access token. Other reasons this type of exchange might be required is if you need to perform a \"permission downgrade\" where your app needs to invoke on a less trusted app and you don’t want to propagate your current access token. 7.1.1. Granting Permission for the Exchange Clients that want to exchange tokens for a different client need to be authorized in the admin console to do so. You’ll need to define a token-exchange fine grain permission in the target client you want permission to exchange to. Target Client Permission Toggle the Permissions Enabled switch to ON. Target Client Permission You should see a token-exchange link on the page. Click that to start defining the permission. It will bring you to this page. Target Client Exchange Permission Setup You’ll have to define a policy for this permission. Click the Authorization link, go to the Policies tab and create a Client Policy. Client Policy Creation Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the target client’s token-exchange permission and add the client policy you just defined. Apply Client Policy Your client now has permission to invoke. If you do not do this correctly, you will get a 403 Forbidden response if you try to make an exchange. 7.1.2. Making the Request When your client is exchanging an existing token for a token targeting another client, you must use the audienceparameter. This parameter must be the client identifier for the target client that you configured in the admin console. curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:refresh_token\" \\ -d \"audience=target-client\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token The subject_token parameter must be an access token for the target realm. If your requested_token_type parameter is a refresh token type, then the response will contain both an access token, refresh token, and expiration. Here’s an example JSON response you get back from this call. { \"access_token\" : \"....\", \"refresh_token\" : \"....\", \"expires_in\" : 3600 } 7.2. 外部令牌交换的内部令牌 You can exchange a realm token for an externl token minted by an external identity provider. This external identity provider must be configured within the Identity Provider section of the admin console. Currently only OAuth/OpenID Connect based external identity providers are supported, this includes all social providers. Keycloak does not perform a backchannel exchange to the external provider. So if the account is not linked, you will not be able to get the external token. To be able to obtain an external token one of these conditions must be met: The user must have logged in with the external identity provider at least once The user must have linked with the external identity provider through the User Account Service The user account was linked through the external identity provider using Client Initiated Account Linking API. Finally, the external identity provider must have been configured to store tokens, or, one of the above actions must have been performed with the same user session as the internal token you are exchanging. If the account is not linked, the exchange response will contain a link you can use to establish it. This is discussed more in the Making the Request section. 7.2.1. Granting Permission for the Exchange Internal to external token exchange requests will be denied with a 403, Forbidden response until you grant permission for the calling client to exchange tokens with the external identity provider. To grant permission to the client you must go to the identity provider’s configuration page to the Permissions tab. Identity Provider Permission Toggle the Permissions Enabled switch to true. Identity Provider Permission You should see a token-exchange link on the page. Click that to start defining the permission. It will bring you to this page. Identity Provider Exchange Permission Setup You’ll have to define a policy for this permission. Click the Authorization link, go to the Policies tab and create a Client Policy. Client Policy Creation Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the identity providers’s token-exchange permission and add the client policy you just defined. Apply Client Policy Your client now has permission to invoke. If you do not do this correctly, you will get a 403 Forbidden response if you try to make an exchange. 7.2.2. Making the Request When your client is exchanging an existing internal token to an external one, you must provide the requested_issuerparameter. The parameter must be the alias of a configured identity provider. curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"requested_issuer=google\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token The subject_token parameter must be an access token for the target realm. The requested_token_type parameter must be urn:ietf:params:oauth:token-type:access_token or left blank. No other requested token type is supported at this time. Here’s an example successful JSON response you get back from this call. { \"access_token\" : \"....\", \"expires_in\" : 3600 \"account-link-url\" : \"https://....\" } If the external identity provider is not linked for whatever reason, you will get an HTTP 400 response code with this JSON document: { \"error\" : \"....\", \"error_description\" : \"...\" \"account-link-url\" : \"https://....\" } The error claim will be either token_expired or not_linked. The account-link-url claim is provided so that the client can perform Client Initiated Account Linking. Most (all?) providers are requiring linking through browser OAuth protocol. With the account-link-url just add a redirect_uri query parameter to it and you can forward browsers to perform the link. 7.3. 外部令牌到内部令牌交换 You can trust and exchange external tokens minted by external identity providers for internal tokens. This can be used to bridge between realms or just to trust tokens from your social provider. It works similarly to an identity provider browser login in that a new user is imported into your realm if it doesn’t exist. The current limitation on external token exchanges is that if the external token maps to an existing user an exchange will not be allowed unless the existing user already has an account link to the external identity provider. When the exchange is complete, a user session will be created within the realm, and you will receive an access and or refresh token depending on the requested_token_type parameter value. You should note that this new user session will remain active until it times out or until you call the logout endpoint of the realm passing this new access token. These types of changes required a configured identity provider in the admin console. SAML identity providers are not supported at this time. Twitter tokens cannot be exchanged either. 7.3.1. Granting Permission for the Exchange Before external token exchanges can be done, you must grant permission for the calling client to make the exchange. This permission is granted in the same manner as internal to external permission is granted. If you also provide an audience parameter whose value points to a different client other than the calling one, you must also grant the calling client permission to exchange to the target client specific in the audience parameter. How to do this is discussed earlier in this section. 7.3.2. Making the Request The subject_token_type must either be urn:ietf:params:oauth:token-type:access_token or urn:ietf:params:oauth:token-type:jwt. If the type is urn:ietf:params:oauth:token-type:access_token you must specify the subject_issuer parameter and it must be the alias of the configured identity provider. If the type is urn:ietf:params:oauth:token-type:jwt, the provider will be matched via the issuer claim within the JWT which must be the alias of the provider, or a registered issuer within the providers configuration. For validation, if the token is an access token, the provider’s user info service will be invoked to validate the token. A successful call will mean that the access token is valid. If the subject token is a JWT and if the provider has signature validation enabled, that will be attempted, otherwise, it will default to also invoking on the user info service to validate the token. By default, the internal token minted will use the calling client to determine what’s in the token using the protocol mappers defined for the calling client. Alternatively, you can specify a different target client using the audience parameter. curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ -d \"subject_issuer=myOidcProvider\" \\ --data-urlencode \"subject_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"audience=target-client\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token If your requested_token_type parameter is a refresh token type, then the response will contain both an access token, refresh token, and expiration. Here’s an example JSON response you get back from this call. { \"access_token\" : \"....\", \"refresh_token\" : \"....\", \"expires_in\" : 3600 } 7.4. 模拟 For internal and external token exchanges, the client can request on behalf of a user to impersonate a different user. For example, you may have an admin application that needs to impersonate a user so that a support engineer can debug a problem. 7.4.1. Granting Permission for the Exchange The user that the subject token represents must have permission to impersonate other users. See the Server Administration Guide on how to enable this permission. It can be done through a role or through fine grain admin permissions. 7.4.2. Making the Request Make the request as described in other chapters except additionally specify the request_subject parameter. The value of this parameter must be a username or user id. curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"subject_token=....\" \\ --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\ -d \"audience=target-client\" \\ -d \"requested_subject=wburke\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token 7.5. 直接赤裸裸的模拟 You can make an internal token exchange request without providing a subject_token. This is called a direct naked impersonation because it places a lot of trust in a client as that client can impersonate any user in the realm. You might need this to bridge for applications where it is impossible to obtain a subject token to exchange. For example, you may be integrating a legacy application that performs login directly with LDAP. In that case, the legacy app is able to authenticate users itself, but not able to obtain a token. It is very risky to enable direct naked impersonation for a client. If the client’s credentials are ever stolen, that client can impersonate any user in the system. 7.5.1. Granting Permission for the Exchange If the audience parameter is provided, then the calling client must have permission to exchange to the client. How to set this up is discussed earlier in this chapter. Additionally, the calling client must be granted permission to impersonate users. In the admin console, go to the Usersscreen and click on the Permissions tab. Users Permission Toggle the Permissions Enabled switch to true. Identity Provider Permission You should see a impersonation link on the page. Click that to start defining the permission. It will bring you to this page. Users Impersonation Permission Setup You’ll have to define a policy for this permission. Click the Authorization link, go to the Policies tab and create a Client Policy. Client Policy Creation Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the users' impersonation permission and add the client policy you just defined. Apply Client Policy Your client now has permission to impersonate users. If you do not do this correctly, you will get a 403 Forbidden response if you try to make this type of exchange. Public clients are not allowed to do direct naked impersonations. 7.5.2. Making the Request To make the request, simply specify the requested_subject parameter. This must be the username or user id of a valid user. You can also specify an audience parameter if you wish. curl -X POST \\ -d \"client_id=starting-client\" \\ -d \"client_secret=geheim\" \\ --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\ -d \"requested_subject=wburke\" \\ http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token 7.6. 使用服务帐户展开权限模型 When granting clients permission to exchange, you don’t necessarily have to manually enable those permissions for each and every client. If the client has a service account associated with it, you can use a role to group permissions together and assign exchange permissions by assigning a role to the client’s service account. For example, you might define a naked-exchange role and any service account that has that role can do a naked exchange. 7.7. 交换漏洞 When you start allowing token exchanges, there’s various things you have to both be aware of and careful of. The first is public clients. Public clients do not have or require a client credential in order to perform an exchange. Anybody that has a valid token will be able to impersonate the public client and perform the exchanges that public client is allowed to perform. If there are any untrustworthy clients that are managed by your realm, public clients may open up vulnerabilities in your permission models. This is why direct naked exchanges do not allow public clients and will abort with an error if the calling client is public. It is possible to exchange social tokens provided by Facebook, Google, etc. for a realm token. Be careful and vigilante on what the exchange token is allowed to do as its not hard to create fake accounts on these social websites. Use default roles, groups, and identity provider mappers to control what attributes and roles are assigned to the external social user. Direct naked exchanges are quite dangerous. You are putting a lot of trust in the calling client that it will never leak out its client credentials. If those credentials are leaked, then the thief can impersonate anybody in your system. This is in direct contrast to confidential clients that have existing tokens. You have two factors of authentication, the access token and the client credentials, and you’re only dealing with one user. So use direct naked exchanges sparingly. Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-13 10:39:23 "}}